<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Sonata Help</title>
</head><body>
<style type="text/css">
H3 {text-align:center;}
P {line-height:1.3;}
UL {column-count: 4; border: 2px solid blue; border-radius: 5px; padding: 5px 5px 5px 30px;}
DIV {margin-left: 10px;}
.EXAMPLE {border: 2px solid blue; border-radius: 5px; background: lightgrey; padding: 15px; margin: 10px 0px; color:navy; }
.DESCRIPT {text-align:center; font-style:italic; }
</style>
<a name="Top"></a>
<div><h1 align="center">Sonata Lua Calculus</h1>
<ul>
<li><a href="#Ap">asciiplot</a></li>
<li><a href="#Int">bigint</a></li>
<li><a href="#Z">complex</a></li>
<li><a href="#C">const</a></li>
<li><a href="#D">data</a></li>
<li><a href="#Geo">geodesy</a></li>
<li><a href="#Gp">gnuplot</a></li>
<li><a href="#Graph">graph</a></li>
<li><a href="#Lens">lens</a></li>
<li><a href="#Main">main</a></li>
<li><a href="#Mat">matrix</a></li>
<li><a href="#Num">numeric</a></li>
<li><a href="#Poly">polynomial</a></li>
<li><a href="#Quat">quaternion</a></li>
<li><a href="#Qb">qubit</a></li>
<li><a href="#Rand">random</a></li>
<li><a href="#Rat">rational</a></li>
<li><a href="#Spec">special</a></li>
<li><a href="#Sym">symbolic</a></li>
<li><a href="#U">units</a></li>
</ul></div>
<div><h3># About #</h3>
<p><br>
Sonata is a Lua based program for mathematical calculations.<br>
<br>
<b>USAGE</b>:<br>
	lua [-i] sonata.lua [flag] [arg1 arg2 ...]<br>
(option '-i' can be used for working in native Lua interpreter)<br>
<br>
<b>FLAGS</b>:<br>
	-h	Get this help message.<br>
	-e	Evaluate command line expression.<br>
		e.g. -e "2+2"<br>
<br>
	--doc	Generating a documentation page.<br>
		e.g. --doc ru<br>
	--test	Run unit tests for a given module. Execute for all modules if no name is specified.<br>
		e.g. --test array<br>
	--new	Generating a template for a new module.<br>
		e.g. --new  matrices  Mat  "Matrix operations."<br>
	--lang	Generation or updating of the localization file.<br>
		e.g. --lang eo<br>
	 No flag  - Evaluate file(s).<br>
<br>
<b>VERSION</b>: 0.9.40<br>
<br>
<b>MODULES</b>: bigint, matrix, qubit, main, symbolic, geodesy, complex, rational, polynomial, const, special, random, gnuplot, data, numeric, lens, quaternion, units, graph, asciiplot.<br>
<br>
<b>BUGS</b>: mail to 'mikhel.sk@gmail.com'<br>
</p>
<p><a href="https://github.com/mikhel1984/sonata/wiki">Project Wiki</a></p></div>
<div><a name="Ap"></a>
<h3># Ap (asciiplot) #</h3>
<p class="descript">Use pseudography for data visualization.</p>
<p><b>Ap (width_N=73, height_N=21) --> new_F</b> - Create new asciiplot.<br>
<b>Ap:concat(F1, F2) --> str</b> - Horizontal concatenation of figures with the same height. Equal to F1..F2.<br>
<b>F:addPoint(x_d, y_d, char_s='*')</b> - Add point (x,y) using char.<br>
<b>F:addPose(row_N, col_N, char_s='*')</b> - Add character to the given position.<br>
<b>F:addString(row_N, col_N, str)</b> - Add string to the given position.<br>
<b>F:axes() --> tbl</b> - Get {'size','log','range','view','fix'} for each axis.<br>
<b>F:bar(t, y_N=2, x_N=1)</b> - Plot bar diargram for the given data.<br>
<b>F:contour(fn, {level=5, view='XY'}) --> nil|str</b> - Find contours of projection for a function fn(x,y). Views: XY, XZ, YZ. Use 'view=concat' for concatenated string output.<br>
<b>F:copy() --> cpy_F</b> - Create a copy of the object.<br>
<b>F:legend(str_t)</b> - Update legend.<br>
<b>F:plot(...)</b> - Plot arguments in form 't', 't1,t1', 'fn,nm', 'fn1,fn2' etc.<br>
<b>F:reset()</b> - Prepare a clean canvas.<br>
<b>F:scale(factor_d | src_F)</b> - Change figure size w.r.t. initial size.<br>
<b>F:setX(par_t)</b> - X axis configuration, set 'range' ({a,b}), 'view' ('min'/'mid'/'max'/false), 'log'-arithm (true/false), 'fix' range (true/false), 'size'.<br>
<b>F:setY(par_t)</b> - Y axis configuration, set 'range' ({a,b}), 'view' ('min'/'mid'/'max'/false), 'log'-arithm (true/false), 'fix' range (true/false), 'size'.<br>
<b>F:setZ(par_t)</b> - Z axis configuration, set 'range' ({a,b}), 'view' ('min'/'mid'/'max'/false), 'log'-arithm (true/false), 'fix' range (true/false), 'size'.<br>
<b>F:title(str)</b> - Set new title.<br>
<b>F:tplot(data_t, cols_t={x=1, polar=false})</b> - Plot the table data, choose columns if need.<br>
<b>Plot(...)</b> - Plot arguments in form 't', 't1,t1', 'fn,nm', 'fn1,fn2' etc.<br></p>
<pre class="example">

-- use 'asciiplot'
Ap = require 'matlib.asciiplot'

-- figure with default size
fig1 = Ap()
info = fig1:axes()
ans = info.x.size             -->  Ap.WIDTH

-- default axis position
ans = info.x.view             -->  'mid'

-- print functions
fig1:setX {range={-3.14, 3.14}}   -- default is {-1, 1}
fig1:plot(math.sin, 'sin', math.cos, 'cos')
fig1:title 'Trigonometry'
print(fig1)

-- make a copy
fig11 = fig1:copy()
print(fig11)

-- print data
x = {1,2,3,4,5}
y = {1,3,5,7,9}
fig1:plot(x,y)
print(fig1)

-- combine different sources
fig1:setY {view='min'}  -- left axis
fig1:plot(x,'single',x,y,'pair',math.log,'function')
print(fig1)

-- define arbitrary figure size
-- odd is preferable
fig2 = Ap(21,11)    -- width=21, height = 11
fig2:plot(function (x) return 2*x end)
print(fig2)

-- show table
tbl = {}
for x = 0, 3, 0.1 do
  --             x      y1          y2
  tbl[#tbl+1] = {x, math.sin(x), math.cos(x)}
end
fig2:setX {view='min'}  -- down
fig2:tplot(tbl)
print(fig2)

-- plot only y2, don't rescale
fig2:setX {range={-1, 4}}
fig2:setY {range={0, 1}, fix=true}
fig2:tplot(tbl, {2})
print(fig2)

-- polar plot for the table
fig7 = Ap()
fig7:tplot(tbl, {polar=true})
fig7:legend {'sin', 'cos'}
print(fig7)

-- scale figure w.r.t. initial size
fig1:scale(0.8)
ans = fig1:axes().x.size      -->  59

-- horizontal concatenation
-- first
fig1:scale(0.5)   -- half of initial size
fig1:setX {range={0, 1.57}, view='min'}
fig1:setY {view='mid'}
fig1:plot(sin, 'sin')
fig1:title 'First'
-- second
fig2:scale(fig1)      -- set equal size
fig2:setX {range={0, 1.57}}
fig2:plot(cos, 'cos')
fig2:title 'Second'
str = Ap:concat(fig1, fig2)   -- similar to fig1..fig2 for 2 objects
print(str)

-- call 'API' functions
fig3 = Ap()
fig3:scale(0.5)
-- no axes and limits
fig3:setX {range={-2,2}, view=false}
fig3:setY {range={-1,4}, view=false}
fig3:reset()
-- set function
for x = -1.2, 1.2, 0.1 do
  fig3:addPoint(x, x*x-0.5, '*')
end
-- set to position
fig3:addPose(3, 13, '#')   -- characters
fig3:addPose(3, 24, '#')
fig3:addString(2,3,'Hi!')  -- text
print(fig3)

-- print surface contours
fig4 = Ap()
fig4:setX {range={-5, 5}}
fig4:setY {range={-5, 5}}
fig4:contour(function (x,y) return x*x - y*y end)
print(fig4)

-- bar diagram
data = {}
k = 2*3.14/20
for i = 1, 20 do data[#data+1] = {k*i, math.sin(k*i)} end
fig5 = Ap()
fig5:bar(data)
print(fig5)

-- use log scale
fig6 = Ap()
fig6:setX {range={-10, 10}}
fig6:setY {log=true}
fig6:plot(math.exp)
print(fig6)

-- simplified call, use range -1...1
-- change it via table if need
Plot(math.cos, 'cos', {-3,3}, {-1,1}, 'range correct')

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Int"></a>
<h3># Int (bigint) #</h3>
<p class="descript">Operations with arbitrary long integers.</p>
<p><b>B:F() --> B!</b> - Return factorial of non-negative integer B.<br>
<b>B:FF() --> B!!</b> - Find double factorial.<br>
<b>B:abs() --> abs_B</b> - Return module of arbitrary long number.<br>
<b>B:digits(N=10) --> tbl</b> - Get digits in the new numeric base.<br>
<b>B:factorize() --> prime_t</b> - Find prive multipliers.<br>
<b>B:float() --> num</b> - Represent current big integer as number if it possible.<br>
<b>B:isPrime(method_s=nil) --> bool</b> - Check if the number is prime. Set 'Fermat' method to use the small Fermat theorem.<br>
<b>B:random() --> rand_B</b> - Generate pseudo-random value from 0 to B.<br>
<b>B:sign() --> int</b> - Return +1/-1.<br>
<b>B:subF() --> !B</b> - Find subfactorial of the number.<br>
<b>Int (num|str|tbl) --> new_B</b> - Create number from integer, string or table.<br>
<b>Int:C(n, k, isRepeat=false) --> combinations_B</b> - Number of combinations C(n,k) with or without repetition.<br>
<b>Int:P(n, k, isRepeat=false) --> permutaions_B</b> - Find permutations with or without repetition.<br>
<b>Int:gcd(...) --> B</b> - Find the greatest common divisor for the given integers.<br>
<b>Int:lcm(...) --> B</b> - Find the least common multiple for the given integers.<br>
<b>Int:ratF(num_B, denom_B) --> num!/denom!</b> - Find ratio of factorials.<br></p>
<pre class="example">
-- use 'bigint'
Int = require 'matlib.bigint'

-- from integer
a = Int(123)
ans = a:float()               -->  123

-- from string
b = Int('456')
ans = b:float()               -->  456

-- 'default' form for base <= 16
ans = Int('0xABC')            -->  Int('10,11,12:16')

-- define base explicitly
g = Int('-1,2,3:10')
ans = g:float()               -->  -123

-- check positive/negative
ans = g:sign()                -->  -1

-- check equality
ans = (a == -g)               -->  true

-- arithmetical operations
ans = (a+b):float()           -->  579

ans = (a-b):float()           -->  -333

ans = (a*Int(2)):float()      -->  246

ans = (b/2):float()           -->  228

ans = (b%a):float()           -->  87

ans = (a^3):float()           -->  1860867

ans = (a > b)                 -->  false

-- absolute value
ans = Int('-25'):abs():float()  -->  25

-- factorial
c = Int(50):F()
ans = c:float() / 3E64       --1>  1.0

-- ratio of factorials
ans = Int:ratF(Int(50), Int(49))  -->  Int(50)

-- subfactorial
ans = Int(4):subF()           --> Int(9)

-- digits for a different numeric base
v = g:digits(60)
ans = tostring(v)             -->  '-2,3:60'

-- improve view
c16 = c:digits(16)
print(c16:group(4))

-- number of digits
ans = #v                      -->  2

-- 2nd digit (from the lowest)
ans = v[2]                    -->  2

-- base and sign
ans = v.base == 60 and v.sign == -1  -->  true

-- print digits
print(v)

-- back to bigint
ans = Int(v)                  -->  g

-- comparison
ans = (a ~= g)                -->  true

-- simple print
print(a)

-- find permutations
ans = Int:P(10, 5)            -->  Int(30240)

-- find combinations
ans = Int:C(10, 3)            -->  Int(120)

-- with repititions
ans = Int:C(10, 3, true)      -->  Int(220)

-- check if it prime
-- iterate though multipliers
ans = Int(1229):isPrime()     -->  true

-- Fermat theorem
ans = Int(1229):isPrime('Fermat') -->  true

-- factorize
t = b:factorize()
ans = #t                      -->  5

-- check factorization
ans = 1
for i = 1,#t do
  ans = ans * (t[i]:float())
end                           -->  456

-- pseudo-random number
-- from 0 to b
print(b:random())

-- greatest common divisor
ans = Int:gcd(a,b,g):float()  -->  3

-- least common multiple
ans = Int:lcm(a,b):float()    --> 18696

-- with numbers
-- result is bigint
ans = a + 1.0                 -->  Int(124)

-- result is float
ans = a - 0.5                 -->  122.5

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Z"></a>
<h3># Z (complex) #</h3>
<p class="descript">Manipulations with complex numbers.</p>
<p><b>C:abs() --> float</b> - Return module of complex number.<br>
<b>C:acos() --> y_C</b> - Complex inverse cosine.<br>
<b>C:acosh() --> y_C</b> - Complex inverse hyperbolic cosine.<br>
<b>C:arg() --> float</b> - Return argument of complex number.<br>
<b>C:asin() --> y_C</b> - Complex inverse sine.<br>
<b>C:asinh() --> y_C</b> - Complex inverse hyperbolic sine.<br>
<b>C:atan() --> y_C</b> - Complex inverse tangent.<br>
<b>C:atanh() --> y_C</b> - Complex inverse hyperbolic tangent.<br>
<b>C:conj() --> conj_C</b> - Return the complex conjugate. Equal to ~C.<br>
<b>C:cos() --> y_C</b> - Return cosine of a complex number.<br>
<b>C:cosh() --> y_C</b> - Return hyperbolic cosine of a real or complex number.<br>
<b>C:exp() --> y_C</b> - Return exponent in for complex argument.<br>
<b>C:im() --> var</b> - Get imaginary part.<br>
<b>C:log() --> y_C</b> - Complex logarithm.<br>
<b>C:re() --> var</b> - Get real part.<br>
<b>C:sin() --> y_C</b> - Return sinus of a complex number.<br>
<b>C:sinh() --> y_C</b> - Return hyperbolic sinus of a complex number.<br>
<b>C:sqrt() --> y_C</b> - Return square root. Result can be real of complex.<br>
<b>C:tan() --> y_C</b> - Return tangent of a complex number.<br>
<b>C:tanh() --> y_C</b> - Return hyperbolic tangent of a complex number.<br>
<b>Z (re=0, im=0) --> new_C</b> - Create new complex number.<br>
<b>Z:E(phy) --> cos(phy)+i*sin(phy)</b> - Make complex number exp(i*phy).<br>
<b>Z:i(x=1) --> new_C</b> - Return x*i.<br></p>
<pre class="example">

-- use 'complex'
Z = require 'matlib.complex'

-- real and imaginary pars
a = Z(1,2)
-- or just imaginary
b = Z(0,3)

-- imaginary unit
ans = 3+Z:i(4)                -->  Z(3,4)

-- use polar form
ans = 2*Z:E(1.57):im()     --2>  2.0

-- arithmetic
ans = a + b                   -->  Z(1,5)

ans = Z:i(3) - b              -->  0

ans = a * b                   -->  Z(-6,3)

-- call complex unit I = Z:i()
ans = a / I                   -->  Z(2,-1)

-- power can be complex
c = Z(1,1)^Z(2,-2)

-- real part
ans = c:re()                 --3>  6.147

-- imaginary part
ans = c:im()                 --1>  7.4

-- comparison
ans = (a == b)                -->  false

ans = (a ~= b)                -->  true

-- absolute value
ans = a:abs()                --3>  2.236

-- argument (angle, rad)
ans = a:arg()                --3>  1.107

-- conjugated number
ans = a:conj()                -->  Z(1,-2)

-- some functions after import
-- become default, such as
d = Z(-2):sqrt()
ans = d:im()                 --3>  1.414

-- exp
ans = d:exp():re()           --3>  0.156

-- log
ans = d:log():re()           --3>  0.3465

-- sin
ans = d:sin():im()           --3>  1.935

-- cos
ans = d:cos():re()           --3>  2.178

-- tan
ans = d:tan():re()           --1>  0

-- sinh
ans = d:sinh():re()          --1>  0

-- cosh
ans = d:cosh():re()          --3>  0.156

-- tanh
ans = d:tanh():im()          --3>  6.334

-- asin
z = Z(2,3)
ans = z:asin():im()          --3>  1.983

-- acos
ans = z:acos():re()          --2>  1.000

-- atan
ans = z:atan():im()          --3>  0.229

-- asinh
ans = z:asinh():re()         --3>  1.968

-- acosh
ans = z:acosh():im()         --1>  1.000

-- atanh
ans = z:atanh():re()         --3>  0.146

-- show
print(a)

-- update env on import
-- update some methods
ans = sqrt(-1)                -->  I

ans = log(-1):im()           --3>  math.pi

--</pre>
<a href="#Top">Top</a></div>
<div><a name="C"></a>
<h3># C (const) #</h3>
<p class="descript">Collection of constants.</p>
<p><b>C.astro.au --> 1.5E11</b> - Astronomic unit.<br>
<b>C.astro.k --> 0.017</b> - Gaussian gravitational constant.<br>
<b>C.astro.ly --> 9.5E15</b> - One light year.<br>
<b>C.astro.pc --> 3.1E16</b> - One parsec.<br>
<b>C.math.e --> 2.72</b> - Base of the natural logarithm.<br>
<b>C.math.gamma --> 0.577</b> - Euler-Mascheroni constant.<br>
<b>C.math.phi --> 1.62</b> - Golden ratio.<br>
<b>C.phi.Da --> 1.7E-27</b> - Unified atomic mass unit.<br>
<b>C.phy.G --> 6.7E-11</b> - Gravitational constant.<br>
<b>C.phy.NA --> 6E23</b> - Avogadro's number.<br>
<b>C.phy.R --> 8.31</b> - Universal gas constant.<br>
<b>C.phy.Rinf --> 1.1E7</b> - Rydberg constant.<br>
<b>C.phy.Vm --> 2.2E-2</b> - Volume of one mole of ideal gas.<br>
<b>C.phy.c --> 3E8</b> - Speed of light.<br>
<b>C.phy.e --> 1.6E-19</b> - Electron charge.<br>
<b>C.phy.eps0 --> 8.8E-12</b> - Permittivity of free space.<br>
<b>C.phy.g --> 9.81</b> - Acceleration of free fall.<br>
<b>C.phy.h --> 6.6E-34</b> - Planck's constant.<br>
<b>C.phy.k --> 1.4E-23</b> - Boltzmann's constant.<br>
<b>C.phy.mu0 --> 1.2E-6</b> - Permeability of free space.<br>
<b>C.phy.sigma --> 5.6E-8</b> - Stefan-Boltzmann constant.<br>
<b>C:add(name_s, value, units_s=nil)</b> - Create new constant.<br>
<b>C:remove(name_s) --> bool</b> - Delete user-defined constant.<br></p>
<pre class="example">

-- use 'const'
C = require 'matlib.const'
-- external dependencies, can be loaded implicitly
require 'matlib.units'  -- convert into Unit object

-- charge of electron
ans = C.phy.e * 1E19         --3>  1.602

-- convert to Unit object (add _U)
e = C.phy.e_U
ans = e:u()                   -->  C.phy.e_u_

-- change units
ans = e 'nC'                 --3>  C.phy.e * 1E9

-- create "immutable" value
C:add('myConst', 10)
ans = C.myConst               -->  10

-- modification generates error
ans = pcall(function() C.myConst = 0 end)  -->  false

-- remove constant
C:remove('myConst')
ans = C.myConst               -->  nil

--</pre>
<a href="#Top">Top</a></div>
<div><a name="D"></a>
<h3># D (data) #</h3>
<p class="descript">Data processing and statistics.</p>
<p><b>D:Fn(expr_s, arg_N=2) --> fn</b> - Generate function from expression of x1, x2 etc.<br>
<b>D:T(src_t) --> new_T</b> - Get reference to 'transposed' table.<br>
<b>D:copy(t) --> copy_t</b> - Make deep copy of the table.<br>
<b>D:cov(data_t) --> cov_M</b> - Find covariance matrix for list of vectors.<br>
<b>D:cov2(xs_t, ys_t) --> float</b> - Find covariance value for two vectors.<br>
<b>D:csvread(file_s, delim_s=',') --> tbl</b> - Read delimiter separated data as Lua table.<br>
<b>D:csvwrite(file_s, data_t, delim_s=',')</b> - Save Lua table as delimiter separated data into file.<br>
<b>D:filter(in_t, fn|str|tbl) --> out_t</b> - Get result of the table filtering. Condition is boolean function, string or table of weights.<br>
<b>D:freq(data_t) --> tbl</b> - Return table with frequencies of elements.<br>
<b>D:geomean(data_t, weigh_t=nil) --> num</b> - Geometrical mean.<br>
<b>D:harmmean(data_t, weigh_t=nil) --> num</b> - Harmonic mean.<br>
<b>D:histcounts(data_t, edges_t|N=10) --> sum_t, edges_t</b> - Calculate amount of bins. Edges can be either number or table.<br>
<b>D:is(data_t, fn|str) --> weigh_t</b> - Find weights using condition (boolean function or string).<br>
<b>D:isNot(data_t, fn|str) --> weigh_t</b> - Find inverted weights using condition (boolean function or string).<br>
<b>D:max(data_t) --> var, ind_N</b> - Maximal element and its index.<br>
<b>D:md(data_t, names_t=nil, row_fn=nil) --> str</b> - Markdown-like table representation. Rows can be processed using function row_fn(t)-->t.<br>
<b>D:mean(data_t, wight_t=nil) --> num</b> - Calculate average value. Weights can be used.<br>
<b>D:median(data_t) --> num</b> - Median of the list.<br>
<b>D:min(data_t) --> var, ind_N</b> - Minimal element and its index.<br>
<b>D:moment(order_N, data_t, weigth_t=nil) --> num</b> - Central moment of order N, weights can be defined.<br>
<b>D:range(begin_d, end_d, step_d=±1) --> new_R</b> - Generate range object.<br>
<b>D:reduce(fn|str, data_t, initial=datadata_t[1]_t[1]) --> var</b> - Apply function to its previous result and next element.<br>
<b>D:ref(src_t, begin_N=1, end_N=#src_t) --> new_R</b> - Return reference to the range of elements.<br>
<b>D:std(data_t, weight_t=nil) --> num</b> - Standard deviation. Weights can be used.<br>
<b>D:sum(data_t) --> var</b> - Get sum of all elements.<br>
<b>D:zip(fn|str, ...) --> tbl</b> - Sequentially apply function to list of tables.<br></p>
<pre class="example">

-- use 'data'
D = require 'matlib.data'
-- external dependencies, can be loaded implicitly
require 'matlib.special'
require 'matlib.matrix'

-- initial data (tables)
X = {3,2,5,6,3,4,3,1}
-- weight
W = {1,1,0}
-- enought to define w[i] ~= 1
W[5] = 2; W[6] = 2
-- average
ans = D:mean(X)              --3>  3.375

-- standard deviation
ans = D:std(X,W)             --3>  1.314

-- covariance for two vectors
Y = {0,2,1,3,7,5,8,4}
a = D:cov2(X,Y)
ans = a                      --3>  -0.65625

-- covariance matrix
tmp = D:cov({X,Y})
ans = tmp[1][2]              --3>  a

-- maximum element and index
_,ans = D:max(X)              -->  4

-- median
ans = D:median(X)             -->  3

-- table of frequencies
tmp = D:freq(X)
ans = tmp[3]                  -->  3

-- central moment
ans = D:moment(2,X)          --3>  2.234

-- summ of elements
ans = D:sum(X)                -->  27

-- minimum value
ans = D:min(X)                -->  1

-- geometrical mean
ans = D:geomean(X)           --3>  2.995

-- harmonic mean
ans = D:harmmean(X,W)        --3>  2.571

-- check if X[i] > 2
a = D:is(X, "x1 > 2")
ans = a[1]                    -->  1

-- get elements X[i] > 2
tmp = D:filter(X, a)
ans = tmp[1]                  -->  X[1]

-- filtration using explicit function
fn = function (x) return x > 2 end
tmp = D:filter(X, fn)
ans = tmp[1]                  -->  X[1]

-- generate new list
-- use 'lazy' function definition
tmp = D:zip("{x1-x2, x1+x2}", X, Y)
ans = tmp[1][2]               -->  X[1]+Y[1]

-- find histogram
a,b = D:histcounts(X, 3)
ans = b[1]                    -->  2.25

-- define edges
a,b = D:histcounts(X,{2,4,7})
ans = a[1]                    -->  1

-- table range reference
a = D:ref(X, 3, 6)
ans = #a                      -->  4

ans = a[1]                    -->  X[3]

-- dsv write
nm = os.tmpname()
-- separate elements with ';'
t = {{1,2,3},{4,5,6}}
D:csvwrite(nm, t, ';')

-- dsv read
-- with separator ';'
tt = D:csvread(nm, ';')
ans = tt[2][2]                -->  t[2][2]

-- reference to 'transposed' table
b = D:T(t)
ans = b[3][2]                 -->  t[2][3]

-- Markdown-like print for a table
print(D:md(t))

-- add column names and some processing
fn = function (v)
  return {v[1]^2, 0.5*(v[2]+v[3])}
end
c = D:md(t, {'sq', 'avg'}, fn)
print(c)

-- even numbers
b = D:range(2,10,2)
ans = b[2]                    -->  4

-- linear transformations
-- with range Range objects
b2 = 2*b + 4
ans = b2[1]                   -->  8

-- apply function
c = b:map(math.sin)
ans = c[1]                   --3>  0.909

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Geo"></a>
<h3># Geo (geodesy) #</h3>
<p class="descript">Coordinate transformations and other geodetic tasks.</p>
<p><b>E.blhInto[E2] --> fn</b> - Get function to transform geodetic coordinates from E to E2 system using the Molodensky method.<br>
<b>E.xyzInto[E2] --> fn</b> - Get function to transform coordinates from E to E2 system.<br>
<b>E:bl2utm(blh_t) --> utm_t</b> - Find UTM projection for the given coordinates.<br>
<b>E:into(E2, lin, rot, m)</b> - Define transormation rules between ellipsoids.<br>
<b>E:solveDir(blh_t, az1_d, dist_d) --> blh_t, az2_d</b> - Solve direct geodetic problem, find second point position and its orientation if the first point, azimuth and distance are given.<br>
<b>E:solveInv(blh1_t, blh2_t) --> dist_d, az1_d, az2_d</b> - Solve inverse geodetic problem, find distance and azimuths for two points.<br>
<b>E:toBLH(xyz_t) --> blh_t</b> - Transform Cartesian coordinates to Geodetic.<br>
<b>E:toXYZ(blh_t) --> xyz_t</b> - Transform Geodetic coordinates to Cartesian.<br>
<b>E:utm2bl(utm_t) --> blh_t</b> - Find Geodetic coordinates for the given UTM pose and zone.<br>
<b>Geo (param_t=nil) --> E</b> - Produce ellipsoid with the given params {'a', 'f'}.<br>
<b>Geo:deg2dms(deg_d) --> deg, min, sec</b> - Return degrees, minutes and seconds for the given angle value.<br>
<b>Geo:dms2deg(deg_d, min_d=0, sec_d=0) --> deg</b> - Convert degrees, minutes and seconds to degrees.<br>
<b>Geo:grav(latitude_d) --> acceleration</b> - International gravity formula, angle in degrees.<br>
<b>Geo:hashDecode(hash_s) --> coord_t, range_t</b> - Find central point and range of the zone.<br>
<b>Geo:hashEncode(coord_t, letter_N=6) --> hash_s</b> - Find hash for the given point.<br></p>
<pre class="example">

-- use 'geodesy'
Geo = require 'matlib.geodesy'

-- generate random from number -1 to 1
rnd = function () return 2*math.random()-1 end
-- random coordinates (degrees and meters)
t0 = {B=rnd()*90, L=rnd()*180, H=rnd()*1000}
-- latitude, longitude, height
print(t0.B, t0.L, t0.H)

-- default is WGS84
wgs84 = Geo()
-- BLH to XYZ
t1 = wgs84:toXYZ(t0)
print(t1.X, t1.Y, t1.Z)

-- XYZ to BHL
t2 = wgs84:toBLH(t1)
print(t2.B, t2.L, t2.H)
ans = t2.B                   --3>  t0.B

ans = t2.L                   --3>  t0.L

ans = t2.H                   --3>  t0.H

-- add another ellipsoid
-- use russian PZ90
pz90 = Geo { a = 6378136, f = 1/298.25784,
  -- additional parameters (optional)
  GMe = 398600.4418E9,  -- m^3/s^2
  omega = 7.292115E-5,  -- rad/s, rotation rate
  J2 = 1082.62575E-6,   -- dynamic form factor
}
-- define transformation
pz90:into( wgs84,
  {-1.1, -0.3, -0.9},          -- linear
  {0, 0, math.rad(-0.2/3600)}, -- angular
  -0.12E-6)                    -- scale
-- transform XYZ from WGS84 to PZ90
print(pz90)  -- show

-- transform
xyz_wgs84_pz90 = wgs84.xyzInto[pz90]
t3 = xyz_wgs84_pz90(t1)

-- backward transformation
xyz_pz90_wgs84 = pz90.xyzInto[wgs84]
t4 = xyz_pz90_wgs84(t3)
ans = t4.X                   --2>  t1.X

-- datum transformation
blh_wgs84_pz90 = wgs84.blhInto[pz90]
t5 = blh_wgs84_pz90(t0)

-- UTM to lat/lon
utm = {N=5601281, E=625394, zone=42, hs='N'}
ll = wgs84:utm2bl(utm)
ans = ll.B                   --2>  50.55

ans = ll.L                   --2>  70.77

-- lat/lon to UTM
utm1 = wgs84:bl2utm(ll)
ans = utm1.N                 --2>  utm.N

ans = utm1.E                 --2>  utm.E

ans = utm1.zone               -->  utm.zone

-- inverse problem
p1 = {B=rnd()*50, L=rnd()*50}
p2 = {B=rnd()*50, L=rnd()*50}
s, a1, a2 = wgs84:solveInv(p1,p2)
ans = (s >= 0)                -->  true

-- direct problem
p3, a3 = wgs84:solveDir(p1,a1,s)
ans = a3                     --2>  a2

ans = p3.B                   --2>  p2.B

-- equator acceleration
ans = Geo:grav(0)            --1>  9.78

-- find geohash
h = Geo:hashEncode(p1, 7)
print(h)

-- position from geohash
p4, _ = Geo:hashDecode(h)
ans = p4.B                   --2>  p1.B

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Gp"></a>
<h3># Gp (gnuplot) #</h3>
<p class="descript">Interface for calling Gnuplot from Sonata.</p>
<p><b>G:add(curve_v)</b> - Add new curve to figure.<br>
<b>G:copy() --> cpy_G</b> - Get copy of the plot options.<br>
<b>G:show()</b> - Plot data, represented as Lua table.<br>
<b>Gp () --> new_G</b> - Prepare Gnuplot object.<br>
<b>Gp.keys</b> -   Options / examples:<br>
{math.sin, title='sin'}       -- plot using function, define in Lua; add legend<br>
{'sin.dat', ln=1, lw=2}       -- plot data from file, use given color and width<br>
{tbl, with='lines'}           -- plot data from Lua table, use lines<br>
title='Graph name'            -- set title<br>
xrange={0,10}                 -- range of x from 0 to 10<br>
yrange={-2,2}                 -- range of y<br>
zrange={0,5}                  -- range of z<br>
trange={1,2}                  -- range for parametric functions<br>
xtitle='A', ytitle='B'        -- axes names<br>
terminal='jpeg'               -- save result as jpeg image<br>
output='my_plot.jpg'          -- file name<br>
parametric=true               -- create parametric plot<br>
size='square'                 -- set square size<br>
polar=true                    -- use polar coordinate system<br>
grid='polar'                  -- polar grid<br>
legend=false                  -- don't use legend<br>
surface=true                  -- plot surface in 3D<br>
samples=200                   -- define number of points<br>
raw='set pm3d'                -- set Gnuplot options manually<br>
<br>
<b>Gp:plot(x1_t, [y1_t, nm_s, x2_t,..])</b> - 'x' is list of numbers, 'y' is either list or functin, 'nm' - curve name.<br>
<b>Gp:polarplot(x1_t, y1_t, [nm_s, x2_t, y2_t,..])</b> - Make polar plot. 'x' is list of numbers, 'y' is either list or functin, 'nm' - curve name.<br>
<b>Gp:surfplot(x1_t, y1_t, fn1, [nm_s, x2_t, y2_t,..])</b> - Make surfacе plot. 'x' and 'y' are lists of numbers, 'fn' is functin, 'nm' - surface name.<br>
<b>Gp:tplot(var, [x_N, y1_N, y2_N,..])</b> - Plot table, matrix or data file. Optional elements define columns.<br>
<b>Gp:tpolar(var, [x_N, y1_N, y2_N,..])</b> - Polar plot for table, matrix or data file. Optional elements define columns.<br>
<b>Gp:tsurf(var, [x_N, y_N, z1_N, z2_N,..])</b> - Surface plot for table, matrix or data file. Optional elements define columns.<br></p>
<pre class="example">

-- use 'gnuplot'
Gp = require 'matlib.gnuplot'
Gp.testmode = true -- just for testing

-- simple plot
t1 = {1,2,3,4,5}
t2 = {2,4,6,4,2}
-- in the dialog call "plot(t1,t2,'some curve')"
Gp:plot(t1,t2,'some curve')

-- simplified function plot
Gp:plot(t1, math.sin, 'sin')

-- name can be skipped
Gp:plot(t1, math.sin, t1, math.cos)

-- plot table (or matrix, or datafile)
arr = {}
for i = 1,50 do
  x = 0.1*i
  arr[i] = {x, math.sin(x), math.cos(x)}
end
-- all columns by default (for table and matrix)
Gp:tplot(arr)

-- the same, but with explicit column specification
Gp:tplot(arr,1,2,3)

-- in polar coordinate system
Gp:polarplot(t1,t2,'some curve')

-- from table
Gp:tpolar(arr,1,2)

-- plot surface
function fun(x,y) return x*x + y*y end
Gp:surfplot(t1,t2,fun,'some surf')

-- from table
arr2 = {}
for _,v1 in ipairs(t1) do
  for _,v2 in ipairs(t2) do
    arr2[#arr2+1] = {v1,v2,fun(v1,v2)}
  end
end
Gp:tsurf(arr2)

-- direct use Gp object
a = Gp()
a:add {math.sin, title='sin'}
a:add {math.cos, title='cos'}
a:show()

-- additional parameters
a.xrange = {0,10}   -- add rangle
-- save to file
a.terminal = 'png'
a.output = 'test.png'
a:show()

-- copy parameters to other object
b = a:copy()
print(b)

-- send 'raw' command to Gnuplot
c = Gp()
c.raw = 'plot x**2-2*x+1; set xlabel "X"; set ylabel "Y"'
c:show()

-- print Lua table
tmp = {
  {1,1},
  {2,2},
  {3,3},
  {4,4}
}
d = Gp()
d:add {tmp,with='lines'}
d:show()

-- define function
fn1 = function (x) return x^2-x end
f = Gp()
f:add {fn1,with='lines',title='x^2-x'}
f:show()

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Graph"></a>
<h3># Graph (graph) #</h3>
<p class="descript">Operations with graphs.</p>
<p><b>G:add(n1, n2=nil, w_d=1)</b> - Add new node or edge.<br>
<b>G:addEdges(list_t)</b> - Import edges and weights from list.<br>
<b>G:addNodes(list_t)</b> - Import nodes from list.<br>
<b>G:components() --> G_t</b> - Get list of connected components.<br>
<b>G:copy() --> cpy_G</b> - Get copy of the graph.<br>
<b>G:dot(fname_s=nil) --> str</b> - Save or return graph structure in dot notation.<br>
<b>G:edge(pair_t) --> weight_d|nil</b> - Get weight of the edge.<br>
<b>G:edges() --> edges_t</b> - Get list of edges.<br>
<b>G:has(node) --> bool</b> - Check if the graph has the node.<br>
<b>G:isComplete() --> bool</b> - Check completeness of the graph.<br>
<b>G:isConnected() --> bool</b> - Check if the graph is connected.<br>
<b>G:isDirected() --> bool</b> - Check if the graph is directed.<br>
<b>G:isEuler() --> bool</b> - Check if the graph has Euler circle.<br>
<b>G:isTree() --> bool</b> - Check if the graph is tree.<br>
<b>G:isWeighted() --> bool</b> - Check if any edge has weight different from 1.<br>
<b>G:matrix() --> adjacency_M, nodes_t</b> - Get adjacency matrix and node list.<br>
<b>G:nin(node) --> nodes_t</b> - Find adjucent input nodes.<br>
<b>G:nodes() --> node_t</b> - List of nodes.<br>
<b>G:nout(node) --> nodes_t</b> - Find adjucent output nodes.<br>
<b>G:rand(edge_N)</b> - Fill graph with random edges.<br>
<b>G:randp(probability_d)</b> - Fill graph with random edges.<br>
<b>G:remove(n1, n2=nil)</b> - Remove node or edge from the graph.<br>
<b>G:search(node1, node2, method_s) --> path_t|nil</b> - Find path between two nodes. Methods are: bfs, dfs, dijkstra.<br>
<b>G:size() --> nodes_N</b> - Get node number. Equal to #G.<br>
<b>G:toSvg(name_s)</b> - Convert graph to SVG image using Graphviz.<br>
<b>Graph (params_t={}) --> new_G</b> - Create graph. Parameters are {dir=bool, O|K|C|P=number|names_t, name='n'}.<br>
<b>Graph:concat(G_t) --> new_G</b> - Combine graphs into one object.<br></p>
<pre class="example">

-- use 'graph'
Graph = require 'matlib.graph'

-- build undirected graph
a = Graph()
a:addNodes {'a', 'b', 'c', 'd', 'e'}
-- list of nodes
nd = a:nodes()
ans = #nd                     -->  5

-- add node
a:add('h')
-- add edge
a:add('a', 'd')
-- check size
-- (same as #a)
ans = a:size()                -->  6

-- group of edges
a:addEdges {
  {'b', 'e'},
  {'x', 'y'},
  {'e', 'c', 2},  -- with waigth
}
-- remove node
a:remove('a')
-- new edge number
ed = a:edges()
ans = #ed                     -->  3

-- check properties
ans = a:isWeighted()          --> true

ans = a:isConnected()         --> false

ans = a:isDirected()          --> false

ans = a:isTree()              --> false

-- generate
b = Graph {K=5}
ans = b:isComplete()          --> true

ans = b:isEuler()             --> true

-- directed graph
c = Graph {C=4, dir=true, name='c'}
ans = c:edge {'c2', 'c1'}     --> 1

-- no edge
ans = (c:edge {'c1', 'c2'} == nil)  --> true

-- check node
ans = c:has 'c3'              --> true

-- input nodes
ans = #c:nin 'c1'             --> 1

-- output nodes
ans = #c:nout 'c1'            --> 1

-- same in undirected graph
ans = (#b:nin('n1') == #b:nout('n1'))  --> true

-- list of components
ans = #a:components()         --> 4

-- make copy
b1 = b:copy()
ans = (b == b1)               --> true

-- change
b1:remove('n1', 'n2')
ans = (b == b1)               --> false

-- adjacency matrix
print(c:matrix())

-- random graph
d = Graph{O=3, name='a'} .. Graph{O=3, name='b'}
-- generate edges with probability 0.5
d:randp(0.5)
print(d:edges())

-- set 8 random edges
d:rand(8)
ans = #d:edges()              --> 8

-- print in 'dot' notation
print(d:dot())

-- save svg image
d:toSvg('test_d')

-- search
g = Graph {K={1,2,3,4,5,6}}
ans = #g:search(1, 4, 'bfs')  --> 2

ans = (#g:search(1, 4, 'dfs') > 2)  --> true

-- dijkstra algorithm
-- update weight 1-4
g:add(1, 4, 10)
ans = #g:search(1, 4, 'dijkstra')   --> 3

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Lens"></a>
<h3># Lens (lens) #</h3>
<p class="descript">Matrix methods in paraxial optics.</p>
<p><b>L:beam(inCurv_d, inSize_d, lambda_d) --> outCurv_d, outSize_d</b> - Find output beam curvature and spot radius.<br>
<b>L:cardinal(nLft_d=1, nRht_d=1) --> points_t</b> - Find location of the cardinal points of the given system w.r.t input and output planes, use refractive indeces if need. Return table of distances.<br>
<b>L:copy() --> cpy_L</b> - Create a copy of the object.<br>
<b>L:emit(lambda_d) --> outCurv_d, outSize_d|nil, waist_d|nil, shift_d|nil </b> - Find laser cavity output beam curvature. In the case of stable cavity also returns size radius, waist radius and its shift from the plane.<br>
<b>L:inv() --> inv_L</b> - Get the inverted system matrix.<br>
<b>L:matrix() --> M</b> - Get elements as matrix.<br>
<b>L:transform(yIn_d, VIn_d) --> yOut_d, VOut_d</b> - Find the output ray position 'y' and optical angle 'V' (= v*n). Equal to L(y,V).<br>
<b>Lens (A_d, B_d, C_d, D_d) --> new_L</b> - Make new lens component.<br>
<b>Lens:M(rad_d, n_d=1) --> L</b> - Find reflection matrix for the given radius and refractive index.<br>
<b>Lens:R(nin_d, rad_d, nout_d) --> L</b> - Find refraction matrix for the given radius of surface and input and output refractive indeces.<br>
<b>Lens:T(dist_d, n_d=1) --> L</b> - Find translation matrix for the given distance and refractive index.<br>
<b>Lens:afocal(magn_d) --> L</b> - Find matrix for the afocal system.<br>
<b>Lens:gParam(waist_d, lambda_d) --> div_d, range_d</b> - Find divergence angle and Raileigh range for a Gaussian beam.<br>
<b>Lens:gSize(waist_d, lambda_d, dist_d) --> curv_d, rad_d</b> - Find Gaussian beam radius and curvature at some distance.<br>
<b>Lens:solve(fn, index_N, initial_d) --> found_d</b> - Find condition when component with the given index is equal to 0, use initial assumption.<br>
<b>Lens:thin(focal_d) --> L</b> - Find the thin lens system matrix for the given focal distance.<br></p>
<pre class="example">

-- use 'lens'
Lens = require 'matlib.lens'
-- external dependencies, can be loaded implicitly
require 'matlib.numeric'  -- for root searching
require 'matlib.complex'  -- for beam transformation

-- define a simple lense
n1 = 1      -- air
n2 = 1.56   -- glass
-- radius 200 mm, thickness 5 mm
lens1 = Lens:R(n1,200,n2)
        :T(5,n2)
        :R(n2,-200,n1)
ans = lens1:matrix():det()   --2>  1.0

-- in the chain definition
-- 'n' can be taken from a previous element
lens11 = Lens:R(n1,200,n2)
         :T(5)
         :R(-200, n1)
ans = (lens1 == lens11)       -->  true

-- if n==1 then it can be skipped
lens12 = Lens:R(200,n2)  -- skip first n
         :T(5)
         :R(-200)  -- first n from previous, skip last n
ans = (lens1 == lens12)       -->  true

-- get matrix element
ans = lens1.D                --2>  1

-- find cardinal points
pts = lens1:cardinal()
ans = pts.F1                 --2>  -177.76

-- print points
print(pts)

-- object is located 250 mm to the left
-- from the lens, find position of
-- the image
d1 = 250
fn = function (d2)
  return Lens:T(d1)..lens1..Lens:T(d2)
end
-- solve for B = 0, initial guess dist = 100
d2 = Lens:solve(fn, 'B', 100)
ans = d2                     --2>   623.21

-- check solution
-- assume the lens it thin
f = -pts.F1
ans = 1/d1 + 1/d2            --2>  1/f

-- ray transformation
y1 = 10          -- mm, height
V1 = n1 * 0.05   -- optical angle
sys1 = fn(d2)
y2, V2 = sys1(y1,V1)
ans = y2                     --2>  -24.83

-- from image to object
sys2 = sys1:inv()  -- transpose
ans, _ = sys2(y2, V2)        --3>  y1

-- create thin lens
lens2 = Lens:thin(f)
_, V3 = lens1(y1,V1)
_, ans = lens2(y1,V1)        --2>  V3

-- flat mirror
lens3 = Lens:M(math.huge, n1)
_, ans = lens3(y1,V1)        --2>  V1

-- afocal system
m = 10
lens4 = Lens:afocal(m)
ans, _ = lens4(y1,V1)        --2>  m*y1

-- arbitrary system matrix (ABCD)
lens5 = Lens(1, 0, -0.5, 1)
print(lens5)

-- make copy
ans = lens1:copy()            -->  lens1

-- gaussian beam parameters
lambda = 1024   -- nm, YAG-Nd laser
lambda = lambda * 1E-6  -- mm
ans, _ = Lens:gParam(1, lambda) --2>  3.26E-4

-- laser beam radius
_, ans = Lens:gSize(1, lambda, 1E5) --2>  32.61

-- laser beam transformation
_, ans = lens1:beam(1E6, 1, lambda)  --2>  0.991

-- laser cavity
air_rod = Lens: T(250) : T(30, 1.56)
cavity = Lens:M(-300) .. air_rod .. Lens:M(-300) .. air_rod
ans, _ = cavity:emit(lambda)         --1> 300.0

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Main"></a>
<h3># Main (main) #</h3>
<p class="descript">Lua based mathematics.</p>
<p><b>Bind(obj, nm1, [nm2, ...]) --> fn</b> - Wrap functions to call them without object.<br>
<b>Map(fn, in_t) --> out_t</b> - Evaluate function for each table element.<br>
<b>PI --> 3.14</b> - Number pi.<br>
<b>Round(v, decimal_N=0) --> round_v</b> - Round value, define number of decimal digits or tolerance.<br>
<b>abs(x) --> y</b> - Absolute value.<br>
<b>acos(x) --> y</b> - Inverse cosine x.<br>
<b>acosh(x) --> y</b> - Hyperbolic arc cosine.<br>
<b>asin(x) --> y</b> - Inverse sine.<br>
<b>asinh(x) --> y</b> - Hyperbolic inverse sine.<br>
<b>atan(x) --> y</b> - Inverse tangent x.<br>
<b>atan2(y_d, x_d) --> num</b> - Inverse tangent of y/x, use signs.<br>
<b>atanh(x) --> y</b> - Hyperbolic inverse tangent.<br>
<b>cos(x) --> y</b> - Cosine.<br>
<b>cosh(x) --> y</b> - Hyperbolic cosine.<br>
<b>exp(x) --> y</b> - Exponent.<br>
<b>help(fn='main') --> str</b> - Show information about the function.<br>
<b>hypot(...)</b> - Hypotenuse.<br>
<b>log(x) --> y</b> - Natural logarithm.<br>
<b>quit()</b> - Quit the program.<br>
<b>sin(x) --> y</b> - Sine.<br>
<b>sinh(x) --> y</b> - Hyperbolic sinus.<br>
<b>sqrt(x) --> y</b> - Square root.<br>
<b>tan(x) --> y</b> - Tangent.<br>
<b>tanh(x) --> y</b> - Hyperbolic tangent.<br>
<b>use([module_s]) --> str|nil</b> - Call use('module') or use{'module1','module2'} to load new functions.<br></p>
<pre class="example">

require 'matlib.main'
-- for bind example
D = require('matlib.data')

-- standard functions
ans = exp(0)+sin(PI/2)+cosh(0)  --1>  3.0

ans = hypot(3, 4)            --2>  5.0

-- round number
ans = Round(0.9)              -->  1.0

-- save 2 digits
ans = Round(math.pi, 2)       -->  3.14

-- use tolerance
ans = Round(math.pi, 0.01)    -->  3.14

-- calculate function values
c = Map(sin, {2,4,6,8,10})
ans = c[1]                   --3>  0.909

-- bind functions
min, sum = Bind(D, 'min', 'sum')
ans = min{1, 2, 3} + sum{1,2,3}  -->  7

-- use Lua functions if need
ans = math.deg(PI)           --2>  180.0

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Mat"></a>
<h3># Mat (matrix) #</h3>
<p class="descript">Matrix operations. The matrices are spares by default. Indexation from 1.</p>
<p><b>M:H() --> conj_Ref</b> - Return conjugabe transpose. <br>
<b>M:T() --> transpose_Ref</b> - Return matrix transpose.<br>
<b>M:chol() --> lower_M|nil</b> - Cholesky decomposition of positive definite symmetric matrix.<br>
<b>M:cols() --> N</b> - Get number of columns.<br>
<b>M:copy() --> cpy_M</b> - Return copy of matrix.<br>
<b>M:det() --> num</b> - Calculate determinant.<br>
<b>M:diag() --> V</b> - Get diagonal of the matrix.<br>
<b>M:eig() --> vectors_M, values_M</b> - Find matrices of eigenvectors and eigenvalues.<br>
<b>M:exp() --> new_M</b> - Matrix exponential.<br>
<b>M:inv() --> inv_M</b> - Return inverse matrix.<br>
<b>M:kron(M2) --> M⊗M2</b> - Find Kronecker product.<br>
<b>M:kronSum(M2) --> M⊕M2</b> - Find Kronecker sum.<br>
<b>M:lu() --> L_M, U_M, perm_M</b> - LU decomposition for the matrix. Return L, U and P matrices.<br>
<b>M:map(fn) --> found_M</b> - Apply the given function to all elements, return new matrix. Function can be in form f(x) or f(x, row, col).<br>
<b>M:minor(row_N, col_N) --> minor_M</b> - Find minor for the matrix element.<br>
<b>M:norm() --> num</b> - Euclidean norm.<br>
<b>M:pinv() --> inv_M</b> - Pseudo inverse matrix calculation.<br>
<b>M:qr() --> Q_M, R_M</b> - QR decomposition of the matrix.<br>
<b>M:rank() --> N</b> - Find rank of the matrix.<br>
<b>M:reshape(row_N=(rows*cols), col_N=1) --> mat_Ref</b> - Matrix with rearranged elements.<br>
<b>M:rows() --> N</b> - Get number of rows.<br>
<b>M:rref() --> upd_M</b> - Perform transformations using Gauss method.<br>
<b>M:stars(cond_fn) --> str</b> - Print star when condition for the current elemen is true.<br>
<b>M:svd() --> U_M, S_M, V_M</b> - Singular value decomposition, return U, S, V.<br>
<b>M:table() --> tbl</b> - Convert to simple Lua table.<br>
<b>M:tr() --> sum</b> - Get trace of the matrix.<br>
<b>M:vec() --> vec_Ref|nil</b> - Create reference to vector data.<br>
<b>M:vectorize() --> V</b> - Create vector as a stack of columns.<br>
<b>Mat {row1_t, ...} --> new_M</b> - Create matrix from list of strings (tables).<br>
<b>Mat:D(list_v, shift_N=0) --> M</b> - Create new matrix with the given diagonal elements.<br>
<b>Mat:V {...} --> mat_Ref</b> - Create vector from list of numbers.<br>
<b>Mat:eye(row_N, col_N=row_N) --> M</b> - Create identity matrix.<br>
<b>Mat:fill(row_N, col_N, val=1) --> M</b> - Create matrix of given numbers (default is 1).<br>
<b>Mat:hor(mat_t) --> mat_Ref</b> - Horizontal concatenation for the given list of matrices.<br>
<b>Mat:ver(mat_t} --> mat_Ref</b> - Vertical concatenation for the given list of matrices.<br>
<b>Mat:zeros(row_N, col_N=row_N) --> M</b> - Create matrix of zeros.<br>
<b>Mat:zip(fn, ...) --> res_M</b> - Apply function to the given matrices element-wise.<br>
<b>V:cross(V2) --> M</b> - Cross product or two 3-element vectors.<br>
<b>V:dot(V2) --> num</b> - Scalar product of two vectors.<br>
<b>V:normalize()</b> - Normalize to unit vector.<br></p>
<pre class="example">

-- use 'matrix'
Mat = require 'matlib.matrix'

-- define matrix objects
a = Mat {{1,2},{3,4}}
b = Mat {{5,6},{7,8}}
-- call in typical way
ans = a[2][2]                 -->  4

-- set new value
b[1][1] = 5

-- transpose
c = a:T()
-- 'smart' getter
ans = c(1,-1)                 -->  3

-- matrix columns and rows
ans = a:cols()                -->  2

ans = a:rows()                -->  2

-- arithmetical operations
ans = a + b                   -->  Mat {{6,8},{10,12}}

ans = b - a                   -->  Mat {{4,4},{4,4}}

ans = a * b                   -->  Mat {{19,22},{43,50}}

-- multiply to scalar
ans = 2 * a                   -->  Mat {{2,4},{6,8}}

-- add scalar (to all elements)
ans = a - 1                   -->  Mat {{0,1},{2,3}}

ans = a ^ 2                   -->  Mat {{7,10},{15,22}}

-- determinant
ans = a:det()                 -->  -2

-- inverse matrix
e = a:inv()
ans = e[2][1]                 -->  1.5

-- another call of inversion
e = a^-1
ans = e(2,1)                  -->  1.5

-- object copy
-- (it doesn't copy zeros)
f = a:copy()
ans = (f == a)                -->  true

-- element-wise comparison
ans = (a == b)                -->  false

-- identity matrix
ans = Mat:eye(2)              -->  Mat {{1,0},
                                        {0,1}}

-- matrix argument
ans = Mat:eye(a)              -->  Mat {{1,0},
                                        {0,1}}

-- matrix of zeros
ans = Mat:zeros(2,1)          -->  Mat {{0},{0}}

-- matrix of constants = 4
ans = Mat:fill(2,3,4)         -->  Mat {{4,4,4},
                                        {4,4,4}}

-- horizontal concatenation
ans = Mat:hor {a, b}          -->  Mat {{1,2,5,6},
                                        {3,4,7,8}}

-- vertical concatenation
ans = Mat:ver {a, b}          -->  Mat {{1,2},{3,4},{5,6},{7,8}}

-- apply function of 1 argument
ans = a:map(function (x) return x^2 end)       -->  Mat {{1,4},{9,16}}

-- apply function which depends on index too
ans = a:map(function (x,r,c) return x-r-c end) -->  Mat {{-1,-1},{-0,-0}}

-- apply function to matrices
-- element-wise
fn = function (x,y,z) return x*y+z end
aa = Mat:zip(fn, b,b,b)
ans = aa[1][1]                -->  30

-- use Gauss transform to solve equation
ans = (a .. Mat:V{5,11}):rref()  -->  Mat {{1,0,1},
                                           {0,1,2}}

-- create vector
ans = Mat:V {1,2,3}           -->  Mat {{1},{2},{3}}

-- get submatrix
g = Mat {
  {1,2,3},
  {4,5,6},
  {7,8,9}
}
-- same as g({2,-1},{2,3})
ans = g({2,-1},{2,3})         -->  Mat {{5,6},
                                        {8,9}}

-- insert elements
gg = Mat:eye(3)
gg({1,2},{1,2}).data = a
ans = gg({1,2},{1,2})   -->  a

-- euclidean norm
ans = Mat:V({1,2,3}):norm()  --3>  math.sqrt(14)

-- random matrix
rnd = function () return math.random() end
h = Mat:zeros(2,3):map(rnd)
print(h)

-- pseudo inverse matrix
m = Mat {
  {1,2},
  {3,4},
  {5,6}
}
n = m:pinv()
ans = n(2,2)                 --3>  0.333

-- copy as Lua table
-- (without methametods)
k = Mat:eye(3)
k = k:table()
ans = k[2][1]                 -->  0

-- make diagonal matrix
ans = Mat:D({1,2,3})          -->  Mat {{1,0,0},
                                        {0,2,0},
                                        {0,0,3}}

-- get diagonal
ans = g:diag()                -->  Mat {{1},{5},{9}}

-- cross-product of 2 vectors
x1 = Mat {{1,2,3}}
x2 = Mat {{4,5,6}}
-- to vectors
v1, v2 = x1:vec(), x2:vec()
ans = v1:cross(v2)  -->  Mat {{-3},{6},{-3}}

-- dot product of 2 vectors
ans = v1:dot(v2)              -->  32

-- LU decomposition
l,u,p = b:lu()
ans = l[2][1]                --3>  0.714

-- QR decomposition
q,r = m:qr()
ans = (q*r)[2][2]            --3>  m[2][2]

ans = q:det()                --3>  1.0

-- SVD decomposition
u,s,v = m:svd()
ans = (u*s*v:T())[1][1]      --3>  m[1][1]

-- Cholesky decomposition
m = Mat {{3,1},{1,3}}
m = m:chol()
ans = m[2][2]                --3>  1.633

-- matrix exponential
m = a:exp()
ans = m[2][2]                --1> 164.1

-- matrix trace
ans = a:tr()                  -->  5

-- extract first row
m = a({},1)
-- vector doesn't need in 2 indices
ans = m(1)                    -->  1

-- extract last column
-- index can be negative
m = a(-1,{})
ans = m(2)                    -->  4

-- get rank
ans = Mat:fill(2,3):rank()    -->  1

-- change size
tmp = Mat{
  {1,2},
  {3,4},
  {5,6}
}
ans = tmp:reshape(2,3)        -->  Mat {{1,2,3},
                                        {4,5,6}}

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Num"></a>
<h3># Num (numeric) #</h3>
<p class="descript">Group of functions for numerical calculations.</p>
<p><b>Num:der(fn, x_d) --> num</b> - Calculate the derivative value for the given function.<br>
<b>Num:int(fn, x1_d, x2_d) --> num</b> - Get integral of the function. Improper integrals with infinite limits are possible.<br>
<b>Num:lim(fn, xn_d, isPositive=false) --> y</b> - Estimate limit of a function.<br>
<b>Num:newton(fn, x0_d) --> num</b> - Find root of equation using Newton's rule.<br>
<b>Num:ode(fn, interval_t, y0, {dt=del/20,exit=nil}) --> ys_t</b> - Numerical approximation of the ODE solution.<br>
List of parameters is optional and can includes time step and exit condition.<br>
Return table of intermediate points in form {t, x(t)}.<br>
<b>Num:solve(fn, low_d, up_d) --> num</b> - Find root of equation fn(x)=0 on interval [a,b].<br>
<b>ys:flat() --> ys</b> - Transform vector to list for each rov in ODE output.<br></p>
<pre class="example">

-- use 'numeric'
Num = require 'matlib.numeric'
-- use matrices for high order equations
Mat = require 'matlib.matrix'

-- define tolerance
Num.TOL = 1e-4
-- solve 'sin(x) = 0' for x in (pi/2...3*pi/2)
a = Num:solve(math.sin, math.pi*0.5, math.pi*1.5)
ans = a                      --3>  math.pi

-- Newton method
-- only one initial value
d = Num:newton(math.sin, math.pi*0.7)
ans = d                      --3>  math.pi

-- numeric derivative
b = Num:der(math.sin, 0)
ans = b                      --0>  1

-- numeric limit
fn = function (x) return math.sin(x) / x end
ans = Num:lim(fn, 0)         --3>  1.0

-- inf limit
ans = Num:lim(math.exp, -INF)  --3> 0.0

-- numeric integral
c = Num:int(math.sin, 0, math.pi)
ans = c                      --2>  2.0

-- infinite limits
ans = Num:int(
  function (x) return math.exp(-x*x) end, -INF, INF)  --2> math.sqrt(math.pi)

-- solve ODE x*y = y'
-- for x = 0..3, y(0) = 1
-- return table of solutions and y(3)
tbl = Num:ode(function (x,y) return x*y end,
                {0,3}, 1)
ans = tbl[#tbl][2]           --2>  90.011

-- y''-2*y'+2*y = 1
-- represent as: x1 = y, x2 = y'
-- so: x1' = x2, x2' = 1+2*x2-2*x1
myfun = function (t,x)
  return Mat:V {x(2), 1+2*x(2)-2*x(1)}
end
res = Num:ode(myfun, {0,2}, Mat:V{3,2}, {dt=0.2})
xn = res[#res][2]  -- last element
ans = xn(1)                  --2>   -10.54

-- define exit condition
cond = function (states)
  -- check current value
  return states[#states][2] < 0.1
end
myfun = function (t,x) return -x end
y = Num:ode(myfun, {0, 1E2}, 1, {exit=cond})
-- time of execution before break
ans = y[#y][1]               --1>  2.3

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Poly"></a>
<h3># Poly (polynomial) #</h3>
<p class="descript">Operations with polynomials.</p>
<p><b>P:copy() --> cpy_P</b> - Get copy of the polynomial.<br>
<b>P:der() --> der_P</b> - Calculate derivative of polynomial.<br>
<b>P:int(x0_d=0) --> int_P</b> - Calculate integral, define free coefficient if need.<br>
<b>P:roots() --> roots_t</b> - Find all the polynomial roots.<br>
<b>P:str(char_s='x') --> str</b> - Pretty print for polynomial.<br>
<b>P:val(x) --> y</b> - Get value of polynomial P in point x. Equat to P(x).<br>
<b>Poly {.., v1, v0} --> new_P</b> - Create a polynomial.<br>
<b>Poly:R(roots_t) --> P</b> - Return polynomial with given roots.<br>
<b>Poly:char(M) --> P</b> - Return characteristic polinomial for the given matrix.<br>
<b>Poly:fit(xs_t, ys_t, order_N) --> P</b> - Find polynomial approximation for the line.<br>
<b>Poly:lagrange(xs_t, ys_t) --> P</b> - Find interpolation polynomial in the Lagrange form.<br>
<b>Poly:lin(xs_t, ys_t, before_d=nil, after_d=before_d) --> Ps_t</b> - Linear data interpolation. Return table with polynomials.<br>
<b>Poly:spline(xs_t, ys_t) --> Ps_t</b> - Cubic spline data interpolation. Return table with polynomials.<br>
<b>Poly:taylor(x_d, fx_d, [fx'_d, fx''_d,..]) --> P</b> - Get Taylor series.<br>
<b>Poly:x() --> P</b> - Get object to define polynomial as a sum of k*x^n<br></p>
<pre class="example">

-- use 'polynomial'
Poly = require 'matlib.polynomial'
-- external dependencies, can be loaded implicitly
require 'matlib.matrix'         -- in Poly.fit
Comp = require 'matlib.complex' -- for complex roots

-- coefficients in ascendant order
a = Poly {1,2,4,3}
b = Poly {1,1}
-- polynomial value for x=0
ans = a:val(0)                -->  3

-- simplified call
ans = a(0)                    -->  3

-- coefficient for x^3
ans = a[3]                    -->  1

-- arithmetic
ans = a + b                   -->  Poly {1,2,5,4}

ans = a - b                   -->  Poly {1,2,3,2}

ans = b * b                   -->  Poly {1,2,1}

ans = a / b                   -->  Poly {1,1,3}

ans = a % b                   -->  0

ans = b ^ 3                   -->  Poly {1,3,3,1}

-- not all powers
x = Poly:x()
ans = x^3-2*x+1               --> Poly {1,0,-2,1}

-- integration
-- free coefficient is 0
ans = b:int()                 -->  Poly {0.5,1,0}

-- derivative
ader = a:der()
-- and its value for x=1
ans = ader(1)                 -->  11

-- build polynomial using roots
ans = Poly:R{1,-1}            -->  Poly {1,0,-1}

-- use complex roots
i = Comp:i()
ans = Poly:R{1, 2+3*i, 2-3*i}  -->  Poly {1, -5, 17, -13}

-- make copy and compare
c = a:copy()
ans = (a == c)                -->  true

-- not equal
ans = (b == c)                -->  false

-- find all roots
g = Poly:R{1, 2, 3+4*i, 3-4*i}
e = g:roots()
ans = e[3]:re()              --1>  3

-- fit curve with polynomial
-- of order 2
A={0,1,2,3}
B={-3,2,11,24}
p = Poly:fit(A,B,2)
ans = p(10)                  --0>  227.0

-- simple print
print(a)

-- human-friendly print
-- with variable 's' (default is 'x')
d = Poly {2,-2,1}
ans = d:str('s')              -->  '2*s^2-2*s+1'

-- Lagrange polynomial
-- for tx(x)
X = {-1.5, -0.75, 0, 0.75, 1.5}
Y = {-14.101,-0.931596,0,0.931596,14.101}
p = Poly:lagrange(X,Y)
ans = p[3]                   --3>  4.83485

-- Taylor series
-- for exp(x) near 0
p = Poly:taylor(0, 1, 1, 1, 1)
ans = p(0.3)                 --2>  math.exp(0.3)

-- linear interpolation
-- use constant values out the interval
p = Poly:lin(X,Y, Y[1], Y[#Y])
y1, n = p:val(0.5)
ans = y1                     --2>  0.621

-- polynomial index
ans = n                       -->  4

-- simplify call when index is known
ans = p(0.5, n)              --2>  y1

-- cubic spline
p = Poly:spline(X, Y)
ans = p(0.5)                 --2>  -0.512

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Quat"></a>
<h3># Quat (quaternion) #</h3>
<p class="descript">Operations with quaternions.</p>
<p><b>Q:abs() --> num</b> - Value of the norm.<br>
<b>Q:conj() --> conj_Q</b> - Get conjugation. Equal to ~Q.<br>
<b>Q:exp() --> exp_Q</b> - Quaternion exponential.<br>
<b>Q:inv() --> inv_Q</b> - Find inverted quaternion.<br>
<b>Q:log() --> log_Q</b> - Quaternion logarithm.<br>
<b>Q:normalized() --> unit_Q</b> - Return unit quaternion.<br>
<b>Q:rotate(in_t|V) --> out_t</b> - Apply quaternion to rotate the vector.<br>
<b>Q:slerp(end_Q, rat_f) --> rat_Q</b> - Spherical linear interpolation for the given ratio.<br>
<b>Q:toAA() --> angle_d, axis_t|nil</b> - Get angle and axis of rotation.<br>
<b>Q:toRPY() --> roll_d, pitch_d, yaw_d</b> - Get Euler angles.<br>
<b>Q:toRot() --> M</b> - Get equal rotation matrix.<br>
<b>Q:w() --> var</b> - Get w component.<br>
<b>Q:x() --> var</b> - Get x component.<br>
<b>Q:y() --> var</b> - Get y component.<br>
<b>Q:z() --> var</b> - Get z component.<br>
<b>Quat {x, y, z, w} --> new_Q</b> - Create new quaternion.<br>
<b>Quat:fromAA(angle_d, axis_t|V) --> Q</b> - Create quaternion using angle and axis.<br>
<b>Quat:fromRPY(roll_d, pitch_d, yaw_d) --> Q</b> - Convert Euler angles to quaternion.<br>
<b>Quat:fromRot(M) --> Q</b> - Convert rotation matrix to quaternion.<br></p>
<pre class="example">

-- use 'quaternion'
Quat = require 'matlib.quaternion'
-- external dependencies, can be loaded implicitly
require 'matlib.matrix'

-- quaternion
-- set {w,x,y,z}
a = Quat {1,2,3,4}
-- part of elements
b = Quat {w=3, x=4}
ans = b                       -->  Quat{3, 4, 0, 0}

-- conjugation
ans = a:conj()                -->  Quat{1, -2,-3,-4}

-- real when imaginary are zeros
ans = a + a:conj()            -->  2

-- norm
ans = b:abs()                --1>  5.000

-- inversion
c = a*a:inv()
ans = c:w()                  --1>  1.000

-- arithmetic
ans = a+b                     -->  Quat{4, 6,3,4}

ans = a*b                     -->  Quat{-5, 10,25,}

ans = 3*b                     -->  Quat{9, 12}

-- power
ans = b^3                     -->  b * b * b

-- unit quaternion
a = a:normalized()
ans = a:abs()                --1>  1.000

-- unit power
aa = a^1.5
ans = aa:x()                 --3>  0.324

ans = aa:y()                 --3>  0.486

ans = aa:z()                 --3>  0.648

-- rotation matrix
m = a:toRot()
d = Quat:fromRot(m)
ans = (d-a):abs()            --1>  0.000

-- use angle
-- and axis
ang = 0.5
axis = {1,1,1}
f = Quat:fromAA(ang,axis)
ans,_ = f:toAA()             --3>  ang

-- rotate vector
p = a:rotate({1,0,0})
ans = p[1]                   --3>  -0.667

-- spherical interpolation
d = a:slerp(b,0.5)
ans = d:w()                  --3>  0.467

-- show
print(d)

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Qb"></a>
<h3># Qb (qubit) #</h3>
<p class="descript">Quantum computing simulation</p>
<p><b>G:CNOT(slave_i, master_i) --> upd_G</b> - Add CNOT gate.<br>
<b>G:H([ind1, ind2 ...]) --> upd_G</b> - Add Hadamard gate.<br>
<b>G:P(phase, [ind1, ind2 ...] --> G</b> - Add phase shift gate.<br>
<b>G:R(axis_s, angle, [ind1, ind2 ...] --> G</b> - Add rotation for axis 'X', 'Y' or 'Z'.<br>
<b>G:S([ind1, ind2 ...]) --> upd_G</b> - Add S gate.<br>
<b>G:SWAP(ind1, ind2) --> upd_G</b> - Add gate to swap 2 qubits.<br>
<b>G:T([ind1, ind2 ...]) --> upd_G</b> - Add T gate.<br>
<b>G:X([ind1, ind2 ...]) --> upd_G</b> - Add X gate.<br>
<b>G:Y([ind1, ind2 ...]) --> upd_G</b> - Add Y gate.<br>
<b>G:Z([ind1, ind2 ...]) --> upd_G</b> - Add Z gate.<br>
<b>G:fromMatrix(M) --> upd_G</b> - Make gate from matrix.<br>
<b>G:fromTable(truth_t) --> upd_G</b> - Make gate from truth table.<br>
<b>G:inverse() --> inv_G</b> - Get inverted gate sequence<br>
<b>G:isUnitary() --> bool</b> - Check if the matrix is unitary<br>
<b>Q:copy() --> cpy_Q</b> - Create a copy of the object.<br>
<b>Q:matrix() --> M</b> - Get matrix representation.<br>
<b>Q:meas(index=nil) --> Q</b> - Qubit state measurement.<br>
<b>Q:normalize()</b> - Make norm equal to 1.<br>
<b>Q:prob(state_s) --> probatility_d</b> - Get probability for the given state.<br>
<b>Qb (state_s|num) --> Q</b> - Create new qubit.<br>
<b>Qb:combine([Q1, Q2, ...]) --> Q|nil</b> - Make a system of qubits. Same as Q1..Q2 for two components.<br>
<b>Qb:fromVector(V) --> Q</b> - Initialize qubit state from vector.<br>
<b>Qb:gates(input_n) --> G</b> - Initialize gates for the given numer of inputs.<br></p>
<pre class="example">

-- use 'qubit'
Qb = require 'matlib.qubit'
-- for oracle definition
Mat = require 'matlib.matrix'

-- define state
a = 0.2*Qb'|0>' + 0.98*Qb'|1>'
-- get number of qubits in system
ans = #a                      -->  1

-- qubit as vector
av = a:matrix()
ans = av(1)                  --2>  0.2

-- norm
ans = a * a                  --2>  1.0

-- projection to |+>
k = 1 / math.sqrt(2)
plus = k*Qb'|0>' + k*Qb'|1>'
ans = plus * a               --2>  (0.2+0.98)*k

-- system of qubits
-- allow to skip |>
b = Qb'00' + Qb'11'
b:normalize()
-- probability of the state |00>
ans = b:prob '00'            --2>  0.5

-- combine qubits Q1-Q2,
-- (same as a..b)
c = Qb:combine(a, b)
print(c)

-- do 'measurement' of all states
-- result is calculated using probabilities
print(c:meas())

-- define Hadamard gate for 2 qubits
g1 = Qb:gates(2):H()
ans = #g1                     -->  2

-- show
print(g1)

-- check if it is unary
ans = g1:isUnitary()          -->  true

-- as matrix
g1m = g1:matrix()
ans = g1m[1][1]              --2>  0.5

-- apply to qubits
d = g1(Qb'|00>')
-- check projection
ans = (plus..plus) * d       --2>  1.0

-- add X to 0-th, Y to 1-st and Z to both
-- indexation from zero
g1:X(0):Y(1):Z()
print(g1)

-- 3 qubit system
-- CNOT on 0 (2 for control), then swap 1 and 2
g2 = Qb:gates(3):CNOT(0,2):SWAP(1,2)
print(g2)

-- inverse system
g3 = g2:inverse()
mm = g2:matrix() * g3:matrix()
ans = mm[4][4]               --2>  1.0

-- Deutsch-Jozsa algorithm
-- check for function f(x) = x, 1 is expected as output
g4 = Qb:gates(2):H()
-- oracle from table
g4:fromTable({
--  in   out
  {'00','00'},
  {'01','01'},
  {'10','11'},
  {'11','10'}
}):H()
-- apply for 01, measure at index 1
ans = g4(Qb'01'):meas(1)      -->  Qb'1'

-- Grover's algorithm
-- check funciton f(101) = 1, f(x) = 0 for others
g5 = Qb:gates(3):H()
-- oracle from matrix
mat_fn = Mat:eye(8); mat_fn[6][6] = -1
-- for the Groover diffusion gate (2|0><0| - 1)
mat_df = -Mat:eye(8); mat_df[1][1] = 1
-- combine
oracle_diffuse = Qb:gates(3)
  :fromMatrix(mat_fn)
  :H()
  :fromMatrix(mat_df)
  :H()
-- apply 2 times (~ sqrt(8)*pi/4)
g5 = g5 * oracle_diffuse^2
-- check result (it is random)
ans = g5(Qb'000'):meas()      --> Qb'101'

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Rand"></a>
<h3># Rand (random) #</h3>
<p class="descript">Random number generators.</p>
<p><b>R:binomial(p_d, N) --> int</b> - Binomial distributed random values.<br>
<b>R:bytes(N) --> str</b> - Get sequence of random bytes.<br>
<b>R:cauchy(mu_d=0, sigma_d=1) --> float</b> - Cauchy distributed random numbers.<br>
<b>R:choice(tbl) --> element, index_N</b> - Get random table element.<br>
<b>R:exp(lambda_d=1) --> float</b> - Exponential distributed random values.<br>
<b>R:flip(p=0.5) --> bool</b> - Uniform distributed binary value.<br>
<b>R:gamma(alpha_N, beta_d=1) --> float</b> - Gamma distributed random values.<br>
<b>R:int(lower_i=1, upper_i) -> int</b> - Uniform distributed random integer in the given range.<br>
<b>R:ipairs(tbl) --> iterator_fn</b> - Random iterator over the table elements.<br>
<b>R:logistic(mu_d=0, sigma_d=1) --> float</b> - Logistic distributed random value.<br>
<b>R:norm(mean_d=0, dev_d=1) --> float</b> - Normal distributed random value with the given mean and deviation.<br>
<b>R:poisson(lambda_d) --> int</b> - Poisson distributed random values.<br>
<b>R:rayleigh(sigma_d) --> float</b> - Rayleigh distributed random values.<br>
<b>R:seed(N=os.time) --> R</b> - Set random generator seed.<br>
<b>R:shuffle(tbl)</b> - Change order of elements in place.<br>
<b>Rand () --> float</b> - Uniform distributed random number between 0 and 1.<br>
<b>Rand:new() --> R</b> - Create random generator object.<br></p>
<pre class="example">

-- use 'random'
Rand = require 'matlib.random'
Ap = require 'matlib.asciiplot'     -- for visualization
_D = require 'matlib.data'          -- hystogram
Spec = require 'matlib.special'     -- gamma function
-- prepare for data generation
N = 100  -- number of points
-- normalize hystograms
function normalize (lst, step)
  local d = step * N
  for i, v in ipairs(lst) do lst[i] = v / d end
end

-- default generator (0 to 1)
lst = {}
for i = 1, N do
  lst[i] = Rand()
end

-- visualize
ts, te = _D:histcounts(lst, 10)
normalize(ts, 1)
fig = Ap()
fig:setY {view='min'}; fig:setX {range={0, 0.5}, fix=true}
v = _D:T({te, ts})  -- get list of pairs
fig:bar(v)
print(fig)

-- custom generator (0 to 1)
rnd = Rand:new()
for i = 1, N do
  lst[i] = rnd()
end

-- visualize renerated data
ts, te = _D:histcounts(lst, 10)
normalize(ts, 1)
v = _D:T({te, ts})   -- list of pairs
fig:bar(v)
print(fig)

-- normal distribution
mu, sig = 1, 0.5
for i = 1, N do
  lst[i] = rnd:norm(mu, sig)
end

-- show normal distribution
fig = Ap(53, 19)
fig:setX {view='min'}
-- simplify visualization
function visualize (data, a, b, step, fn)
  local lim = {}
  for x = a, b, step do lim[#lim+1] = x end
  local ts, te = _D:histcounts(data, lim)
  normalize(ts, step)
  fig:plot(te, ts, 'random', fn, 'pdf')
  print(fig)
end
-- probability density function
pdf = function (x)
  return math.exp(-0.5*(x-mu)^2/sig^2) / (sig*math.sqrt(2*math.pi))
end
visualize(lst, mu-2*sig, mu+2*sig, 4*sig/10, pdf)

-- exponential distribution
lam = 0.5
for i = 1, N do
  lst[i] = Rand:exp(lam)
end

-- show exponential distribution
pdf = function (x) return  lam*math.exp(-lam*x) end
step = 0.5
visualize(lst, 0, 10*step, step, pdf)

-- logistic distribution
mu = 2; sig = 2
for i = 1, N do
  lst[i] = Rand:logistic(mu, sig)
end

-- show logistic distribution
pdf = function (x)
  local v = math.exp(-(x-mu)/sig)
  return v / sig / (1 + v)^2
end
visualize(lst, mu-4*sig, mu+4*sig, 8*sig/10, pdf)

-- Raileigh distribution
sig = 0.5
for i = 1, N do
  lst[i] = rnd:rayleigh(sig)
end

-- show Raileigh distribution
pdf = function (x)
  return x/sig^2*math.exp(-0.5*x^2/sig^2)
end
visualize(lst, 0, 4*sig, 4*sig/10, pdf)

-- Cauchy distribution
mu = 0; sig = 1
for i = 1, N do
  lst[i] = Rand:cauchy(mu, sig)
end

-- show Cauchy distribution
pdf = function (x)
  return 1/(math.pi*sig)/(1+(x-mu)^2/sig^2)
end
visualize(lst, mu-3*sig, mu+3*sig, 6*sig/10, pdf)

-- gamma distribution
alpha = 7; beta = 1
for i = 1, N do
  lst[i] = rnd:gamma(alpha, beta)
end

-- show gamma distribution
gamma = Spec:gamma(alpha)
pdf = function (x)
  return beta^alpha * x^(alpha-1) * math.exp(-beta*x)/gamma
end
visualize(lst, 2, 14, 1.2, pdf)

-- Poisson distribution
lambda = 4
for i = 1, N do
  lst[i] = Rand:poisson(lambda)
end

-- show Poisson distribution
-- find factorial
function fact(n)
  local p = 1
  for k = 2, n do p = p * k end
  return p
end
pmf = function (x)
  x = math.floor(x)  -- to 'integer'
  return lambda^x * math.exp(-lambda) / fact(x)
end
visualize(lst, 0, 10, 1, pmf)

-- binomial distribution
n = 20; p = 0.4
for i = 1, N do
  lst[i] = Rand:binomial(p, n)
end

-- show binomial distribution
pmf = function (x)
  x = math.floor(x)  -- to 'integer'
  return fact(n) * p^x * (1-p)^(n-x) / fact(x) / fact(n-x)
end
visualize(lst, 0, n, n/10, pmf)

-- get random true/false
v = Rand:flip()
ans = type(v)                 -->  'boolean'

-- get integer from 1 to 10
v = Rand:int(10)
ans = (1 <= v and v <= 10)    -->  true

-- random order iterator
a = {1, 2, 3, 4, 5}
for i, v in Rand:ipairs(a) do print(i, v) end

-- random choice
v, i = Rand:choice(a)
ans = v                       -->  a[i]

-- change order in place
Rand:shuffle(a)
for i, v in ipairs(a) do print(i, v) end

-- random chars
print(rnd:bytes(8))

-- same seed
r1 = Rand:new():seed(1)
r2 = Rand:new():seed(1)
ans = (r1() == r2())          -->  true

-- change seed
r2:seed(2)
ans = (r1() ~= r2())          -->  true

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Rat"></a>
<h3># Rat (rational) #</h3>
<p class="descript">Computations with rational numbers.</p>
<p><b>R:denom() --> var</b> - Return the denominator of the rational number.<br>
<b>R:float() --> num</b> - Return rational number as decimal.<br>
<b>R:num() --> var</b> - Return the numerator of rational number.<br>
<b>R:toCF() --> coeff_t</b> - Transform rational number to continued fraction.<br>
<b>Rat (num, denom=1) --> new_R</b> - Create rational number using num (and denom).<br>
<b>Rat:from(src_f, err_f=1E-3) --> R</b> - Estimate ratio from floating point value.<br>
<b>Rat:fromCF(coeff_t) --> R</b> - Transform continued fraction to rational number.<br></p>
<pre class="example">

-- use 'rational'
Rat = require 'matlib.rational'

-- numerator, denominator
a = Rat(1,2)
-- only numerator
b = Rat(2)
ans = b                       -->  Rat(2,1)

-- simplification
k = 234781
ans = Rat(2*k,3*k)            -->  Rat(2,3)

-- arithmetic
ans = a + b                   -->  Rat(5,2)

ans = 2 * a                   -->  1

ans = Rat(2,3)*Rat(3,2)       -->  1

ans = a / Rat(1,3)            -->  Rat(3,2)

ans = a ^ 3                   -->  Rat(1,8)

ans = 2 ^ a                  --3>  1.414

-- comparison
ans = (b == b)                -->  true

ans = (a >= b)                -->  false

-- represent as decimal
ans = a:float()               -->  0.5

-- from decimal
ans = Rat:from(math.pi)       -->  Rat(333, 106)

-- numerator
ans = b:num()                 -->  2

-- denominator
ans = b:denom()               -->  1

-- show
print(a)

-- continued fraction to rational
-- 1 + 1/(2+1/(3+1/4))
c = Rat:fromCF {[0]=1, 2, 3, 4}
ans = c                       -->  Rat(43,30)

-- rational to continued fraction
d = c:toCF()
ans = d[1]                    -->  2

-- show continued fraction
print(d)

-- result is rational
ans = a + 1                   -->  Rat(3,2)

-- result is float
ans = a + 0.5                 -->  1

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Spec"></a>
<h3># Spec (special) #</h3>
<p class="descript">Special mathematical functions.</p>
<p><b>Spec:besseli(order_N, x_d) --> num</b> - Modified Bessel function In(x).<br>
<b>Spec:besselj(order_N, x_d) --> num</b> - Bessel function of the first kind.<br>
<b>Spec:besselk(order_N, x_d) --> num</b> - Modified Bessel function Kn(x).<br>
<b>Spec:bessely(order_N, x_d) --> num</b> - Bessel function of the second kind.<br>
<b>Spec:beta(z_d, w_d) --> num</b> - Beta function.<br>
<b>Spec:betainc(x_d, a_d, b_d) --> num</b> - Incomplete beta function Ix(a,b).<br>
<b>Spec:betaln(z_d, w_d) --> num</b> - Natural logarithm of beta function.<br>
<b>Spec:dawson(x_d) --> num</b> - Dawson integral.<br>
<b>Spec:erf(x_d) --> num</b> - Error function.<br>
<b>Spec:erfc(x_d) --> num</b> - Complementary error function.<br>
<b>Spec:expint(pow_N, x_d) --> num</b> - Exponential integral En(x).<br>
<b>Spec:gamma(x_d) --> num</b> - Gamma function.<br>
<b>Spec:gammaln(x_d) --> num</b> - Natural logarithm of gamma function.<br>
<b>Spec:gammp(order_N, x_d) --> num</b> - Incomplete gamma function P(N,x).<br>
<b>Spec:gammq(order_N, x_d) --> num</b> - Incomplete gamma function Q(N,x) = 1-P(N,x).<br></p>
<pre class="example">

-- use 'special'
Spec = require 'matlib.special'

-- beta functions
ans = Spec:beta(3,4) * 1E2   --3>  1.667

ans = Spec:betaln(10,20)     --3>  -19.115

ans = Spec:betainc(0.5, 2, 3.3)  --3>  0.7309

-- error functions
ans = Spec:erf(1)            --3>  0.8427

ans = Spec:erfc(0.5)         --3>  0.4795

-- Ei(x)
ans = Spec:expint(3.3) * 1E3   --3>  8.939

-- E3(x)
ans = Spec:expint(2, 5) * 1E4  --3>  9.965

-- gamma functions
ans = Spec:gamma(-1.5)       --3>  2.3633

ans = Spec:gammaln(100)      --3>  359.1342

ans = Spec:gammp(7.7, 2.3) * 1E3  --2>  3.85

ans = Spec:gammq(1.5, 4.8) * 1E2  --2>  2.23

-- Bessel functions
ans = Spec:besselj(3, 1.5) * 1E2  --3>  6.096

ans = Spec:bessely(4, 0.8)   --3>  -78.751

ans = Spec:besseli(2, -3.6)  --3>  4.254

ans = Spec:besselk(5, 5) * 1E2   --3>  3.2706

-- Dawson function
ans = Spec:dawson(3.3)       --3>  0.1598

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Sym"></a>
<h3># Sym (symbolic) #</h3>
<p class="descript">Symbolic calculations.</p>
<p><b>S:diff(var_S) --> derivative_S</b> - Find symbolic derivative.<br>
<b>S:eval(env_t={}) --> upd_S|num</b> - Evaluate symbolic expression with the given environment.<br>
<b>S:expand() --> expanded_S</b> - Expand product of polynomials when possible.<br>
<b>S:isFn() --> bool</b> - Return true if the symbol is function.<br>
<b>S:ratDenom() --> denominator_S</b> - Get denominator of the expression.<br>
<b>S:ratNum() --> numerator_S</b> - Get numerator of the expression.<br>
<b>S:struct() --> str</b> - Show internal structure.<br>
<b>S:val() --> num</b> - Get constant value.<br>
<b>Sym (num|str) --> new_S</b> - Create new symbolic variable.<br>
<b>Sym:def(name_s, args_t, expr_S) --> fn_S</b> - Define symbolical function. S is either symbolic expression or a Lua function.<br>
<b>Sym:parse(expr_s) --> S1, S2, ..</b> - Get simbolic expression from string.<br></p>
<pre class="example">

-- use 'symbolic'
Sym = require 'matlib.symbolic'

-- create variables
x, y = Sym('x'), Sym('y')
ans = (x == y)                -->  false

-- sum
ans = x + 2*y - x + y         -->  3*y

-- product
ans = x * y^2 / x * y         -->  y^3

-- power
ans = x^y * x^(2*y)           -->  x^(3*y)

-- evaluate
S = (x+y)*(x-y)
ans = S:eval{x=2, y=1}        -->  Sym(3)

-- define function
foo = Sym:def('foo', {x, y}, x^y)
ans = foo(y, x)               -->  y^x

-- numeric value
ans = foo(Sym(2), Sym(3)):val()  -->  8

-- get by name
ssin = Sym.fn.sin
ans = ssin:isFn()             --> true

-- expand
ans = S:expand()              -->  x*x-y*y

-- derivative
ans = (x^3-ssin(2*x)):diff(x)       -->  3.0*x*x-2*Sym.fn.cos(2*x)

-- parts
S1 = (x-y)/(x+y)
ans = S1:ratNum()                -->  x-y

ans = S1:ratDenom()              --> x+y

-- internal structure
print(S1:struct())

--</pre>
<a href="#Top">Top</a></div>
<div><a name="U"></a>
<h3># U (units) #</h3>
<p class="descript">Operations and conversations according the units.</p>
<p><b>U (val=1, name_s) --> new_U</b> - Create new elements with units.<br>
<b>U.prefix</b> - Table of possible prefixes for units.<br>
<b>U.rules</b> - Table of rules for conversation.<br>
<b>U:convert(new_s) --> upd_U|nil</b> - Convert one units to another, return new object or nil.<br>
<b>U:copy() --> cpy_U</b> - Create copy of the element.<br>
<b>U:u() --> str</b> - Get units.<br></p>
<pre class="example">

-- use 'units'
U = require 'matlib.units'

-- add some rules
U.rules['h'] = U(60,'min')
U.rules['min'] = 60 * U's'

-- define variable
a = U(1,'m/s')
-- convert to km/h, get only value
ans = a('km/h')              --2>  3.6

-- equal syntax
ans = a 'km/h'               --2>  3.6

-- get numerical value (skip key)
ans = a()                     -->  1

-- get units
ans = a:u()                   -->  'm/s'

-- make copy
cp = a:copy()
ans = cp                      -->  U(1,'m/s')

-- get converted variable
b = a:convert('km/h')
ans = b                       -->  U(3.6, 'km/h')

-- arithmetic
b = 3 * b
ans = a + b                   -->  U(4, 'm/s')

ans = b - a                   -->  U(2, 'm/s')

ans = a * b                   -->  U(3, 'm^2/s^2')

ans = b / a                   -->  U(3, '')

ans = (a < b)                 -->  true

ans = b ^ 3                   -->  U(27, 'm^3/s^3')

-- another definition syntax
ans = 2 * U('N')              -->  U(2,'N')

-- show result
print(a)

-- list of rules
print(U.rules)
--</pre>
<a href="#Top">Top</a></div>
<div><p align="center"><i>2017-2024, Stanislav Mikhel</i></p></div>
</body></html>