---------- locale/ru.lua ----------

return {
----------
language = 'Русский',
authors  = [[Станистав Михель]],
---------- dialog ----------
Dialog = {
["cmd_help"]               = [[Показать эту справку]],
["cmd_ls"]                 = [[Отобразить список блоков]],
["cmd_N"]                  = [[Выполнить блок N]],
["cmd_o"]                  = [[Открыть note-файл]],
["intro"]                  = [[-------- help([функция]) = справка --------------
---------- use([модуль]) = импорт функций -------
----------------- quit() = выход ----------------
]],
["cmd_q"]                  = [[Выйти]],
["cmd_trace"]              = [[Профилирование функции]],
["cmd_time"]               = [[Оценка времени работы функции]],
["cmd_rm"]                 = [[Очистить список блоков]],
["cmd_show"]               = [[Отобразить следующий или заданный блок]],
["cmd_log"]                = [[Включить/выключить запись лога]],
["done"]                   = [[Выполнено.]],
},
---------- asciiplot.lua ----------
asciiplot = {
["F:axes() --> tbl"]       = [[Получить информацию по каждой оси в виде таблицы {size, log, range, pose}.]],
["F:copy() --> cpy_F"]     = [[Возвращает копию объекта.]],
["F:setX(par_t={range,view,log,fix})"] = [[Установить X диапазон.]],
["F:title(str)"]           = [[Установить название графика.]],
["F:addString(row_N, col_N, str)"] = [[Добавление строки в указанную позицию.]],
["F:addPose(row_N, col_N, char_s)"] = [[Установка символа в указанную позицию.]],
["F:legend(str_t)"]        = [[Настроить подписи.]],
["__module__"]             = [[Визуализация данных с помощью псевдо-графики.]],
["F:scale(factor_d, isDefault=false) --> F"] = [[Изменить размер графика относительно начальных размеров.]],
["F:plot(...)"]            = [[Построение графиков данных для аргументов типа 't', 't1,t1', 'fn,nm', 'fn1,fn2' и т.д.]],
["F:addPoint(x_d, y_d, char_s)"] = [[Добавить точку с координатами (x,y) с помощью символа.]],
["F:contour(fn, {level=5, view='XY'}) --> nil|str"] = [[Проекция контуров функции fn(x,y). Проекции: XY, XZ, YZ, concat.]],
["Plot(...)"]              = [[Построение графиков данных для аргументов типа 't', 't1,t1', 'fn,nm', 'fn1,fn2' и т.д.]],
[" (width_N=73, height_N=21) --> new_F"] = [[Новый график.]],
["F:setZ(par_t={range,view,log,fix})"] = [[Установить Z диапазон.]],
["F:bar(t, y_N=2, x_N=1)"] = [[Столбчатая диаграмма. vy может быть индексом y в таблице t либо списком y-в.]],
["F:resize(src_F | (width_N, height_N))"] = [[Задать новый размер графика.]],
["F:setY(par_t={range,view,log,fix})"] = [[Установить Y диапазон.]],
["F:tplot(data_t, cols_N={})"] = [[Построение графика на основе таблицы, можно указать номера столбцов и дополнительные опции.]],
[":concat(...) --> str"]   = [[Горизонтальное объединение графиков равного размера. Для двух объектов можно использовать оператор '..' .]],
["F:reset()"]              = [[Очистка холста.]],
},
---------- bigint.lua ----------
bigint = {
["B:base(N) --> tbl"]      = [[Возвращает основание системы счисления.]],
["B:eq(x) --> bool"]       = [[Проверка равенства двух чисел.]],
[" (var) --> new_B"]       = [[Создаёт большое целое число на основе числа, строки или таблицы.]],
["B:float() --> num"]      = [[Представление в виде числа с плавающей точкой.]],
[":P(n, k) --> permutaions_B"] = [[Возвращает число перестановок без повторов.]],
["B:abs() --> num"]        = [[Возвращает модуль числа.]],
["__module__"]             = [[Вычисления с целыми числами произвольной длины.]],
["B:isPrime([method_s]) --> bool"] = [[Проверка числа на простоту. Установите метод 'Fermat' для использования малой теоремы Ферма.]],
[":ratF(num_B, denom_B) --> num!/denom!"] = [[Вычисляет отношение факториалов num!/denom!.]],
["B:sign() --> int"]       = [[Возвращает +1/0/-1.]],
[":C(n, k) --> combinations_B"] = [[Возвращает число компинаций из n по k.]],
["B:gcd(B2) --> B3"]       = [[Наибольший общий делитель.]],
[":random(B) --> rand_B"]  = [[Псевдо-случайное число от 0 до B.]],
["B:F() --> B!"]           = [[Возвращает факториал положительного числа.]],
["B:factorize() --> primeBs_t"] = [[Возвращает список простых множителей для данного числа.]],
},
---------- complex.lua ----------
complex = {
["C:asin() --> y_C"]       = [[Комплексный обратный синус.]],
["C:atanh() --> y_C"]      = [[Комплексный обратный гиперболический тангенс.]],
[":i(x=1) --> new_C"]      = [[Возвращает комплексное число v*i.]],
["C:im() --> var"]         = [[Мнимая часть.]],
["C:abs() --> float"]      = [[Модуль комплексного числа.]],
["C:exp() --> y_C"]        = [[Комплексная экспонента.]],
[":trig(module, angle) --> module*exp(i*angle)"] = [[Создание комплексного числа по модули и агрументу.]],
["C:sqrt() --> y_C"]       = [[Комплексный квадратный корень.]],
["C:tan() --> y_C"]        = [[Комплексный обратный тангенс.]],
["__module__"]             = [[Вычисления с комплексными числами.]],
["C:tanh() --> y_C"]       = [[Комплексный гиперболический тангенс.]],
["C:sinh() --> y_C"]       = [[Комплексный гиперболический синус.]],
["C:acos() --> y_C"]       = [[Комплексный обратный косинус.]],
["C:asinh() --> y_C"]      = [[Комплексный обратный гиперболический синус.]],
["C:conj() --> conj_C"]    = [[Комплексно-сопряженное число. Эквивалентно ~C.]],
["C:sin() --> y_C"]        = [[Комплексный синус.]],
["C:round(N=6) --> rounded_C"] = [[Возвращает число с округлением до заданного количества знаков.]],
["C:log() --> y_C"]        = [[Комплексный логарифм.]],
["C:re() --> var"]         = [[Действительная часть.]],
["C:cos() --> y_C"]        = [[Комплексный обратный косинус.]],
["C:acosh() --> y_C"]      = [[Комплексный обратный гиперболический косинус.]],
["C:atan() --> y_C"]       = [[Комплексный обратный тангенс.]],
["C:arg() --> float"]      = [[Возвращает агрумент комплексного числа.]],
["C:cosh() --> y_C"]       = [[Комплексный гиперболический косинус.]],
[" (re=0, im=0) --> new_C"] = [[Создать новое комплексное число.]],
},
---------- const.lua ----------
const = {
["__module__"]             = [[Разнообразные константы.]],
[":remove(name_s) --> bool"] = [[Удаление константы.]],
[":add(name_s, value, [units_s])"] = [[Добавление временной константы.]],
[".phy.e --> 1.6E-19"]     = [[Заряд электрона.]],
[".phy.sigma --> 5.6E-8"]  = [[Постоянная Стефана-Больцмана.]],
[".phy.NA --> 6E23"]       = [[Число Авогадро.]],
[".math.phi --> 1.62"]     = [[Золотое сечение.]],
[".math.pi --> 3.14"]      = [[Отношение длины окружности к её диаметру.]],
[".astro.pc --> 3.1E16"]   = [[Один парсек.]],
[".astro.ly --> 9.5E15"]   = [[Световой год.]],
[".phy.Rinf --> 1.1E7"]    = [[Постоянная Ридберга.]],
[".phy.Vm --> 2.2E-2"]     = [[Объём моля идеального газа.]],
[".phy.g --> 9.81"]        = [[Ускорение свободного падения.]],
[".phy.G --> 6.7E-11"]     = [[Гравитационная постоянная.]],
[".phy.k --> 1.4E-23"]     = [[Постоянная Больцмана.]],
[".math.e --> 2.72"]       = [[Основание натурального логарифма.]],
[".astro.au --> 1.5E11"]   = [[Астрономическая единица.]],
[".phy.h --> 6.6E-34"]     = [[Постоянная Планка.]],
[".phy.c --> 3E8"]         = [[Скорость света.]],
[".phi.Da --> 1.7E-27"]    = [[Атомная единица массы.]],
[".phy.mu0 --> 1.2E-6"]    = [[Магнитная постоянная.]],
[".phy.R --> 8.31"]        = [[Универсальная газовая постоянная.]],
[".phy.eps0 --> 8.8E-12"]  = [[Электрическая постоянная.]],
},
---------- data.lua ----------
data = {
[":md(data_t, names_t=nil, row_fn=nil) --> str"] = [[Печать таблицы в стиле Markdown. Строки могут быть обработаны функцией row_fn(t)-->t.]],
[":max(data_t) --> var, ind_N"] = [[Максимальный элемент и его индекс.]],
[":sum(data_t) --> var"]   = [[Возвращает сумму элементов.]],
[":csvread(file_s, delim_s=',') --> tbl"] = [[Формирует таблицу на основе файла с заданным разделителем.]],
[":harmmean(data_t, [weigh_t]) --> num"] = [[Гармоническое среднее.]],
[":moment(order_N, data_t, [weigth_t]) --> num"] = [[Центральный момент t порядка N (с весами tw).]],
[":range(begin_d, end_d, [step_d]) --> new_R"] = [[Генерация диапазона чисел.]],
[":ref(src_t, begin_N=1, end_N=#src_t) --> new_R"] = [[Возвращает "ссылку" на таблицу элементов.]],
[":median(data_t) --> num"] = [[Возвращает медиану распределения.]],
[":T(src_t) --> new_T"]    = [[Возвращает указатель на 'транспонированную' таблицу.]],
["__module__"]             = [[Обработка данных и статистические расчёты.]],
[":zip(fn,...) --> tbl"]   = [[Последовательно применяет функцию к списку векторов.]],
[":csvwrite(file_s, data_t, char=',')"] = [[Сохраняет таблицу в файл с заданным разделителем.]],
[":geomean(data_t, [weigh_t]) --> num"] = [[Геометрическое среднее.]],
[":cov(data_t) --> cov_M"] = [[Возвращает матрицу ковариации для списка векторов.]],
[":cov2(xs_t, ys_t) --> float"] = [[Вычисляет ковариацию для двух списков.]],
[":filter(in_t, condition) --> out_t"] = [[Вильтрует список данных. Условием является булева функция или массив весов.]],
[":mean(data_t, [wight_t]) --> num"] = [[Вычисляет среднее значение.]],
[":min(data_t) --> var, ind_N"] = [[Возвращает наименьший элемент и его индекс.]],
[":Fn(expr_s, arg_N=2) --> fn"] = [[Генерирует функцию из строки с параметрами x1, x2 и т.д.]],
[":std(data_t, [weight_t]) --> dev_f, var_f"] = [[Возвращает стандартное отклонение и дисперсию.]],
[":isNot(data_t, cond_fn) --> yesno_t"] = [[Возвращает инвертированные веса для булевой функции.]],
[":freq(data_t) --> tbl"]  = [[Возвращает таблицу частот элементов.]],
[":histcounts(data_t, rng_v=10) --> sum_t, edges_t"] = [[Распределение данных по интервалам. Можно указать число интервалов разбиения, либо задать границы в виде таблицы.]],
[":is(data_t, cond) --> yesno_t"] = [[Возвращает массив весов на основе булевой функции.]],
[":reduce(fn, data_t, [initial]) --> var"] = [[Итеративное применение функции к элементам списка и предыдущему результату.]],
[":copy(t) --> copy_t"]    = [[Глубокое копирование списка.]],
},
---------- geodesy.lua ----------
geodesy = {
["__module__"]             = [[Преобразования координат и другие геодезические задачи.]],
[":deg2dms(deg_d) --> num"] = [[Возвращает градусы, минуты и секунды для заданного угла в градусах.]],
[":dms2rad(deg_d, min_d=0, sec_d=0) --> num"] = [[Преобразует градусы, минуты и секунды в радианы.]],
["E:solveInv(blh1_t, blh2_t) --> dist_d, az1_d, az2_d"] = [[Решение обратной задачи геодеции, поиск расстояния и азимутов для двух заданных точек.]],
[":hashEncode(coord_t, letter_N=6) --> hash_s"] = [[Вычисления геохэша для точки.]],
[":hashDecode(hash_s) --> coord_t, range_t"] = [[Определения положения зоны по геохэшу.]],
[":toENU(blRef_t, xyzRef_t, xyzObs_t) --> top_t"] = [[Преобразовать геоцентрические координаты точки в топоцентрические.]],
["E:toBLH(xyz_t) --> blh_t"] = [[Приобразовать геоцентрические координаты в геодезические.]],
["E.xyzInto[E2] --> fn"]   = [[Возвращает функцию для преобразования геоцентрических координат из системы A в B.]],
["E:toXYZ(blh_t) --> xyz_t"] = [[Преобразует геодезические координаты в геоцентрические.]],
[":fromENU(blRef_t, xyzRef_t, top_t) --> xyzObs_t"] = [[Преобразовать топоцентрические координаты точки в геоцентрические.]],
["E:solveDir(blh_t, az1_d, dist_d) --> blh_t, az2_d"] = [[Решение прямой задачи геодезии, поиск положения и азимута второй точки при заданных начальной точке, направлении и расстоянии.]],
["E:ll2utm(blh_t) --> utm_t"] = [[Найти UTM проекцию для заданных координат.]],
[":grav(latitude_d) --> num"] = [[Международная формула гравитации, аргумент в радианах.]],
["E:utm2ll(utm_t) --> blh_t"] = [[Найти геодезические координаты для заданной UTM позиции и зоны.]],
["E.blhInto[E2] --> fn"]   = [[Возвращает функцию для преобразования геодезических координат из A в B с помощью метода Молоденского.]],
},
---------- gnuplot.lua ----------
gnuplot = {
["__module__"]             = [[Интерфейс для взаимодействия с Gnuplot.]],
[":polarplot(x1_t, y1_t, [nm_s, x2_t, y2_t,..])"] = [[График в полярных координатах. 'x' - список чисел, 'y' - список либо функция, 'nm' - имя кривой.]],
[":tpolar(var, [x_N, y1_N, y2_N,..])"] = [[График в полярных координатах для таблицы, матрицы или файла. Опциональные элементы определяют стоблцы.]],
[".keys"]                  = [[  Описание параметров:
{math.sin, title='sin'}                      -- строит график для Lua функции, добавляет текст в легенду
{'sin.dat', ln=1, lw=2}                      -- строит график для файла с учётом цвета и толщины маркеров
{tbl, with='lines'}                          -- строит график для Lua таблицы с помощью линий
title='Graph name'                           -- имя графика в целом
xrange={0,10}                                -- диапазон x от 0 до 10
yrange={-2,2}                                -- диапазон y
zrange={0,5}                                 -- диапазон z
trange={1,2}                                 -- изменение параметра в случае параметрической функции
xtitle='A', ytitle='B'                       -- имена осей
terminal='jpeg'                              -- сохранение результата в файл
output='my_plot.jpg'                         -- имя файла для вывода результата
parametric=true                              -- параметрическое представление функции
size='square'                                -- установить квадратный размер изображения
polar=true                                   -- график в полярных координатах
grid='polar'                                 -- изменить тип сетки на полярный
legend=false                                 -- отключить легенду
surface=true                                 -- построение трёхмерного графика
samples=200                                  -- задать число точек на графике
raw='set pm3d'                               -- позволяет написать команды Gnuplot в явном виде
]],
[":tplot(var, [x_N, y1_N, y2_N,..])"] = [[Построение графика на основе таблицы, матрицы или файла. Опциональные элементы определяют необходимые столбцы.]],
[" () --> new_G"]          = [[Подготовка таблицы для Gnuplot.]],
[":plot(x1_t, [y1_t, nm_s, x2_t,..])"] = [[График в полярных координатах. 'x' - список чисел, 'y' - список либо функция, 'nm' - имя кривой.]],
[":tsurf(var, [x_N, y_N, z1_N, z2_N,..])"] = [[Построение графика поверхности на основе таблицы, матрицы или файла. Опциональные элементы определяют необходимые столбцы.]],
[":surfplot(x1_t, y1_t, fn1, [nm_s, x2_t, y2_t,..])"] = [[Построение поверхности. 'x' и 'y' - списки чисел, 'fn' - функция двух агрументов, 'nm' - имя поверхности.]],
["G:show()"]               = [[Строит график на основе параметров, представленных в виде таблицы Lua.]],
["G:copy() --> cpy_G"]     = [[Возвращает копию параметров графика.]],
["G:add(curve_v)"]         = [[Добавить функцию для построения.]],
},
---------- graph.lua ----------
graph = {
[" () --> new_G"]          = [[Создаёт ненаправленный граф.]],
["G:pathD(startNode, [goalNode]) --> dist_d, path_t|prev_t"] = [[Поиск кратчайшего пути алгоритмом Дейкстры. Возвращает таблицу расстояний и узлов. Если задана цель, возвращает путь и его длину.]],
["G:copy() --> cpy_G"]     = [[Создаёт копию графа.]],
["G:isComplete() --> bool"] = [[True если граф полный.]],
["G:add(n1, n2=nil, w_d=1)"] = [[Добавляет узел (одиночное имя) или ребро. Ребро представлено списком, содержащим начало, конец и, при необходимости, вес (веса).]],
["G:isWeighted() --> bool"] = [[True если граф взвешенный.]],
["__module__"]             = [[Операции с графами.]],
["G:size() --> nodes_N"]   = [[Число узлов графа.]],
["G:dot() --> str"]        = [[Возвращает описание структуры в dot формате.]],
["G:addEdges(list_t)"]     = [[Импортирует рёбра и веса из списка.]],
["G:toSvg(name_s)"]        = [[Сохраняет граф в SVG изображене с помощью Graphviz.]],
["G:remove(n1, [n2])"]     = [[Удаляет узел или ребро. Узлы представляются именем, рёбра - двухэлементным списком.]],
["G:dfs(startNote, goalNode) --> isFound, path_t"] = [[Поиск в глубину. Возвращает флаг результата и найденный путь.]],
["G:bfs(startNode, goalNode) --> isFound, path_t"] = [[Поиск в ширину. Возвращает флаг результата и найденный путь.]],
[":dir() --> new_G"]       = [[Создаёт направленный граф.]],
["G:isDirected() --> bool"] = [[True если граф направленный.]],
["G:nodes() --> node_t"]   = [[Возвращает список узвло графа.]],
["G:addNodes(list_t)"]     = [[Импортирует узлы из списка.]],
["G:edges() --> edges_t"]  = [[Возвращает список рёбер.]],
["G:edge() --> weight_d|nil"] = [[Возвращает вес ребра.]],
["G:isNegative() --> bool"] = [[True если граф содержит отрицательные веса.]],
},
---------- lens.lua ----------
lens = {
[":solve(fn, index_N, initial_d) --> found_d"] = [[Поиск условий, при которых компонент с заданным индексом равен 0. d0 - начальное предположение.]],
["L:transform(yIn_d, VIn_d) --> yOut_d, VOut_d"] = [[Определяет положение луча 'dy' и оптический угол 'dV' (= v*n) на выходе оптической системы. Эквивалентно вызову L(dy,dV).]],
[":gaussSize(waist_d, lambda_d, dist_d) --> rad_d, curv_d"] = [[Определение радиуса и кривизны гаусова пучка на заданном расстоянии.]],
[" (A_d, B_d, C_d, D_d) --> new_L"] = [[Новый объект с произвольными параметрами A, B, C, D.]],
[":ref(rad_d, n1_d, n2_d) --> L"] = [[Возвращает матрицу для преломления с учётом показателей преломления и радиуса кривизны поверхности.]],
[":trans(dist_d, n_d=1) --> L"] = [[Возвращает матрицу перемещения с учётом показателя преломления.]],
[":gaussParam(waist_d, lambda_d) --> div_d, range_d"] = [[Определение расходимости и размера ближней зоны пучка.]],
["L:isUnit() --> bool"]    = [[Проверка, является ли матрица единичной.]],
["__module__"]             = [[Матричные методы в параксиальной оптике.]],
["L:copy() --> cpy_L"]     = [[Возвращает копию объекта.]],
[":mirror(rad_d, n_d) --> L"] = [[Возвращает матрицу отражения на кривой поверхности с учётом показателя преломления.]],
[":thin(focalDist_d) --> L"] = [[Возвращает матрицу для тонкой линзы при заданном фокальном расстоянии.]],
["L:det() --> determinant_d"] = [[Возвращает определитель матрицы.]],
[":afocal(magn_d) --> L"]  = [[Возвращает матрицу для афокальной системы.]],
["L:cardinal(nLft_d=1, nRht_d=1) --> points_t"] = [[Поиск положения кардинальных точек системы относительно входных и выходных плоскостей, с учётом показателей преломления. Возвращает список расстояний.]],
["L:beam(inRad_d, inCurv_d, lambda_d) --> outRad_d, outCurv_d"] = [[Определение радиуса и кривизны фронта гаусова пуска на выходе из системы.]],
["L:inv() --> inv_L"]      = [[Инвертированная матрица системы.]],
},
---------- main.lua ----------
main = {
["cos(x) --> y"]           = [[Косинус x.]],
["asinh(x) --> y"]         = [[Гиперболический арксинус.]],
["atan(x) --> y"]          = [[Арктангенс x.]],
["atan2(y_d, x_d) --> num"] = [[Арктангенс dy/dx с учётом знака.]],
["tan(x) --> y"]           = [[Тангенс x.]],
["acosh(x) --> y"]         = [[Гиперболический арккосинус.]],
["log(x) --> y"]           = [[Натуральный логарифм.]],
["Round(x_d, N=0) --> num"] = [[Округление числа до заданного количества десятичных знаков.]],
["exp(x) --> y"]           = [[Экспонента.]],
["sinh(x) --> y"]          = [[Гиперболический синус.]],
["__module__"]             = [[Программа для математических расчётов на Lua.]],
["asin(x) --> y"]          = [[Арксинус x.]],
["abs(x) --> num"]         = [[Абсолютная величина.]],
["atanh(x) --> y"]         = [[Гиперболический арктангенс.]],
["quit()"]                 = [[Выход из программы.]],
["sin(x) --> y"]           = [[Синус x.]],
["Map(fn, in_t) --> out_t"] = [[Вычисляет функцию для всех элементов списка (таблицы), возвращает новый список.]],
["tanh(x) --> y"]          = [[Гиперболический тангенс.]],
["help(fn='main') --> str"] = [[Описание модуля, функции или элемента.]],
["use([module_s]) --> str|nil"] = [[Используйте use('модуль') или use{'модульA','модульB'} для подключения дополнительных модулей.]],
["acos(x) --> y"]          = [[Арккосинус x.]],
["sqrt(x) --> y"]          = [[Квадратный корень.]],
["cosh(x) --> y"]          = [[Гиперболический косинус.]],
["Bind(obj, fn_name) --> fn"] = [[Обёртывание функции для вызова без объекта.]],
["pi --> 3.14"]            = [[Число пи.]],
},
---------- matrix.lua ----------
matrix = {
["M:range(rows_t, cols_t) --> range_M"] = [[Возвращает подматрицу с заданным интервалом строк и столбцов.]],
["V:dot(V2) --> num"]      = [[Скалярное произведение векторов.]],
["M:reshape(row_N=size, col_N=1) --> upd_M"] = [[Изменить размер матрицы.]],
[":V {...} --> new_V"]     = [[Создать вектор из списка чисел.]],
["M:inv() --> inv_M"]      = [[Обратная матрица.]],
["M:round(N=6)"]           = [[Округлить все элементы матрицы до заданного числа знаков.]],
["M:minor(row_N, col_N) --> minor_M"] = [[Возвращает минорную матрицу для заданного элемента.]],
[":eye(row_N, col_N=row_N) --> M"] = [[Единичная матрица.]],
["M:kron(M2) --> M3"]      = [[Произведение Кронеккера.]],
["M:H() --> conj_M"]       = [[Сопряженная транспонированная матрица.]],
["M:bidiag() --> U_M, B_M, V_M"] = [[Бидиагонализация матрицы, возвращает U, B, V.]],
["M:insert(rows_t, cols_t, M2)"] = [[Вставляет матрицу в заданный диапазон строк и столбцов.]],
["M:tr() --> sum"]         = [[След матрицы.]],
["M:norm() --> num"]       = [[Евклидова норма.]],
["M:eig() --> vectors_M, values_M"] = [[Возвращает матрицы из собственных векторов и чисел.]],
["M:pinv() --> inv_M"]     = [[Вовзращает псевдо-обратную матрицу.]],
["M:cols() --> N"]         = [[Число столбцов.]],
[" {row1_t, row2_t,..} --> new_M"] = [[Создаёт матрицу на основе списка строк.]],
[":zip(fn, M1, M2,..) --> res_M"] = [[Поэлементно применяет функцию к матрицам для формирования новой матрицы.]],
[":zeros(row_N, col_N=row_N) --> M"] = [[Формирует матрицу нулей.]],
["M:vectorize() --> V"]    = [[Преобразование в вектор по столбцам.]],
["M:T() --> transpose_M"]  = [[Транспонирование матрицы. Эквивалентно T().]],
["M:svd() --> U_M, S_M, V_M"] = [[Сингулярное разложение матрицы, возвращает U, S, V.]],
["M:table() --> tbl"]      = [[Преобразует матрицу в обыкновенную Lua таблицу.]],
["M:diag() --> V"]         = [[Извлекает диагональные элементы матрицы.]],
["M:concat(M2, dir_s) --> comb_M"] = [[Объединяет две матрица горизонтально (dir='h') или вертикально (dir='v').
Горизонтальная конкатенация доступна в виде M1 .. M2, а вертикальная - M1 // M2.]],
["M:rref() --> upd_M"]     = [[Преобразование матрицы методом Гаусса.]],
["M:chol() --> lower_M"]   = [[Преобразование Холески для положительно определённой симметричной матрицы.]],
[":D(list_v) --> M"]       = [[Матрица с заданными диагональными элементами.]],
[":fill(row_N, col_N, val=1) --> M"] = [[Создать матрицу, заполненную заданным числом.]],
["V:cross(V2) --> V3"]     = [[Векторное произведение 3-элементных векторов.]],
["M:qr() --> Q_M, R_M"]    = [[QR разложение матрицы. Возвращает Q и R.]],
["M:det() --> num"]        = [[Определитель матрицы.]],
["M:rows() --> N"]         = [[Число строк.]],
["M:copy() --> cpy_M"]     = [[Возвращает копию матрицы.]],
["M:kronSum(M2) --> M3"]   = [[Сумма Кронеккера.]],
["M:lu() --> L_M, U_M, perm_M"] = [[LU преобразование матрицы. Возвращает L, U и P.]],
["M:map(fn) --> found_M"]  = [[Формирует новую матрицу путём применения указанной функции к исходной. Функция может зависеть как от элементов, f(x) так и от индексов f(x,row,col).]],
["__module__"]             = [[Операции с матрицами. На нулевые элементы память не расходуется. Индексация с единицы.]],
["M:rank() --> N"]         = [[Возвращает ранг матрицы.]],
["M:star(cond_fn) --> str"] = [[Печать элементов матрицы в виде звёздочек при выполнении заданного условия.]],
},
---------- numeric.lua ----------
numeric = {
["__module__"]             = [[Функции для численных расчётов. Все функции работают с точностью, определяемой параметром TOL.]],
[":trapez(fn, x1_d, x2_d) --> num"] = [[Интегрирование методом трапеций.]],
[":lim(fn, xn_d, isPositive) --> y, isFound"] = [[Оценка предела функции.]],
[":der(fn, x_d) --> num"]  = [[Оценка производной функции в точке.]],
[":solve(fn, xLow_d, xUp_d) --> num"] = [[Поиск корня уравнения fn(x)=0 на интервале [a,b].]],
[":newton(fn, x0_d) --> num"] = [[Поиск корня методом Ньютона в окрестностях заданной точки.]],
[":ode45(fn, interval_t, y0, {dt=10*TOL,exit=nil}) --> ys_t"] = [[Численное решение ОДУ.
Первый параметр задаёт уравнение, второй - временной интервал, третий - начальное значение функции. Дополнительно можно определить такие параметры как шаг интегрирования и условие прерывания.
Возвращает таблицу промежуточных точек и конечное значение yn.]],
[".TOL=0.001"]             = [[Точность решения.]],
},
---------- polynomial.lua ----------
polynomial = {
[":char(M) --> P"]         = [[Возвращает характеристический полином матрицы.]],
["P:int(x0_d=0) --> int_P"] = [[Первообразная полинома, x0 - свободный коэффициент.]],
[":spline(xs_t, ys_t) --> Ps_t"] = [[Интерполяция данных кубическими сплайнами. Возвращает таблицу полиномов.]],
["P:copy() --> cpy_P"]     = [[Возвращает копию полинома.]],
[":lagrange(xs_t, ys_t) --> P"] = [[Интерполяция данных полиномом Лагранжа.]],
[":taylor(x_d, fx_d, [fx'_d, fx''_d,..]) --> P"] = [[Формирует полином Тейлора в окрестности заданной точки.]],
[":fit(xs_t, ys_t, order_N) --> P"] = [[Аппроксимация точек полиномом заданной степени.]],
["P:der() --> der_P"]      = [[Первая производная полинома.]],
["__module__"]             = [[Действия над полиномами.]],
[":ppval(Ps_t, x_d, [index_N]) --> num"] = [[Вычисляет значение интерполяции из таблицы полиномов, можно использовать индекс полинома для ускорения расчёта.]],
["P:val(x) --> y"]         = [[Вычисляет значение полинома в заданной точке. Эквивалентно вызаву P(x).]],
["P:str(char_s='x') --> str"] = [[Более наглядное представление полинома.]],
[":build(roots_t) --> P"]  = [[Строит полином на основе списка корней.]],
[" {.., v1, v0} --> new_P"] = [[Создаёт полином на основе списка коэффициентов.]],
[":lin(xs_t, ys_t, yBefore_d=0, yAfter_d=y0) --> P"] = [[Линейная интерполяция. Возвращает таблицу полиномов.]],
["P:roots() --> roots_t"]  = [[Поиск действительных и комплексных корней полинома.]],
["P:real() --> roots_t"]   = [[Возвращает список действительных корней полинома.]],
[":x() --> P"]             = [[Возвращает объект для представления полинома в виде суммы k*x^n]],
},
---------- quaternion.lua ----------
quaternion = {
[":fromRPY(roll_d, pitch_d, yaw_d) --> Q"] = [[Построить кватернион по углам Эйлера.]],
["Q:conj() --> conj_Q"]    = [[Сопряжённый кватернион.]],
["Q:y() --> var"]          = [[Компонента y.]],
["Q:toAA() --> angle_d, axis_t|nil"] = [[Возвращает угол поворота и ось вращения.]],
["Q:inv() --> inv_Q"]      = [[Возвращает крватернион, обратный к данному.]],
[" {w, x, y, z} --> new_Q"] = [[Создаёт новый кватернион.]],
["Q:toRot() --> M"]        = [[Возвращает эквивалентную матрицу вращения.]],
["Q:abs() --> num"]        = [[Норма кватерниона.]],
["__module__"]             = [[Операции над кватернионами.]],
["Q:normalize() --> unit_Q"] = [[Возвращает единичный кватернион.]],
[":fromAA(angle_d, axis_d) --> Q"] = [[Возвращает кватернион для заданного угла и оси вращения.]],
["Q:w() --> var"]          = [[Действительная часть w.]],
["Q:rotate(inVec) --> outVec_t"] = [[Возвращает вектор, полученный при вращении с помощью заданного кватерниона.]],
[":fromRot(M) --> Q"]      = [[Строит кватернион на основе угла поворота и оси вращения.]],
["Q:z() --> var"]          = [[Компонента z.]],
["Q:x() --> var"]          = [[Компонента x.]],
["Q:matrix() --> M"]       = [[Представление в виде матрицы.]],
["Q:slerp(end_Q, rat_f) --> rat_Q"] = [[Сферическая линейная интерполяция двух кватернионов.]],
["Q:toRPY() --> roll_d, pitch_d, yaw_d"] = [[Преобразовать в крен-тангаж-рысканье.]],
},
---------- qubit.lua ----------
qubit = {
["G:Z([ind1,ind2,..]) --> upd_G"] = [[Добавить Z гейт.]],
["Q:prob(state_s) --> probatility_d"] = [[Вероятность заданного состояния.]],
[":gates(input_n) --> G"]  = [[Инициализация гейта для заданного числа кубитов.]],
["G:fromTable(truth_t) --> upd_G"] = [[Добавить гейт на основе таблицы истинности.]],
["G:Y([ind1,ind2,..]) --> upd_G"] = [[Добавить Y гейт.]],
["G:CNOT(slave_i, master_i) --> upd_G"] = [[Добавить CNOT гейт.]],
["G:isUnitary() --> bool"] = [[Проверка унитарности преобразования.]],
[":combine([Q1,Q2,..]) --> Q|nil"] = [[Объединить кубиты в систему. Эквивалентно Q1..Q2.]],
["Q:normalize()"]          = [[Нормализовать коэффициенты.]],
["G:X([ind1,ind2,..]) --> upd_G"] = [[Добавить гейт X.]],
["Q:copy() --> cpy_Q"]     = [[Возвращает копию объекта.]],
["__module__"]             = [[Симуляция квантовых расчётов.]],
["Q:matrix() --> M"]       = [[Эквивалентная матрица гейтов или вектор кубитов.]],
["G:S([ind1,ind2,..]) --> upd_G"] = [[Добавить S гейт.]],
["Q:meas([index]) --> Q"]  = [[Измерить всё состояние или заданный кубит. После измерения система остаётся в найденном состоянии.]],
["G:T([ind1,ind2,..]) --> upd_G"] = [[Добавить T гейт.]],
["G:H([i1,i2,..]) --> upd_G"] = [[Добавить гейт Адамара.]],
["G:SWAP(ind1, ind2) --> upd_G"] = [[Добавить гейт для обмена 2х кубитов.]],
["G:inverse() --> inv_G"]  = [[Возвращает обратное преобразование.]],
["G:fromMatrix(mat) --> upd_G"] = [[Добавить гейт на основе матрицы.]],
[" (t) --> Q"]             = [[Создать систему кубитов.]],
},
---------- random.lua ----------
random = {
[":int([lower_i=1], upper_i) -> int"] = [[Равномерное распределение целых чисел в заданном диапазоне.]],
[":flip(p=0.5) --> bool"]  = [[Случайное логическое значение.]],
[":seed(N=os.time)"]       = [[Установка начального значения генератора случайных чисел.]],
[":gamma(alpha_N, beta_d=1) --> float"] = [[Гамма распределение.]],
[":choice(tbl) --> element, index_N"] = [[Случайный элемент таблицы.]],
["__module__"]             = [[Генераторы случайных чисел.]],
[":rayleigh(sigma_d) --> float"] = [[Распределение Рэлея.]],
[":ipairs(tbl) --> fn"]    = [[Итерация по элементам таблицы в случайном порядке.]],
[":norm(mean_d=0, dev_d=1) --> float"] = [[Нормальное распределение.]],
[" () --> float"]          = [[Случайное число от 0 до 1.]],
[":binomial(p_d, N) --> int"] = [[Биномиальное распределение.]],
[":cauchy(mu_d=0, sigma_d=1) --> float"] = [[Распределение Коши.]],
[":logistic(mu_d=0, sigma_d=1) --> float"] = [[Логистическое распределение.]],
[":poisson(lambda_d) --> int"] = [[Распределение Пуассона.]],
[":exp(lambda_d=1) --> float"] = [[Экспоненциальное распределение.]],
[":shuffle(tbl)"]          = [[Случайное изменение порядка элементов таблицы.]],
[":bytes(N) --> str"]      = [[Случайная последовательность символов заданной длины.]],
[":new(seed_i=0) --> R"]   = [[Новый генератор равномерно распределённых случайных чисел.]],
},
---------- rational.lua ----------
rational = {
["__module__"]             = [[Операции с числами, представленными в виде дроби.]],
[":fromCF(coeff_t) --> R"] = [[Преобразование цепной дроби в рациональное число.]],
["R:denom() --> var"]      = [[Возвращает знаменатель.]],
[":from(src_f, err_f=1E-3) --> R"] = [[Оценка дроби рациональным числом с заданной точностью.]],
[" (num, denom=1) --> new_R"] = [[Для создания рационального числа укажите числитель и (опционально) знаменатель.]],
["R:float() --> num"]      = [[Представление рационального числа в десятичном виде.]],
["R:toCF() --> coeff_t"]   = [[Преобразование рационального числа в цепную дробь.]],
["R:eq(x) --> bool"]       = [[Проверка равенства двух чисел.]],
["R:num() --> var"]        = [[Возвращает числитель.]],
},
---------- special.lua ----------
special = {
[":erfc(x_d) --> num"]     = [[Дополнительная функция ошибки.]],
[":gammq(order_N, x_d) --> num"] = [[Неполная гамма-функция Q(N,x) = 1-P(N,x).]],
[":beta(z_d, w_d) --> num"] = [[Бета-функция.]],
[":gammaln(x_d) --> num"]  = [[Натуральный логарифм гамма-функции.]],
[":dawson(x_d) --> num"]   = [[Интеграл Доусона.]],
[":legendre(order_N, x_d) --> coeff_t"] = [[Список коэффициентов полиномов Лежандра.]],
[":betainc(x_d, a_d, b_d) --> num"] = [[Неполная бета-функция Ix(a,b).]],
[":gamma(x_d) --> num"]    = [[Гамма функция.]],
[":betaln(z_d, w_d) --> num"] = [[Натуральный логарифм бета-функции.]],
["__module__"]             = [[Специальные функции.]],
[":besselk(order_N, x_d) --> num"] = [[Модифицированная функция Бесселя Kn(x).]],
[":erf(x_d) --> num"]      = [[Функция ошибки.]],
[":gammp(order_N, x_d) --> num"] = [[Неполная гамма-функция P(N,x).]],
[":besselj(order_N, x_d) --> num"] = [[Функция Бесселя первого рода.]],
[":bessely(order_N, x_d) --> num"] = [[Функция Бесселя второго рода.]],
[":besseli(order_N,x_d) --> num"] = [[Модифицированная функция Бесселя In(x).]],
[":expint(pow_N, x_d) --> num"] = [[Экспоненциальный интеграл En(x).]],
},
---------- symbolic.lua ----------
symbolic = {
["__module__"]             = [[Символьные преобразования.]],
["S:eval(env_t={}) --> upd_S|num"] = [[Вычисляет выражение с заданным окружением.]],
["S:introspect() --> str"] = [[Отображает внутреннее представление выражения.]],
[":def(name_s, args_t, expr_S) --> fn_S"] = [[Создаёт символьную функцию. S либо символьное выражение, либо Lua функция.]],
[":fn(name_s) --> fn_S|nil"] = [[Возвращает символьную функцию с заданным именем или nil.]],
["S:diff(var_S) --> derivative_S"] = [[Возвращает символьную производную выражения.]],
[":parse(expr_s) --> S1, S2, .."] = [[Формирует символьное выражение из строки.]],
[" (num|str) --> new_S"]   = [[Символьная переменная или константа.]],
["S:isFn() --> bool"]      = [[Проверяет, является ли символ функцией.]],
},
---------- units.lua ----------
units = {
["__module__"]             = [[Операции с единицами измерения.]],
["U:copy() --> cpy_U"]     = [[Создание копии объекта с его единицами измерения.]],
["U:value() --> var"]      = [[Возвращает значение объекта. Эквивалентно #U.]],
[":setRule(name_s, val_U)"] = [[Добавление нового правила преобразования единиц измерения.]],
["U:convert(new_s) --> upd_U|nil"] = [[Преобразование единиц измерения, возвращает новый объект или nil.]],
[".prefix"]                = [[Таблица приставок.]],
[" (val=1, name_s) --> new_U"] = [[Создание числа с единицами измерения.]],
[":rules() --> str"]       = [[Печатает список заданных правил.]],
["U:key() --> str"]        = [[Возвращает единицы измерения.]],
},
}
