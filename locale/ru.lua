---------- locale/ru.lua ----------

return {
----------
language = 'Русский',
authors  = [[Станистав Михель]],
---------- dialog ----------
Dialog = {
["cmd_w"]                  = [[Направить вывод в терминал 'w'.]],
["cmd_shell"]              = [[Выполнить команду оболочки.]],
["cmd_rm"]                 = [[Очистить список блоков.]],
["cmd_help"]               = [[Показать эту справку.]],
["done"]                   = [[Выполнено.]],
["cmd_o"]                  = [[Открыть note-файл.]],
["cmd_q"]                  = [[Выйти.]],
["cmd_trace"]              = [[Профилирование функции.]],
["cmd_N"]                  = [[Выполнить блок N.]],
["cmd_log"]                = [[Включить/выключить запись лога.]],
["intro"]                  = [[-------- help([функция]) = справка --------------
---------- use([модуль]) = импорт функций -------
----------------- quit() = выход ----------------
]],
["cmd_time"]               = [[Оценка времени работы функции.]],
["cmd_ls"]                 = [[Отобразить список блоков.]],
["cmd_clear"]              = [[Очистить список переменных.]],
["cmd_set"]                = [[Создать алиасы для методов модуля.]],
["cmd_show"]               = [[Отобразить следующий или заданный блок.]],
},
---------- asciiplot.lua ----------
asciiplot = {
["F:addPose(row_N, col_N, char_s='*')"] = [[Установка символа в указанную позицию.]],
["F:setZ(par_t)"]          = [[Настройки оси Z. Установить 'range' ({a,b}), 'view' ('min'/'mid'/'max'/false), 'log'-арифм (true/false), 'fix'-ировать диапазон (true/false), 'size'.]],
["F:plot(...)"]            = [[Построение графиков данных для аргументов типа 't', 't1,t1', 'fn,nm', 'fn1,fn2' и т.д.]],
["F:copy() --> cpy_F"]     = [[Возвращает копию объекта.]],
["F:addPoint(x_d, y_d, char_s='*')"] = [[Отметить точку с координатами (x,y) с помощью символа.]],
["Plot(...)"]              = [[Построение графиков данных для аргументов типа 't', 't1,t1', 'fn,nm', 'fn1,fn2' и т.д.]],
["F:setY(par_t)"]          = [[Настройки оси Y. Установить 'range' ({a,b}), 'view' ('min'/'mid'/'max'/false), 'log'-арифм (true/false), 'fix'-ировать диапазон (true/false), 'size'.]],
["F:tplot(data_t, cols_t={x=1, polar=false})"] = [[Построение графика на основе таблицы, можно указать номера столбцов и дополнительные опции.]],
["F:legend(str_t)"]        = [[Настроить подписи.]],
["F:scale(factor_d | src_F)"] = [[Изменить размер графика относительно начальных размеров.]],
["F:contour(fn, {level=5, view='XY'}) --> nil|str"] = [[Проекция контуров функции fn(x,y). Проекции: XY, XZ, YZ, concat.]],
["__module__"]             = [[Визуализация данных с помощью псевдо-графики.]],
["F:setX(par_t)"]          = [[Настройки оси X. Установить 'range' ({a,b}), 'view' ('min'/'mid'/'max'/false), 'log'-арифм (true/false), 'fix'-ировать диапазон (true/false), 'size'.]],
["F:title(str)"]           = [[Установить название графика.]],
[" (width_N=73, height_N=21) --> new_F"] = [[Новый график.]],
["F:axes() --> tbl"]       = [[Получить информацию по каждой оси в виде таблицы {'size','log','range','view','fix'}.]],
["F:bar(t, y_N=2, x_N=1)"] = [[Столбчатая диаграмма.]],
[":concat(F1, F2) --> str"] = [[Горизонтальное объединение графиков равного размера. Эквивалентно '..' .]],
["F:addString(row_N, col_N, str)"] = [[Добавление строки в указанную позицию.]],
["F:reset()"]              = [[Очистка холста.]],
},
---------- bigint.lua ----------
bigint = {
["B:FF() --> B!!"]         = [[Возвращает двойной факториал.]],
[":C(n, k, isRepeat=false) --> combinations_B"] = [[Возвращает число компинаций из n по k, с повторениями и без.]],
["B:random() --> rand_B"]  = [[Псевдо-случайное число от 0 до B.]],
[" (num|str|tbl) --> new_B"] = [[Создаёт большое целое число на основе числа, строки или таблицы.]],
[":lcm(...) --> B"]        = [[Наименьшее общее кратное.]],
["B:float() --> num"]      = [[Представление в виде числа с плавающей точкой.]],
["__module__"]             = [[Вычисления с целыми числами произвольной длины.]],
[":gcd(...) --> B"]        = [[Наибольший общий делитель.]],
[":ratF(num_B, denom_B) --> num!/denom!"] = [[Вычисляет отношение факториалов num!/denom!.]],
["B:abs() --> abs_B"]      = [[Возвращает модуль числа.]],
["B:F() --> B!"]           = [[Возвращает факториал положительного числа.]],
["B:subF() --> !B"]        = [[Возвращает субфакториал.]],
["B:sign() --> int"]       = [[Возвращает +1/-1.]],
["B:isPrime(method_s=nil) --> bool"] = [[Проверка числа на простоту. Установите метод 'Fermat' для использования малой теоремы Ферма.]],
["B:digits(N=10) --> tbl"] = [[Возвращает цифры числа для заданной системы счисления.]],
["B:factorize() --> prime_t"] = [[Возвращает список простых множителей для данного числа.]],
[":P(n, k, isRepeat=false) --> permutaions_B"] = [[Возвращает число перестановок без повторов.]],
},
---------- complex.lua ----------
complex = {
["C:sinh() --> y_C"]       = [[Комплексный гиперболический синус.]],
["C:log() --> y_C"]        = [[Комплексный логарифм.]],
["C:atan() --> y_C"]       = [[Комплексный обратный тангенс.]],
["C:abs() --> float"]      = [[Модуль комплексного числа.]],
["C:cosh() --> y_C"]       = [[Комплексный гиперболический косинус.]],
["C:sin() --> y_C"]        = [[Комплексный синус.]],
["C:acos() --> y_C"]       = [[Комплексный обратный косинус.]],
[":i(x=1) --> new_C"]      = [[Возвращает комплексное число x*i.]],
["C:exp() --> y_C"]        = [[Комплексная экспонента.]],
[" (re=0, im=0) --> new_C"] = [[Создать новое комплексное число.]],
["C:cos() --> y_C"]        = [[Комплексный обратный косинус.]],
["C:atanh() --> y_C"]      = [[Комплексный обратный гиперболический тангенс.]],
[":E(phy) --> cos(phy)+i*sin(phy)"] = [[Комплексное число вида exp(i*phy).]],
["C:tanh() --> y_C"]       = [[Комплексный гиперболический тангенс.]],
["__module__"]             = [[Вычисления с комплексными числами.]],
["C:arg() --> float"]      = [[Возвращает агрумент комплексного числа.]],
["C:conj() --> conj_C"]    = [[Комплексно-сопряженное число. Эквивалентно ~C.]],
["C:tan() --> y_C"]        = [[Комплексный обратный тангенс.]],
["C:asinh() --> y_C"]      = [[Комплексный обратный гиперболический синус.]],
["C:asin() --> y_C"]       = [[Комплексный обратный синус.]],
["C:sqrt() --> y_C"]       = [[Комплексный квадратный корень.]],
["C:re() --> var"]         = [[Действительная часть.]],
["C:im() --> var"]         = [[Мнимая часть.]],
["C:acosh() --> y_C"]      = [[Комплексный обратный гиперболический косинус.]],
},
---------- const.lua ----------
const = {
[".phy.e --> 1.6E-19"]     = [[Заряд электрона.]],
[".phy.sigma --> 5.6E-8"]  = [[Постоянная Стефана-Больцмана.]],
[".phy.NA --> 6E23"]       = [[Число Авогадро.]],
[".math.phi --> 1.62"]     = [[Золотое сечение.]],
[".math.gamma --> 0.577"]  = [[Постоянная Эйлера-Маскерони.]],
[".astro.pc --> 3.1E16"]   = [[Один парсек.]],
[".astro.ly --> 9.5E15"]   = [[Световой год.]],
[".phy.Rinf --> 1.1E7"]    = [[Постоянная Ридберга.]],
[".phy.Vm --> 2.2E-2"]     = [[Объём моля идеального газа.]],
[".phy.g --> 9.81"]        = [[Ускорение свободного падения.]],
[".astro.k --> 0.017"]     = [[Гравитационная постоянная Гаусса.]],
[".astro.au --> 1.5E11"]   = [[Астрономическая единица.]],
[":add(name_s, value, units_s=nil)"] = [[Добавление временной константы.]],
[".phy.G --> 6.7E-11"]     = [[Гравитационная постоянная.]],
["__module__"]             = [[Разнообразные константы.]],
[".phy.k --> 1.4E-23"]     = [[Постоянная Больцмана.]],
[":remove(name_s) --> bool"] = [[Удаление константы.]],
[".math.e --> 2.72"]       = [[Основание натурального логарифма.]],
[".phy.h --> 6.6E-34"]     = [[Постоянная Планка.]],
[".phy.c --> 3E8"]         = [[Скорость света.]],
[".phi.Da --> 1.7E-27"]    = [[Атомная единица массы.]],
[".phy.mu0 --> 1.2E-6"]    = [[Магнитная постоянная.]],
[".phy.R --> 8.31"]        = [[Универсальная газовая постоянная.]],
[".phy.eps0 --> 8.8E-12"]  = [[Электрическая постоянная.]],
},
---------- data.lua ----------
data = {
[":range(begin_d, end_d, step_d=±1) --> new_R"] = [[Генерация диапазона чисел.]],
[":reduce(fn|str, data_t, initial=datadata_t[1]_t[1]) --> var"] = [[Итеративное применение функции к элементам списка и предыдущему результату.]],
[":zip(fn|str, ...) --> tbl"] = [[Последовательно применяет функцию к списку векторов.]],
[":harmmean(data_t, weigh_t=nil) --> num"] = [[Гармоническое среднее.]],
[":csvwrite(file_s, data_t, delim_s=',')"] = [[Сохраняет таблицу в файл с заданным разделителем.]],
[":sum(data_t) --> var"]   = [[Возвращает сумму элементов.]],
[":T(src_t) --> new_T"]    = [[Возвращает указатель на 'транспонированную' таблицу.]],
[":moment(order_N, data_t, weigth_t=nil) --> num"] = [[Центральный момент порядка N (с заданными весами).]],
[":ref(src_t, begin_N=1, end_N=#src_t) --> new_R"] = [[Возвращает "ссылку" на таблицу элементов.]],
[":histcounts(data_t, edges_t|N=10) --> sum_t, edges_t"] = [[Распределение данных по интервалам. Можно указать число интервалов разбиения, либо задать границы в виде таблицы.]],
[":geomean(data_t, weigh_t=nil) --> num"] = [[Геометрическое среднее.]],
[":median(data_t) --> num"] = [[Возвращает медиану распределения.]],
[":copy(t) --> copy_t"]    = [[Глубокое копирование списка.]],
[":is(data_t, fn|str) --> weigh_t"] = [[Возвращает массив весов на основе булевой функции или строки.]],
[":filter(in_t, fn|str|tbl) --> out_t"] = [[Фильтрует список данных. Условием является булева функция, строка или массив весов.]],
[":md(data_t, names_t=nil, row_fn=nil) --> str"] = [[Печать таблицы в стиле Markdown. Строки могут быть обработаны функцией row_fn(t)-->t.]],
[":mean(data_t, wight_t=nil) --> num"] = [[Вычисляет среднее значение.]],
[":min(data_t) --> var, ind_N"] = [[Возвращает наименьший элемент и его индекс.]],
["__module__"]             = [[Обработка данных и статистические расчёты.]],
[":isNot(data_t, fn|str) --> weigh_t"] = [[Возвращает инвертированные веса для булевой функции.]],
[":freq(data_t) --> tbl"]  = [[Возвращает таблицу частот элементов.]],
[":cov(data_t) --> cov_M"] = [[Возвращает матрицу ковариации для списка векторов.]],
[":csvread(file_s, delim_s=',') --> tbl"] = [[Формирует таблицу на основе файла с заданным разделителем.]],
[":cov2(xs_t, ys_t) --> float"] = [[Вычисляет ковариацию для двух списков.]],
[":std(data_t, weight_t=nil) --> num"] = [[Возвращает стандартное отклонение и дисперсию.]],
[":max(data_t) --> var, ind_N"] = [[Максимальный элемент и его индекс.]],
[":Fn(expr_s, arg_N=2) --> fn"] = [[Генерирует функцию из строки с параметрами x1, x2 и т.д.]],
},
---------- extremum.lua ----------
extremum = {
[":annealing(energy_fn, update_fn, x_M, temp_d=enerty0, alpha_d=0.9, nmax_N=1) -> x_M, energy_d"] = [[Оптимизация методом отжига.]],
[":maximum(fn, p_M, param={method='Powel',dfun=nil}) -> x_M, min_d"] = [[Поиск максимума для функции от вектора. Параметры: method=Powel|simplex, dfun - градиент. Для симплекса p это матрица.]],
[":maximum1D(fn, a_d, c_d, param={method='golden',b=millde,dfun=nil}) -> x_d, min_d"] = [[Поиск максимума для скалярной функции. Параметры: method=Brent|nil, b - начальная точка, dfun - производная (для метода Брента).]],
["__module__"]             = [[Поиск экстремумов и методы оптимизации.]],
[":minimum(fn, p_M, param={method='Powel',dfun=nil}) -> x_M, min_d"] = [[Поиск минимума для функции от вектора. Параметры: method=Powel|simplex, dfun - градиент. Для симплекса p это матрица.]],
[":minimum1D(fn, a_d, c_d, param={method='golden',b=middle,dfun=nil}) -> x_d, min_d"] = [[Поиск минимума для скалярной функции. Параметры: method=Brent|nil, b - начальная точка, dfun - производная (для метода Брента).]],
[":linprog(c_M, param={Au=nil,bu=nil,Ae=nil,be=nil,Al=nil,bl=nil}) -> x_M, min_d"] = [[Поиск решения задачи линейного программирования c*x -> min для условий Au*x <= bu, Ae*x == be, Al*x >= bl.]],
},
---------- geodesy.lua ----------
geodesy = {
["E:toXYZ(blh_t) --> xyz_t"] = [[Преобразует геодезические координаты в геоцентрические.]],
[":dms2deg(deg_d, min_d=0, sec_d=0) --> deg"] = [[Преобразует градусы, минуты, секунды в десятичные градусы.]],
[" (param_t=nil) --> E"]   = [[Новый эллипсоид с заданными параметрами {'a', 'f'}.]],
["E:into(E2, lin, rot, m)"] = [[Задать правила преобразования эллипсоидов.]],
["__module__"]             = [[Преобразования координат и другие геодезические задачи.]],
[":hashDecode(hash_s) --> coord_t, range_t"] = [[Определения положения зоны по геохэшу.]],
["E:toBLH(xyz_t) --> blh_t"] = [[Приобразовать геоцентрические координаты в геодезические.]],
["E:bl2utm(blh_t) --> utm_t"] = [[Найти UTM проекцию для заданных координат.]],
[":grav(latitude_d) --> acceleration"] = [[Международная формула гравитации, аргумент в градусах.]],
["E.xyzInto[E2] --> fn"]   = [[Возвращает функцию для преобразования геоцентрических координат из системы E в E2.]],
["E:solveDir(blh_t, az1_d, dist_d) --> blh_t, az2_d"] = [[Решение прямой задачи геодезии, поиск положения и азимута второй точки при заданных начальной точке, направлении и расстоянии.]],
["E:solveInv(blh1_t, blh2_t) --> dist_d, az1_d, az2_d"] = [[Решение обратной задачи геодеции, поиск расстояния и азимутов для двух заданных точек.]],
[":deg2dms(deg_d) --> deg, min, sec"] = [[Возвращает градусы, минуты и секунды для заданного угла в градусах.]],
["E:utm2bl(utm_t) --> blh_t"] = [[Найти геодезические координаты для заданной UTM позиции и зоны.]],
["E.blhInto[E2] --> fn"]   = [[Возвращает функцию для преобразования геодезических координат из E в E2 с помощью метода Молоденского.]],
[":hashEncode(coord_t, letter_N=6) --> hash_s"] = [[Вычисления геохэша для точки.]],
},
---------- gnuplot.lua ----------
gnuplot = {
[":tpolar(var, [x_N, y1_N, y2_N,..])"] = [[График в полярных координатах для таблицы, матрицы или файла. Опциональные элементы определяют стоблцы.]],
[":tplot(var, [x_N, y1_N, y2_N,..])"] = [[Построение графика на основе таблицы, матрицы или файла. Опциональные элементы определяют необходимые столбцы.]],
["__module__"]             = [[Интерфейс для взаимодействия с Gnuplot.]],
[":tsurf(var, [x_N, y_N, z1_N, z2_N,..])"] = [[Построение графика поверхности на основе таблицы, матрицы или файла. Опциональные элементы определяют необходимые столбцы.]],
[":surfplot(x1_t, y1_t, fn1, [nm_s, x2_t, y2_t,..])"] = [[Построение поверхности. 'x' и 'y' - списки чисел, 'fn' - функция двух агрументов, 'nm' - имя поверхности.]],
["G:show()"]               = [[Строит график на основе параметров, представленных в виде таблицы Lua.]],
["G:copy() --> cpy_G"]     = [[Возвращает копию параметров графика.]],
["G:add(curve_v)"]         = [[Добавить функцию для построения.]],
[":polarplot(x1_t, y1_t, [nm_s, x2_t, y2_t,..])"] = [[График в полярных координатах. 'x' - список чисел, 'y' - список либо функция, 'nm' - имя кривой.]],
[".keys"]                  = [[  Описание параметров:
{math.sin, title='sin'}                      -- строит график для Lua функции, добавляет текст в легенду
{'sin.dat', ln=1, lw=2}                      -- строит график для файла с учётом цвета и толщины маркеров
{tbl, with='lines'}                          -- строит график для Lua таблицы с помощью линий
title='Graph name'                           -- имя графика в целом
xrange={0,10}                                -- диапазон x от 0 до 10
yrange={-2,2}                                -- диапазон y
zrange={0,5}                                 -- диапазон z
trange={1,2}                                 -- изменение параметра в случае параметрической функции
xtitle='A', ytitle='B'                       -- имена осей
terminal='jpeg'                              -- сохранение результата в файл
output='my_plot.jpg'                         -- имя файла для вывода результата
parametric=true                              -- параметрическое представление функции
size='square'                                -- установить квадратный размер изображения
polar=true                                   -- график в полярных координатах
grid='polar'                                 -- изменить тип сетки на полярный
legend=false                                 -- отключить легенду
surface=true                                 -- построение трёхмерного графика
samples=200                                  -- задать число точек на графике
raw='set pm3d'                               -- позволяет написать команды Gnuplot в явном виде
]],
[" () --> new_G"]          = [[Подготовка таблицы для Gnuplot.]],
[":plot(x1_t, [y1_t, nm_s, x2_t,..])"] = [[График в полярных координатах. 'x' - список чисел, 'y' - список либо функция, 'nm' - имя кривой.]],
},
---------- graph.lua ----------
graph = {
["G:size() --> nodes_N"]   = [[Число узлов графа. Эквивалентно #G.]],
["G:matrix() --> adjacency_M, nodes_t"] = [[Матрица сопряжения и список узлов.]],
["G:has(node) --> bool"]   = [[Проверка принадлежности узла графу.]],
["G:nodes() --> node_t"]   = [[Возвращает список узвло графа.]],
["G:edge(pair_t) --> weight_d|nil"] = [[Возвращает вес ребра.]],
["G:addNodes(list_t)"]     = [[Импортирует узлы из списка.]],
["G:nin(node) --> nodes_t"] = [[Список узлов на входе.]],
["G:copy() --> cpy_G"]     = [[Создаёт копию графа.]],
["G:edges() --> edges_t"]  = [[Возвращает список рёбер.]],
["G:components() --> G_t"] = [[Список компонентов графа.]],
["G:isComplete() --> bool"] = [[True если граф полный.]],
["G:rand(edge_N)"]         = [[Заполнить граф случайными ребрами.]],
["G:dot(fname_s=nil) --> str"] = [[Возвращает описание структуры в dot формате.]],
["G:toSvg(name_s)"]        = [[Сохраняет граф в SVG изображене с помощью Graphviz.]],
[":concat(G_t) --> new_G"] = [[Объединить несколько графов в один объект.]],
["G:addEdges(list_t)"]     = [[Импортирует рёбра и веса из списка.]],
["G:isConnected() --> bool"] = [[True если граф связанный.]],
["__module__"]             = [[Операции с графами.]],
["G:isTree() --> bool"]    = [[True если это дерево.]],
[" (params_t={}) --> new_G"] = [[Создать граф, используюя параметры {dir=флаг, O|K|C|P=число|names_t, name='n'}.]],
["G:isWeighted() --> bool"] = [[True если граф взвешенный.]],
["G:isDirected() --> bool"] = [[True если граф направленный.]],
["G:remove(n1, n2=nil)"]   = [[Удаляет узел или ребро.]],
["G:randp(probability_d)"] = [[Заполнить рёбрами с заданной вероятностью.]],
["G:nout(node) --> nodes_t"] = [[Список узлов на выходе.]],
["G:search(node1, node2, method_s) --> path_t|nil"] = [[Поиск пути между двумя узлами. Методы: bfs, dfs, dijkstra.]],
["G:isEuler() --> bool"]   = [[True если содержит цикл Эйлера.]],
["G:add(n1, n2=nil, w_d=1)"] = [[Добавляет узел (одиночное имя) или ребро.]],
},
---------- lens.lua ----------
lens = {
["L:copy() --> cpy_L"]     = [[Возвращает копию объекта.]],
[":T(dist_d, n_d=1) --> L"] = [[Матрица перемещения для заданного расстояния и показателя преломления.]],
[":R(nin_d, rad_d, nout_d) --> L"] = [[Матрица преломления с учётом радиуса кривизны и показателей преломления на входе и выходе.]],
[":gSize(waist_d, lambda_d, dist_d) --> curv_d, rad_d"] = [[Размер пучка и радиус кривизны на расстоянии от перетяжки.]],
[":solve(fn, index_N, initial_d) --> found_d"] = [[Поиск условий, при которых компонент с заданным индексом равен 0, используется начальное предположение.]],
["L:cardinal(nLft_d=1, nRht_d=1) --> points_t"] = [[Поиск положения кардинальных точек системы относительно входных и выходных плоскостей, с учётом показателей преломления. Возвращает список расстояний.]],
["L:inv() --> inv_L"]      = [[Инвертированная матрица системы.]],
["L:emit(lambda_d) --> outCurv_d, outSize_d|nil, waist_d|nil, shift_d|nil "] = [[Поиск радиуса кривизны фронта на выходе резонатора. 
Для устойчивого резонатора также возвращает радиус пучка на выходе, а также размер и положение перетяжки.]],
["L:matrix() --> M"]       = [[Матрица оптической системы.]],
["L:transform(yIn_d, VIn_d) --> yOut_d, VOut_d"] = [[Определяет положение луча 'y' и оптический угол 'V' (= v*n) на выходе оптической системы. Эквивалентно вызову L(y,V).]],
[":afocal(magn_d) --> L"]  = [[Возвращает матрицу для афокальной системы.]],
[":M(rad_d, n_d=1) --> L"] = [[Матрица для отражающей поверхности заданного радиуса с учётом показателя преломления среды.]],
["__module__"]             = [[Матричные методы в параксиальной оптике.]],
[":thin(focal_d) --> L"]   = [[Возвращает матрицу для тонкой линзы при заданном фокальном расстоянии.]],
[":gParam(waist_d, lambda_d) --> div_d, range_d"] = [[Возвращает угол расходимости и размер ближней зоны гауссова луча.]],
[" (A_d, B_d, C_d, D_d) --> new_L"] = [[Новый объект с произвольными параметрами A, B, C, D.]],
["L:beam(inCurv_d, inSize_d, lambda_d) --> outCurv_d, outSize_d"] = [[Определение кривизны фронта и радиуса гаусова пуска на выходе из системы.]],
},
---------- main.lua ----------
main = {
["abs(x) --> y"]           = [[Абсолютная величина.]],
["atan(x) --> y"]          = [[Арктангенс x.]],
["PI --> 3.14"]            = [[Число пи.]],
["quit()"]                 = [[Выход из программы.]],
["hypot(...)"]             = [[Гипотенуза.]],
["Map(fn, in_t) --> out_t"] = [[Вычисляет функцию для всех элементов списка (таблицы), возвращает новый список.]],
["exp(x) --> y"]           = [[Экспонента.]],
["log(x) --> y"]           = [[Натуральный логарифм.]],
["asinh(x) --> y"]         = [[Гиперболический арксинус.]],
["use([module_s]) --> str|nil"] = [[Используйте use('модуль') или use{'модульA','модульB'} для подключения дополнительных модулей.]],
["help(fn='main') --> str"] = [[Описание модуля, функции или элемента.]],
["cosh(x) --> y"]          = [[Гиперболический косинус.]],
["Bind(obj, nm1, [nm2, ...]) --> fn"] = [[Обёртывание функций для вызова без объекта.]],
["sin(x) --> y"]           = [[Синус x.]],
["__module__"]             = [[Программа для математических расчётов на Lua.]],
["Round(v, decimal_N=0) --> round_v"] = [[Округление числа до заданного количества десятичных знаков или точности.]],
["acosh(x) --> y"]         = [[Гиперболический арккосинус.]],
["atanh(x) --> y"]         = [[Гиперболический арктангенс.]],
["atan2(y_d, x_d) --> num"] = [[Арктангенс y/x с учётом знака.]],
["tan(x) --> y"]           = [[Тангенс x.]],
["acos(x) --> y"]          = [[Арккосинус x.]],
["sqrt(x) --> y"]          = [[Квадратный корень.]],
["cos(x) --> y"]           = [[Косинус x.]],
["tanh(x) --> y"]          = [[Гиперболический тангенс.]],
["sinh(x) --> y"]          = [[Гиперболический синус.]],
["asin(x) --> y"]          = [[Арксинус x.]],
},
---------- matrix.lua ----------
matrix = {
[":hor(mat_t) --> mat_Ref"] = [[Горизонтальная конкатенация списка матриц.]],
["M:rref() --> upd_M"]     = [[Преобразование матрицы методом Гаусса.]],
["M:pinv() --> inv_M"]     = [[Вовзращает псевдо-обратную матрицу.]],
["M:exp() --> new_M"]      = [[Матричная экспонента.]],
["M:kron(M2) --> M⊗M2"]  = [[Произведение Кронеккера.]],
[":eye(row_N, col_N=row_N) --> M"] = [[Единичная матрица.]],
[":fill(row_N, col_N, val=1) --> M"] = [[Создать матрицу, заполненную заданной величиной.]],
["M:norm() --> num"]       = [[Евклидова норма.]],
[":D(list_v, shift_N=0) --> M"] = [[Матрица с заданными диагональными элементами.]],
["M:H() --> conj_Ref"]     = [[Сопряженная транспонированная матрица.]],
["M:cols() --> N"]         = [[Число столбцов.]],
["__module__"]             = [[Операции с матрицами. На нулевые элементы память не расходуется. Индексация с единицы.]],
["M:eig() --> vectors_M, values_M"] = [[Возвращает матрицы из собственных векторов и чисел.]],
["V:normalize()"]          = [[Нормализация вектора.]],
[":zeros(row_N, col_N=row_N) --> M"] = [[Формирует матрицу нулей.]],
["M:minor(row_N, col_N) --> minor_M"] = [[Возвращает минорную матрицу для заданного элемента.]],
["M:diag() --> V"]         = [[Извлекает диагональные элементы матрицы.]],
["M:rows() --> N"]         = [[Число строк.]],
["M:svd() --> U_M, S_M, V_M"] = [[Сингулярное разложение матрицы, возвращает U, S, V.]],
["M:lu() --> L_M, U_M, perm_M"] = [[LU преобразование матрицы. Возвращает L, U и P.]],
["M:table() --> tbl"]      = [[Преобразует матрицу в обыкновенную Lua таблицу.]],
["M:map(fn) --> found_M"]  = [[Формирует новую матрицу путём применения указанной функции к исходной. Функция может зависеть как от элементов f(x), так и от индексов f(x,row,col).]],
["M:det() --> num"]        = [[Определитель матрицы.]],
[" {row1_t, ...} --> new_M"] = [[Строит матрицу из списка строк.]],
[":zip(fn, ...) --> res_M"] = [[Поэлементно применяет функцию к матрицам для формирования новой матрицы.]],
[":V {...} --> mat_Ref"]   = [[Строит вектор из списка чисел.]],
["M:kronSum(M2) --> M⊕M2"] = [[Сумма Кронеккера.]],
["M:vec() --> vec_Ref|nil"] = [[Создаёт вектор.]],
[":ver(mat_t} --> mat_Ref"] = [[Вертикальная конкатенация списка матриц.]],
["M:inv() --> inv_M"]      = [[Обратная матрица.]],
["M:vectorize() --> V"]    = [[Преобразование в вектор по столбцам.]],
["M:copy() --> cpy_M"]     = [[Возвращает копию матрицы.]],
["V:dot(V2) --> num"]      = [[Скалярное произведение векторов.]],
["M:stars(cond_fn) --> str"] = [[Печатает элементы звёздочками когда условие истинно.]],
["M:tr() --> sum"]         = [[След матрицы.]],
["M:qr() --> Q_M, R_M"]    = [[QR разложение матрицы. Возвращает Q и R.]],
["M:T() --> transpose_Ref"] = [[Транспонирование матрицы.]],
["M:rank() --> N"]         = [[Возвращает ранг матрицы.]],
["V:cross(V2) --> M"]      = [[Векторное произведение 3-элементных векторов.]],
["M:reshape(row_N=(rows*cols), col_N=1) --> mat_Ref"] = [[Изменить размер матрицы.]],
["M:chol() --> lower_M|nil"] = [[Преобразование Холески для положительно определённой симметричной матрицы.]],
["V:outer(V2) --> M"]      = [[Внешнее произведение векторов.]],
},
---------- numeric.lua ----------
numeric = {
[":ode(fn, interval_t, y0, {dt=del/20,exit=nil}) --> ys_t"] = [[Численное решение ОДУ.
Списко параметров опциональный, может включать шаг по времени и условие завершения.
Возвращает список найденных точек в форме {t, x(t)}.]],
[":int(fn, x1_d, x2_d) --> num"] = [[Определённый интеграл. Допустимы бесконечные пределы.]],
[":der(fn, x_d) --> num"]  = [[Оценка производной функции в точке.]],
["ys:flat() --> ys"]       = [[Преобразовать вектор в список чисел для каждой строки результата ОДУ.]],
["__module__"]             = [[Функции для численных расчётов. Все функции работают с точностью, определяемой параметром TOL.]],
[":solve(fn, low_d, up_d) --> num"] = [[Поиск корня уравнения fn(x)=0 на интервале [a,b].]],
[":lim(fn, xn_d, isPositive=false) --> y"] = [[Оценка предела функции.]],
[":newton(fn, x0_d) --> num"] = [[Поиск корня методом Ньютона в окрестностях заданной точки.]],
},
---------- polynomial.lua ----------
polynomial = {
["P:copy() --> cpy_P"]     = [[Возвращает копию полинома.]],
["P:int(x0_d=0) --> int_P"] = [[Первообразная полинома, x0 - свободный коэффициент.]],
["P:der() --> der_P"]      = [[Первая производная полинома.]],
[":lagrange(xs_t, ys_t) --> P"] = [[Интерполяция данных полиномом Лагранжа.]],
[":spline(xs_t, ys_t) --> Ps_t"] = [[Интерполяция данных кубическими сплайнами. Возвращает таблицу полиномов.]],
["P:val(x) --> y"]         = [[Вычисляет значение полинома в заданной точке. Эквивалентно вызаву P(x).]],
["P:str(char_s='x') --> str"] = [[Более наглядное представление полинома.]],
[" {.., v1, v0} --> new_P"] = [[Создаёт полином на основе списка коэффициентов.]],
["__module__"]             = [[Действия над полиномами.]],
[":lin(xs_t, ys_t, before_d=nil, after_d=before_d) --> Ps_t"] = [[Линейная интерполяция. Возвращает таблицу полиномов.]],
[":taylor(x_d, fx_d, [fx'_d, fx''_d,..]) --> P"] = [[Формирует полином Тейлора в окрестности заданной точки.]],
[":x() --> P"]             = [[Возвращает объект для представления полинома в виде суммы k*x^n]],
[":char(M) --> P"]         = [[Возвращает характеристический полином матрицы.]],
[":fit(xs_t, ys_t, order_N) --> P"] = [[Аппроксимация точек полиномом заданной степени.]],
[":R(roots_t) --> P"]      = [[Строит полином по списку корней.]],
["P:roots() --> roots_t"]  = [[Поиск действительных и комплексных корней полинома.]],
},
---------- quaternion.lua ----------
quaternion = {
[" {x, y, z, w} --> new_Q"] = [[Новый кватернион, w - действительная часть, остальные мнимые.]],
["Q:w() --> var"]          = [[Действительная часть w.]],
["Q:rotate(in_t|V) --> out_t"] = [[Возвращает вектор, полученный при вращении с помощью заданного кватерниона.]],
[":fromAA(angle_d, axis_t|V) --> Q"] = [[Возвращает кватернион для заданного угла и оси вращения.]],
["Q:slerp(end_Q, rat_f) --> rat_Q"] = [[Сферическая линейная интерполяция двух кватернионов.]],
["Q:abs() --> num"]        = [[Норма кватерниона.]],
["Q:inv() --> inv_Q"]      = [[Возвращает крватернион, обратный к данному.]],
["Q:exp() --> exp_Q"]      = [[Экспонента кватерниона.]],
["Q:z() --> var"]          = [[Компонента z.]],
["__module__"]             = [[Операции над кватернионами.]],
["Q:toRot() --> M"]        = [[Возвращает эквивалентную матрицу вращения.]],
["Q:log() --> log_Q"]      = [[Логарифм кватерниона.]],
["Q:y() --> var"]          = [[Компонента y.]],
["Q:x() --> var"]          = [[Компонента x.]],
["Q:toAA() --> angle_d, axis_t|nil"] = [[Возвращает угол поворота и ось вращения.]],
[":fromRPY(roll_d, pitch_d, yaw_d) --> Q"] = [[Построить кватернион по углам Эйлера.]],
["Q:toRPY() --> roll_d, pitch_d, yaw_d"] = [[Найти углы крен-тангаж-рысканье.]],
["Q:normalized() --> unit_Q"] = [[Возвращает единичный кватернион.]],
[":fromRot(M) --> Q"]      = [[Строит кватернион на основе угла поворота и оси вращения.]],
["Q:conj() --> conj_Q"]    = [[Сопряжённый кватернион.]],
},
---------- qubit.lua ----------
qubit = {
["G:SWAP(ind1, ind2) --> upd_G"] = [[Добавить гейт для обмена 2х кубитов.]],
["G:T([ind1, ind2 ...]) --> upd_G"] = [[Добавить T гейт.]],
["G:fromMatrix(M) --> upd_G"] = [[Добавить гейт на основе матрицы.]],
["G:inverse() --> inv_G"]  = [[Возвращает обратное преобразование.]],
["Q:matrix() --> M"]       = [[Эквивалентная матрица гейтов или вектор кубитов.]],
[" (state_s|num) --> Q"]   = [[Создать систему кубитов.]],
["Q:copy() --> cpy_Q"]     = [[Возвращает копию объекта.]],
["G:Z([ind1, ind2 ...]) --> upd_G"] = [[Добавить Z гейт.]],
["G:Y([ind1, ind2 ...]) --> upd_G"] = [[Добавить Y гейт.]],
[":fromVector(V) --> Q"]   = [[Создать систему на основе вектора состояний.]],
[":gates(input_n) --> G"]  = [[Инициализация гейта для заданного числа кубитов.]],
["G:isUnitary() --> bool"] = [[Проверка унитарности преобразования.]],
["G:S([ind1, ind2 ...]) --> upd_G"] = [[Добавить S гейт.]],
["__module__"]             = [[Симуляция квантовых расчётов.]],
["Q:normalize()"]          = [[Нормализовать коэффициенты.]],
["G:R(axis_s, angle, [ind1, ind2 ...] --> G"] = [[Гейт вращения для оси 'X', 'Y' или 'Z'.]],
["G:P(phase, [ind1, ind2 ...] --> G"] = [[Добавить гейт для сдвига фазы.]],
["G:X([ind1, ind2 ...]) --> upd_G"] = [[Добавить гейт X.]],
["G:fromTable(truth_t) --> upd_G"] = [[Добавить гейт на основе таблицы истинности.]],
["Q:prob(state_s) --> probatility_d"] = [[Вероятность заданного состояния.]],
[":combine([Q1, Q2, ...]) --> Q|nil"] = [[Объединить кубиты в систему. Эквивалентно Q1..Q2.]],
["G:H([ind1, ind2 ...]) --> upd_G"] = [[Добавить гейт Адамара.]],
["G:CNOT(slave_i, master_i) --> upd_G"] = [[Добавить CNOT гейт.]],
["Q:meas(index=nil) --> Q"] = [[Измерить всё состояние или заданный кубит. После измерения система остаётся в найденном состоянии.]],
},
---------- random.lua ----------
random = {
["R:shuffle(tbl)"]         = [[Перемешать элементы списка.]],
["R:int(lower_i=1, upper_i) -> int"] = [[Равномерное распределение целых чисел в заданном диапазоне.]],
["R:flip(p=0.5) --> bool"] = [[Случайное логическое значение.]],
["R:seed(N=os.time) --> R"] = [[Установка начального значения генератора случайных чисел.]],
["R:cauchy(mu_d=0, sigma_d=1) --> float"] = [[Распределение Коши.]],
["R:choice(tbl) --> element, index_N"] = [[Случайный элемент списка.]],
["R:poisson(lambda_d) --> int"] = [[Распределение Пуассона.]],
["R:exp(lambda_d=1) --> float"] = [[Экспоненциальное распределение.]],
["__module__"]             = [[Генераторы случайных чисел.]],
["R:rayleigh(sigma_d) --> float"] = [[Распределение Рэлея.]],
[" () --> float"]          = [[Случайное число от 0 до 1.]],
["R:ipairs(tbl) --> iterator_fn"] = [[Итерация по элементам списка в случайном порядке.]],
["R:norm(mean_d=0, dev_d=1) --> float"] = [[Нормальное распределение.]],
["R:gamma(alpha_N, beta_d=1) --> float"] = [[Гамма распределение.]],
["R:bytes(N) --> str"]     = [[Случайная последовательность символов заданной длины.]],
["R:logistic(mu_d=0, sigma_d=1) --> float"] = [[Логистическое распределение.]],
[":new() --> R"]           = [[Новый генератор равномерно распределённых случайных чисел.]],
["R:binomial(p_d, N) --> int"] = [[Биномиальное распределение.]],
["R:array(n1,[n2,..]) --> tbl"] = [[Многомерный массив случайных чисел.]],
},
---------- rational.lua ----------
rational = {
["R:float() --> num"]      = [[Представление рационального числа в десятичном виде.]],
["__module__"]             = [[Операции с числами, представленными в виде дроби.]],
["R:denom() --> var"]      = [[Возвращает знаменатель.]],
[":fromCF(coeff_t) --> R"] = [[Преобразование цепной дроби в рациональное число.]],
["R:num() --> var"]        = [[Возвращает числитель.]],
[":from(src_f, err_f=1E-3) --> R"] = [[Оценка дроби рациональным числом с заданной точностью.]],
[" (num, denom=1) --> new_R"] = [[Для создания рационального числа укажите числитель и (опционально) знаменатель.]],
["R:toCF() --> coeff_t"]   = [[Преобразование рационального числа в цепную дробь.]],
},
---------- special.lua ----------
special = {
[":gammq(order_N, x_d) --> num"] = [[Неполная гамма-функция Q(N,x) = 1-P(N,x).]],
[":gammp(order_N, x_d) --> num"] = [[Неполная гамма-функция P(N,x).]],
[":beta(z_d, w_d) --> num"] = [[Бета-функция.]],
[":besseli(order_N, x_d) --> num"] = [[Модифицированная функция Бесселя In(x).]],
[":bessely(order_N, x_d) --> num"] = [[Функция Бесселя второго рода.]],
[":gammaln(x_d) --> num"]  = [[Натуральный логарифм гамма-функции.]],
[":gamma(x_d) --> num"]    = [[Гамма функция.]],
[":dawson(x_d) --> num"]   = [[Интеграл Доусона.]],
[":expint(pow_N, x_d) --> num"] = [[Экспоненциальный интеграл En(x).]],
[":erf(x_d) --> num"]      = [[Функция ошибки.]],
[":besselk(order_N, x_d) --> num"] = [[Модифицированная функция Бесселя Kn(x).]],
[":betaln(z_d, w_d) --> num"] = [[Натуральный логарифм бета-функции.]],
[":besselj(order_N, x_d) --> num"] = [[Функция Бесселя первого рода.]],
[":erfc(x_d) --> num"]     = [[Дополнительная функция ошибки.]],
[":betainc(x_d, a_d, b_d) --> num"] = [[Неполная бета-функция Ix(a,b).]],
["__module__"]             = [[Специальные функции.]],
},
---------- symbolic.lua ----------
symbolic = {
["S:diff(var_S) --> derivative_S"] = [[Возвращает символьную производную выражения.]],
["__module__"]             = [[Символьные преобразования.]],
[" (num|str) --> new_S"]   = [[Символьная переменная или константа.]],
["S:expand() --> expanded_S"] = [[Раскрыть произведение многочленов.]],
[":def(name_s, args_t, expr_S) --> fn_S"] = [[Создаёт символьную функцию. S либо символьное выражение, либо Lua функция.]],
["S:ratNum() --> numerator_S"] = [[Знаменатель рационального выражения.]],
["S:ratDenom() --> denominator_S"] = [[Числитель рационального выражения.]],
[":parse(expr_s) --> S1, S2, .."] = [[Формирует символьное выражение из строки.]],
["S:struct() --> str"]     = [[Отобразить внутреннюю структуру.]],
["S:val() --> num"]        = [[Вычисляет выражение с заданным окружением.]],
["S:isFn() --> bool"]      = [[Проверяет, является ли символ функцией.]],
["S:eval(env_t={}) --> upd_S|num"] = [[Вычисляет выражение с заданным окружением.]],
},
---------- units.lua ----------
units = {
["U:u() --> str"]          = [[Единицы измерения.]],
["__module__"]             = [[Операции с единицами измерения.]],
["U:copy() --> cpy_U"]     = [[Создание копии объекта.]],
[" (val=1, name_s) --> new_U"] = [[Создание числа с единицами измерения.]],
[".prefix"]                = [[Таблица приставок.]],
["U:convert(new_s) --> upd_U|nil"] = [[Преобразование единиц измерения, возвращает новый объект или nil.]],
[".rules"]                 = [[Таблица с правилами преобразования.]],
},
}
