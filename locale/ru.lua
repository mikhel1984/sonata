return {
---------- locale/ru.lng ----------
language = 'Русский',
authors  = [[Станистав Михель]],
---------- dialog nil
Dialog = {
["use_import"]           = [[
Используйте
  use 'модуль' или use {'модульA','модульB' ...}
для подключения дополнительных модулей.
]],
["done"]                 = [[Выполнено.]],
["intro"]                = [[-------- help([функция]) = справка --------------
---------- use([модуль]) = импорт функций -------
----------------- quit() = выход ----------------
]],
},
---------- asciiplot.lua ----------
asciiplot = {
["__module__"]           = [[Визуализация данных с помощью псевдо-графики.]],
["F:bar(t, vy=2, x_N=1) --> F"]   = [[Столбчатая диаграмма. vy может быть индексом y в таблице t либо списком y-в.]],
[" (width_N=75, height_N=23) --> new_F"] = [[Новый график.]],
["F:plot(...) --> F"]            = [[Построение графиков данных для аргументов типа 't', 't1,t1', 'fn,nm', 'fn1,fn2' и т.д.]],
["F:addPose(row_N, col_N, char_s) --> F"]     = [[Установка символа в указанную позицию.]],
["F:reset() --> nil"]              = [[Очистка холста.]],
["F:copy() --> cpy_F"]               = [[Возвращает копию объекта.]],
["F:scale(factor_d, isDefault=false) --> F"] = [[Изменить размер графика относительно начальных размеров.]],
["F:addString(row_N, col_N, str) --> F"]   = [[Добавление строки в указанную позицию.]],
[":concat(...) --> str"]         = [[Горизонтальное объединение графиков равного размера. Для двух объектов можно использовать оператор '..' .]],
["F:addPoint(x_d, y_d, char_s) --> F"]    = [[Добавить точку с координатами (x,y) с помощью символа.]],
["F:tplot(data_t, {yfix=false}) --> F"] = [[Построение графика на основе таблицы, можно указать номера столбцов и дополнительные опции.]],
["F:contour(fn, {view='XY'}) --> F|str"] = [[Проекция контуров функции fn(x,y). Проекции: XY, XZ, YZ, XYZ.]],
},
---------- graph.lua ----------
graph = {
["__module__"]           = [[Операции с графами.]],
["G:bfs(startNode, goalNode) --> isFound, path_t"]    = [[Поиск в ширину. Возвращает флаг результата и найденный путь.]],
["G:pathD(startNode, [goalNode]) --> dist_d, path_t|prev_t"] = [[Поиск кратчайшего пути алгоритмом Дейкстры. Возвращает таблицу расстояний и узлов. Если задана цель, возвращает путь и его длину.]],
["G:isComplete() --> bool"]         = [[True если граф полный.]],
[" {v1, v2,..} --> new_G"]          = [[Создает новый граф.]],
["G:pathBF(startNode, [goalNode]) --> dist_d, path_t|prev_t"] = [[Поиск кратчайшего пути алгоритмом Беллмана-Форда. Возвращает таблицу расстояний и узлов. Если задана цель, возвращает путь и его длину.]],
["G:remove(var) --> nil"]            = [[Удаляет узел или ребро. Узлы представляются именем, рёбра - двухэлементным списком.]],
["G:edges() --> edges_t"]              = [[Возвращает список рёбер.]],
["G:nodes() --> node_t"]              = [[Возвращает список узвло графа.]],
["G:isNegative() --> bool"]         = [[True если граф содержит отрицательные веса.]],
["G:dfs(startNote, goalNode) --> isFound, path_t"]    = [[Поиск в глубину. Возвращает флаг результата и найденный путь.]],
["G:copy() --> cpy_G"]               = [[Создаёт копию графа.]],
["G:isWeighted() --> bool"]         = [[True если граф взвешенный.]],
["G:add(var) --> nil"]               = [[Добавляет узел (одиночное имя) или ребро. Ребро представлено списком, содержащим начало, конец и, при необходимости, вес (веса).]],
["G:isDirected() --> bool"]         = [[True если граф направленный.]],
},
---------- symbolic.lua ----------
symbolic = {
["__module__"]           = [[Символьные преобразования.]],
[":fn(name_s) --> fn_S|nil"]         = [[Возвращает символьную функцию с заданным именем или nil.]],
["S:eval(env_t={}) --> upd_S|num"]         = [[Вычисляет выражение с заданным окружением.]],
[":parse(expr_s) --> S1, S2, .."]          = [[Формирует символьное выражение из строки.]],
[" (var) --> new_S)"]                 = [[Символьная переменная или константа.]],
[":def(name_s, args_t, expr_S) --> fn_S"]  = [[Создаёт символьную функцию. S либо символьное выражение, либо Lua функция.]],
},
---------- numeric.lua ----------
numeric = {
["__module__"]           = [[Функции для численных расчётов. Все функции работают с точностью, определяемой параметром TOL.]],
[":trapez(fn, x1_d, x2_d) --> num"]      = [[Интегрирование методом трапеций.]],
[".TOL=0.001"]          = [[Точность решения.]],
[":der(fn, x_d) --> num"]           = [[Оценка производной функции в точке.]],
[":solve(fn, xLow_d, xUp_d) --> num"]     = [[Поиск корня уравнения fn(x)=0 на интервале [a,b].]],
[":ode45(fn, interval_t, y0, [{dt,exit}]) --> ys_t, yLast"] = [[Численное решение ОДУ.
Первый параметр задаёт уравнение, второй - временной интервал, третий - начальное значение функции. Дополнительно можно определить такие параметры как шаг интегрирования и условие прерывания.
Возвращает таблицу промежуточных точек и конечное значение yn.]],
[":newton(fn, x0_d) --> num"]       = [[Поиск корня методом Ньютона в окрестностях заданной точки.]],
},
---------- lens.lua ----------
lens = {
["__module__"]           = [[Матричные методы в параксиальной оптике.]],
[":mirror(rad_d, n_d) --> L"]       = [[Возвращает матрицу отражения на кривой поверхности с учётом показателя преломления.]],
[":thin(focalDist_d) --> L"]            = [[Возвращает матрицу для тонкой линзы при заданном фокальном расстоянии.]],
["L:det() --> determinant_d"]                = [[Возвращает определитель матрицы.]],
[":afocal(magn_d) --> L"]          = [[Возвращает матрицу для афокальной системы.]],
["L:cardinal(nLft_d=1, nRht_d=1) --> points_t"] = [[Поиск положения кардинальных точек системы относительно входных и выходных плоскостей, с учётом показателей преломления. Возвращает список расстояний.]],
[":solve(fn,index_N, initial_d) --> found_d"]    = [[Поиск условий, при которых компонент с заданным индексом равен 0. d0 - начальное предположение.]],
["L:transform(yIn_d, VIn_d) --> yOut_d, VOut_d"]     = [[Определяет положение луча 'dy' и оптический угол 'dV' (= v*n) на выходе оптической системы. Эквивалентно вызову L(dy,dV).]],
[":gaussSize(waist_d, lambda_d, dist_d) --> rad_d, curv_d"] = [[Определение радиуса и кривизны гаусова пучка на заданном расстоянии.]],
["L:beam(inRad_d, inCurv_d, lambda_d) --> outRad_d, outCurv_d"]     = [[Определение радиуса и кривизны фронта гаусова пуска на выходе из системы.]],
[" {A_d, B_d, C_d, D_d} --> new_L"]       = [[Новый объект с произвольными параметрами A, B, C, D.]],
[":ref(rad_d, n1_d, n2_d) --> L"]     = [[Возвращает матрицу для преломления с учётом показателей преломления и радиуса кривизны поверхности.]],
[":trans(dist_d, n_d) --> L"]        = [[Возвращает матрицу перемещения с учётом показателя преломления.]],
[":gaussParam(waist_d, lambda_d) --> div_d, range_d"] = [[Определение расходимости и размера ближней зоны пучка.]],
["L:isUnit() --> bool"]             = [[Проверка, является ли матрица единичной.]],
["L:copy() --> cpy_L"]               = [[Возвращает копию объекта.]],
["L:inv() --> inv_L"]                = [[Инвертированная матрица системы.]],
--["operations"]           = [[L1 == L2, L1 .. L2]],
},
---------- bigint.lua ----------
bigint = {
["__module__"]           = [[Вычисления с целыми числами произвольной длины.]],
["B:fact() --> B!"]               = [[Вычисляет факториал целого неотрицательного числа.]],
["B:base() --> int"]               = [[Возвращает основание системы счисления.]],
[" (var) --> new_B"]                 = [[Создаёт большое целое число на основе числа, строки или таблицы.]],
["B:factorize() --> primeBs_t"]          = [[Возвращает список простых множителей для данного числа.]],
[":random(B) --> rand_B"]           = [[Псевдо-случайное число от 0 до B.]],
["B:rebase(N) --> upd_B"]            = [[Конвертирует число в новую систему счисления.]],
["B:isPrime([method_s]) --> bool"]   = [[Проверка числа на простоту. Установите метод 'Fermat' для использования малой теоремы Ферма.]],
["B:gcd(B2) --> B3"]               = [[Наибольший общий делитель.]],
["B:float() --> num"]              = [[Представление в виде числа с плавающей точкой.]],
["B:eq(x) --> bool"]                = [[Проверка равенства двух чисел.]],
["B:abs() --> num"]                = [[Возвращает модуль числа.]],
["B:at(N) --> int"]                = [[Возвращает цифру в позиции N.]],
--["comparison"]           = [[a<b, a<=b, a>b, a>=b, a==b, a~=b]],
--["arithmetic"]           = [[a+b, a-b, a*b, a/b, a%b, a^b, -a, #a]],
},
---------- const.lua ----------
const = {
[".phi.Da"]               = [[Атомная единица массы.]],
["__module__"]           = [[Разнообразные константы.]],
[".phy.e"]                = [[Заряд электрона.]],
[".phy.sigma"]            = [[Постоянная Стефана-Больцмана.]],
[".phy.NA"]               = [[Число Авогадро.]],
[".math.phi"]             = [[Золотое сечение.]],
[".math.pi"]              = [[Отношение длины окружности к её диаметру.]],
[":remove(name_s) --> bool"]       = [[Удаление константы.]],
[":add(name_s, value, [units_s]) --> nil"] = [[Добавление временной константы.]],
[".phy.c"]                = [[Скорость света.]],
[".phy.Rinf"]             = [[Постоянная Ридберга.]],
[".phy.Vm"]               = [[Объём моля идеального газа.]],
[".phy.g"]                = [[Ускорение свободного падения.]],
[".phy.G"]                = [[Гравитационная постоянная.]],
[".phy.k"]                = [[Постоянная Больцмана.]],
[".math.e"]               = [[Основание натурального логарифма.]],
[".astro.au"]             = [[Астрономическая единица.]],
[".phy.h"]                = [[Число планка.]],
[".astro.pc"]             = [[Один парсек.]],
[".phy.eps0"]             = [[Электрическая постоянная.]],
[".phy.mu0"]              = [[Магнитная постоянная.]],
[".phy.R"]                = [[Универсальная газовая постоянная.]],
[".astro.ly"]             = [[Световой год.]],
},
---------- special.lua ----------
special = {
["__module__"]           = [[Специальные функции.]],
[":besselk(order_N, x_d) --> num"]        = [[Модифицированная функция Бесселя Kn(x).]],
[":besseli(order_N, x_d) --> num"]        = [[Модифицированная функция Бесселя In(x).]],
[":erf(x_d) --> num"]              = [[Функция ошибки.]],
[":erfc(x_d) --> num"]             = [[Дополнительная функция ошибки.]],
[":gammp(order_N, x_d) --> num"]          = [[Неполная гамма-функция P(N,x).]],
[":beta(z_d, w_d) --> num"]           = [[Бета-функция.]],
[":gammainc(x_d, order_N, type_s='lower') --> num"] = [[Неполная гамма-функция, P (lower - нижняя) или Q (upper - верхняя).]],
[":dawson(x_d) --> num"]           = [[Интеграл Доусона.]],
[":gammq(order_N, x_d) --> num"]          = [[Неполная гамма-функция Q(N,x) = 1-P(N,x).]],
[":betainc(x_d, a_d, b_d) --> num"]      = [[Неполная бета-функция Ix(a,b).]],
[":gammaln(x_d) --> num"]          = [[Натуральный логарифм гамма-функции.]],
[":bessely(order_N, x_d) --> num"]        = [[Функция Бесселя второго рода.]],
[":legendre(order_N, x_d) --> coeff_t"]       = [[Список коэффициентов полиномов Лежандра.]],
[":betaln(z_d, w_d) --> num"]         = [[Натуральный логарифм бета-функции.]],
[":besselj(order_N, x_d) --> num"]        = [[Функция Бесселя первого рода.]],
[":gamma(x_d) --> num"]            = [[Гамма функция.]],
[":expint(pow_N, x_d) --> num"]         = [[Экспоненциальный интеграл En(x).]],
},
---------- quaternion.lua ----------
quaternion = {
["__module__"]           = [[Операции над кватернионами.]],
["Q:slerp(end_Q, rat_f) --> rat_Q"]           = [[Сферическая линейная интерполяция двух кватернионов.]],
["Q:re() --> var"]                 = [[Действительная часть (эквивалентно Q.w).]],
["Q:toAA() --> angle_d, axis_t"]               = [[Возвращает угол поворота и ось вращения.]],
["Q:conj() --> conj_Q"]               = [[Сопряжённый кватернион.]],
["Q:x() --> var"]                  = [[Компонента x.]],
["Q:toRot() --> M"]              = [[Возвращает эквивалентную матрицу вращения.]],
[":fromAA(angle_d, axis_d) --> Q"]   = [[Возвращает кватернион для заданного угла и оси вращения.]],
["Q:abs() --> num"]                = [[Норма кватерниона.]],
["Q:inv() --> inv_Q"]                = [[Возвращает крватернион, обратный к данному.]],
["Q:z() --> var"]                  = [[Компонента z.]],
[":fromRot(M) --> Q"]          = [[Строит кватернион на основе угла поворота и оси вращения.]],
["Q:mat() --> M"]                = [[Представление в виде эквивалентной матрицы.]],
[" {w, x, y, z}"]           = [[Новый кватернион.]],
["Q:rotate(inVec) --> outVec_t"]          = [[Возвращает вектор, полученный при вращении с помощью заданного кватерниона.]],
["Q:y() --> var"]                  = [[Компонента y.]],
["Q:w() --> var"]                  = [[Действительная часть w.]],
["Q:im() --> imaginary_t"]                 = [[Возвращает таблицу мнимых элементов кватерниона.]],
["Q:normalize() --> unit_Q"]          = [[Возвращает единичный кватернион.]],
--["comparison"]           = [[a == b, a ~= b]],
--["arithmetic"]           = [[a + b, a - b, a * b, a ^ k, -a]],
},
---------- rational.lua ----------
rational = {
["__module__"]           = [[Операции с числами, представленными в виде дроби.]],
["R:float() --> num"]              = [[Представление рационального числа в десятичном виде.]],
["R:num() --> var"]                = [[Возвращает числитель.]],
["R:eq(x) --> bool"]                = [[Проверка равенства двух чисел.]],
[":gcd(a_f, b_f) --> num"]          = [[Наибольший общий делитель.]],
[" (num, denom=1) --> new_R"]           = [[Для создания рационального числа укажите числитель и (опционально) знаменатель.]],
[":fromCont(coeff_t) --> R"]         = [[Преобразование цепной дроби в рациональное число.]],
["R:toCont() --> coeff_t"]             = [[Преобразование рационального числа в цепную дробь.]],
[":from(src_f, err_f=1E-3) --> R"] = [[Оценка дроби рациональным числом с заданной точностью.]],
["R:denom() --> var"]              = [[Возвращает знаменатель.]],
--["comparison"]           = [[R1<R2, R1<=R2, R1>R2, R1>=R2, R1==R2, R1~=R2]],
--["arithmetic"]           = [[R1+R2, R1-R2, R1*R2, R1/R2, -R, R1^R2]],
},
---------- geodesy.lua ----------
geodesy = {
["__module__"]           = [[Преобразования координат и другие геодезические задачи.]],
[":fromENU(blRef_t, xyzRef_t, top_t) --> xyzObs_t"] = [[Преобразовать топоцентрические координаты точки в геоцентрические.]],
["E.xyzInto[E2]"]         = [[Возвращает функцию для преобразования геоцентрических координат из системы A в B.]],
["E:solveInv(blh1_t, blh2_t) --> dist_d, az1_d, az2_d"]  = [[Решение обратной задачи геодеции, поиск расстояния и азимутов для двух заданных точек.]],
["projGK(tBL)"]          = [[Вовзращает северное и восточное положение точки в проекции Гаусса-Крюгера.]],
[":grav(latitude_d) --> num"]            = [[Международная формула гравитации, аргумент в радианах.]],
["E.blhInto[E2]"]         = [[Возвращает функцию для преобразования геодезических координат из A в B с помощью метода Молоденского.]],
["E:toBLH(xyz_t) --> blh_t"]          = [[Приобразовать геоцентрические координаты в геодезические.]],
[":toENU(blRef_t, xyzRef_t, xyzObs_t) --> top_t"] = [[Преобразовать геоцентрические координаты точки в топоцентрические.]],
[":dms2rad(deg_d, min_d=0, sec_d=0) --> num"] = [[Преобразует градусы, минуты и секунды в радианы.]],
["E:solveDir(blh_t, az1_d, dist_d) --> blh_t, az2_d"] = [[Решение прямой задачи геодезии, поиск положения и азимута второй точки при заданных начальной точке, направлении и расстоянии.]],
[":hashEncode(coord_t, letter_N=6) --> hash_s"] = [[Вычисления геохэша для точки.]],
[":hashDecode(hash_s) --> coord_t, range_t"]   = [[Определения положения зоны по геохэшу.]],
["E:toXYZ(blh_t) --> xyz_t"]          = [[Преобразует геодезические координаты в геоцентрические.]],
["projM(tBL)"]           = [[Возвращает северное и восточное положение точки в проекции Меркатора.]],
[":deg2dms(deg_d) --> num"]          = [[Возвращает градусы, минуты и секунды для заданного угла в градусах.]],
},
---------- complex.lua ----------
complex = {
["__module__"]           = [[Вычисления с комплексными числами.]],
["Z:acosh() --> y_Z"]              = [[Комплексный обратный гиперболический косинус.]],
["Z:arg() --> float"]                = [[Возвращает агрумент комплексного числа.]],
["Z:cos() --> y_Z"]                = [[Комплексный косинус.]],
["Z:log() --> y_Z"]                = [[Комплексный логарифм.]],
["Z:sqrt() --> y_Z"]               = [[Комплексный квадратный корень.]],
[":i(x=1) --> new_Z"]            = [[Возвращает комплексное число v*i.]],
["Z:atanh() --> y_Z"]              = [[Комплексный обратный гиперболический тангенс.]],
["Z:asinh() --> y_Z"]              = [[Комплексный обратный гиперболический синус.]],
["Z:im() --> var"]                 = [[Мнимая часть.]],
["Z:asin() --> y_Z"]               = [[Комплексный обратный синус.]],
[" (re=0, im=0) --> new_Z"]     = [[Создание комплексного числа.]],
["Z:conj() --> conj_Z"]               = [[Комплексно-сопряженное число. Эквивалентно ~C.]],
[":trig(module, angle) --> new_Z"] = [[Создание комплексного числа по модули и агрументу.]],
["Z:tanh() --> y_Z"]               = [[Комплексный гиперболический тангенс.]],
["Z:tan() --> y_Z"]                = [[Комплексный тангенс.]],
["Z:sinh() --> y_Z"]               = [[Комплексный гиперболический синус.]],
["Z:sin() --> y_Z"]                = [[Комплексный синус.]],
["Z:round(N=6) --> rounded_Z"]         = [[Возвращает число с округлением до заданного количества знаков.]],
["Z:abs() --> float"]                = [[Модуль комплексного числа.]],
["Z:re() --> var"]                 = [[Действительная часть.]],
["Z:acos() --> y_Z"]               = [[Комплексный обратный косинус.]],
["Z:atan() --> y_Z"]               = [[Комплексный обратный тангенс.]],
["Z:exp() --> y_Z"]                = [[Комплексная экспонента.]],
["Z:cosh() --> y_Z"]               = [[Комплексный гиперболический косинус.]],
--["comparison"]           = [[a==b, a~=b]],
--["arithmetic"]           = [[a+b, a-b, a*b, a/b, a^b, -a]],
},
---------- main.lua ----------
main = {
["__module__"]           = [[Программа для математических расчётов на Lua.]],
["tanh(x) --> y"]              = [[Гиперболический тангенс.]],
["atanh(x) --> y"]             = [[Гиперболический арктангенс.]],
["cos(x) --> y"]               = [[Косинус x.]],
["_pi"]                  = [[Число pi.]],
["randn(mean_d=0, dev_d=1) --> float"] = [[Нормально распределённая случайная величина с заданным средним значением и дисперсией.]],
["Round(x_d, N=0) --> num"]       = [[Округление числа до заданного количества десятичных знаков.]],
["acos(x) --> y"]              = [[Арккосинус x.]],
["sqrt(x) --> y"]           = [[Квадратный корень.]],
["sinh(x) --> y"]              = [[Гиперболический синус.]],
["acosh(x) --> y"]             = [[Гиперболический арккосинус.]],
["_ans"]                 = [[Результат последней операции.]],
["Range(dBegin, dEnd, [dStep])"] = [[Генерация диапазона чисел.]],
["Print(...) --> nil"]           = [[Дополненная функция печати, показывает элементы таблицы, представляет числа в н "научно" виде.]],
["Run(name_s, isInt=false) --> nil"] = [[Выполнить lua- или note- файл. Установите флаг bInt для интерактивного выполнения.]],
["exp(x) --> y"]               = [[Экспонента.]],
["Type(x) --> str"]              = [[Печатает тип объекта, распознаёт типы, заданные в Sonata.]],
["Map(fn, inList_t) --> outList_t"]            = [[Вычисляет функцию для всех элементов списка (таблицы), возвращает новый список.]],
["atan2(y_d, x_d) --> num"]         = [[Арктангенс dy/dx с учётом знака.]],
["cosh(x) --> y"]              = [[Гиперболический косинус.]],
["asinh(x) --> y"]             = [[Гиперболический арксинус.]],
["asin(x) --> y"]              = [[Арксинус x.]],
["tan(x) --> y"]               = [[Тангенс x.]],
["rand() --> float"]               = [[Случайное число от 0 до 1.]],
["randi(N) -> int"]             = [[Случайное целое число от 1 до N.]],
["Log(sFlag)"]           = [[Сохранение сессии в файл лога. Используйте 'on'/'off' чтобы запустить/остановить процесс.]],
["sin(x) --> y"]               = [[Синус x.]],
["abs(x) --> num"]               = [[Абсолютная величина.]],
["_e"]                   = [[Число Эйлера.]],
["log(x) --> y"]            = [[Натуральный логарифм.]],
},
---------- array.lua ----------
array = {
["__module__"]           = [[Операции с массивами, т.е. многомерными упорядоченными последовательностями элементов. Индексы задаются в виде таблицы. Индексация с единицы.]],
["A:get(ind_t) --> var"]            = [[Возвращает значение заданного элемента.]],
["A:map(fn) --> out_A"]              = [[Формирует новый массив путём применения функции к элементам исходного.]],
["A:isEqual(A2) --> bool"]           = [[Сравнение размерностей массивов.]],
["A:capacity() --> int"]           = [[Возвращает максимальное число элементов в массиве. Эквивалентно #A.]],
[" {n1, n2,..} --> new_A"]          = [[Создаёт пустой массив заданного размера.]],
["A:concat(A2, axis_N) --> A3"]      = [[Формирует новый массив путём объединения двух исходных по заданной оси.]],
["A:copy() --> cpy_A"]               = [[Возвращает копию массива.]],
[":zip(fn, ...) --> A"]        = [[Применяет функцию к списку массивов для получения нового массива.]],
["A:ipairs() --> iter_fn"]             = [[Итератор, который при каждом вызове возвращает индекс и элемент множества.]],
["A:sub(ind1_t,ind2_t) --> range_A"]     = [[Возвращает массив, ограниченный двумя индексами.]],
["A:set(ind_t, var) --> nil"]          = [[Присваивание значения заданному элементу.]],
["A:dim() --> int"]                = [[Возвращает размерность массива.]],
--["comparison"]           = [[a == b, a ~= b]],
},
---------- units.lua ----------
units = {
["__module__"]           = [[Операции с единицами измерения.]],
["prefix"]               = [[Таблица дольных и кратных приставок.]],
["U:value() --> var"]              = [[Возвращает значение объекта. Эквивалентно #U.]],
["U:convert(new_s) --> upd_U|nil"]           = [[Преобразование единиц измерения, возвращает новый объект или nil.]],
["U:key() --> str"]                = [[Возвращает единицы измерения.]],
[":setRule(name_s, val_U) --> nil"]        = [[Добавление нового правила преобразования единиц измерения.]],
[" (val=1, name_s) --> new_U"]             = [[Создание числа с единицами измерения.]],
["U:copy() --> cpy_U"]               = [[Создание копии объекта с его единицами измерения.]],
--["comparison"]           = [[U1==U2, U1~=U2, U1<U2, U1<=U2, U1>U2, U1>=U2]],
--["arithmetic"]           = [[U1+U2, U1-U2, U1*U2, U1/U2, U1^N]],
},
---------- gnuplot.lua ----------
gnuplot = {
["__module__"]           = [[Интерфейс для взаимодействия с Gnuplot.]],
[":tplot(var, [x_N, y1_N, y2_N,..]) --> nil"] = [[Построение графика на основе таблицы, матрицы или файла. Опциональные элементы определяют необходимые столбцы.]],
[":plot(x1_t, [y1_t, nm_s, x2_t,..]) --> nil"] = [['x' - список чисел, 'y' - список или функция, 'nm' - имя кривой.]],
[":surfplot(x1_t, y1_t, fn1, [nm_s, x2_t, y2_t,..]) --> nil"] = [[Построение поверхности. 'x' и 'y' - списки чисел, 'fn' - функция двух агрументов, 'nm' - имя поверхности.]],
["G:show() --> nil"]               = [[Строит график на основе параметров, представленных в виде таблицы Lua.]],
["G:copy() --> cpy_G"]               = [[Возвращает копию параметров графика.]],
["G:add(curve) --> nil"]          = [[Добавить функцию для построения.]],
[":polarplot(x1_t, y1_t, [nm_s, x2_t, y2_t,..]) --> nil"] = [[График в полярных координатах. 'x' - список чисел, 'y' - список либо функция, 'nm' - имя кривой.]],
["keys"]                 = [[  Описание параметров:
{math.sin, title='sin'}                      -- строит график для Lua функции, добавляет текст в легенду
{'sin.dat', ln=1, lw=2}                      -- строит график для файла с учётом цвета и толщины маркеров
{tbl, with='lines'}                          -- строит график для Lua таблицы с помощью линий
title='Graph name'                           -- имя графика в целом
xrange={0,10}                                -- диапазон x от 0 до 10
yrange={-2,2}                                -- диапазон y
zrange={0,5}                                 -- диапазон z
trange={1,2}                                 -- изменение параметра в случае параметрической функции
xtitle='A', ytitle='B'                       -- имена осей
terminal='jpeg'                              -- сохранение результата в файл
output='my_plot.jpg'                         -- имя файла для вывода результата
parametric=true                              -- параметрическое представление функции
size='square'                                -- установить квадратный размер изображения
polar=true                                   -- график в полярных координатах
grid='polar'                                 -- изменить тип сетки на полярный
legend=false                                 -- отключить легенду
surface=true                                 -- построение трёхмерного графика
samples=200                                  -- задать число точек на графике
raw='set pm3d'                               -- позволяет написать команды Gnuplot в явном виде
]],
[":tpolar(var, [x_N, y1_N, y2_N,..]) --> nil"] = [[График в полярных координатах для таблицы, матрицы или файла. Опциональные элементы определяют стоблцы.]],
[" () --> new_G"]                  = [[Подготовка таблицы для Gnuplot.]],
[":tsurf(v, [x1, y1, z1, z2..])"] = [[Построение графика поверхности на основе таблицы, матрицы или файла. Опциональные элементы определяют необходимые столбцы.]],
},
---------- polynomial.lua ----------
polynomial = {
["__module__"]           = [[Действия над полиномами.]],
[":spline(xs_t, ys_t) --> Ps_t"]       = [[Интерполяция данных кубическими сплайнами. Возвращает таблицу полиномов.]],
["P:copy() --> cpy_P"]               = [[Возвращает копию полинома.]],
[" {.., v1, v0} --> new_P"]          = [[Создаёт полином на основе списка коэффициентов.]],
[":ppval(Ps_t, x_d, [index_N]) --> num"]      = [[Вычисляет значение интерполяции из таблицы полиномов, можно использовать индекс полинома для ускорения расчёта.]],
["P:der() --> der_P"]                = [[Первая производная полинома.]],
[":build(root1, [root2,..]) --> P"] = [[Строит полином на основе списка корней.]],
[":lin(xs_t, ys_t, yBefore_d=0, yAfter_d=y0) --> P"] = [[Линейная интерполяция. Возвращает таблицу полиномов.]],
[":fit(xs_t, ys_t, order_N) --> P"]        = [[Аппроксимация точек полиномом заданной степени.]],
["P:val(x) --> y"]               = [[Вычисляет значение полинома в заданной точке. Эквивалентно вызаву P(x).]],
[":taylor(x_d, fx_d, [fx'_d, fx''_d,..]) --> P"] = [[Формирует полином Тейлора в окрестности заданной точки.]],
["P:roots() --> roots_t"]              = [[Поиск действительных и комплексных корней полинома.]],
["P:real() --> roots_t"]               = [[Возвращает список действительных корней полинома.]],
[":char(M) --> P"]             = [[Возвращает характеристический полином матрицы.]],
[":lagrange(xs_t, ys_t) --> P"]     = [[Интерполяция данных полиномом Лагранжа.]],
["P:int(x0_d=0) --> int_P"]          = [[Первообразная полинома, x0 - свободный коэффициент.]],
--["comparison"]           = [[a==b, a~=b]],
--["arithmetic"]           = [[a+b, a-b, a*b, a/b, a^n, -a]],
},
---------- data.lua ----------
data = {
["__module__"]           = [[Обработка данных и статистические расчёты.]],
[":xLt(num) --> cond_fn"]              = [[Возвращает функцию для условия x < d.]],
[":tcdf(x_d, deg_N) --> num"]           = [[Распределение Стьюдента.]],
[":freq(data_t) --> tbl"]             = [[Возвращает таблицу частот элементов.]],
[":histcounts(data_t, rng_v=10) --> sum_t, edges_t"] = [[Распределение данных по интервалам. Можно указать число интервалов разбиения, либо задать границы в виде таблицы.]],
[":tpdf(x_d, deg_N) --> num"]           = [[Плотность распределения Стьюдента.]],
[":max(data_t) --> var, ind_N"]              = [[Максимальный элемент и его индекс.]],
[":filter(in_t, condition) --> out_t"]     = [[Вильтрует список данных. Условием является булева функция или массив весов.]],
[":ref(src_t, begin_N=1, end_N=#t) --> new_R"] = [[Возвращает "ссылку" на таблицу элементов.]],
[":zip(fn,...) --> tbl"]         = [[Последовательно применяет функцию к списку векторов.]],
[":cov(data_t) --> cov_M"]              = [[Возвращает матрицу ковариации для списка векторов.]],
[":xIn(num1, num2) --> cond_fn"]          = [[Возвращает функцию для условия d1 <= x <= d2.]],
[":harmmean(data_t, [weigh_t]) --> num"]    = [[Гармоническое среднее.]],
[":xGt(num) --> cond_fn"]              = [[Возвращает функцию для условия x > d.]],
[":xEq(num) --> cond_fn"]              = [[Возвращает функцию для условия x == d.]],
[":isNot(data_t, cond_fn) --> yesno_t"]         = [[Возвращает инвертированные веса для булевой функции.]],
[":median(data_t) --> num"]           = [[Возвращает медиану распределения.]],
[":Fn(expr_s, arg_N=2) --> fn"]  = [[Генерирует функцию из строки с параметрами x1, x2 и т.д.]],
[":std(data_t, [weight_t]) --> dev_f, var_f"]         = [[Возвращает стандартное отклонение и дисперсию.]],
[":sum(data_t) --> var"]              = [[Возвращает сумму элементов.]],
[":moment(order_N, data_t, [weigth_t]) --> num"]    = [[Центральный момент t порядка N (с весами tw).]],
[":min(data_t) --> var, ind_N"]              = [[Возвращает наименьший элемент и его индекс.]],
[":geomean(data_t, [weigh_t]) --> num"]     = [[Геометрическое среднее.]],
[":cov2(xs_t, ys_t) --> float"]         = [[Вычисляет ковариацию для двух списков.]],
[":csvread(file_s, delim_s=',', isCol=false) --> tbl"] = [[Формирует таблицу на основе файла с заданным разделителем.]],
[":is(data_t, cond_fn) --> yesno_t"]            = [[Возвращает массив весов на основе булевой функции.]],
[":mean(data_t, [wight_t]) --> num"]        = [[Вычисляет среднее значение.]],
[":csvwrite(file_s, data_t, char=',', isCol=false) --> nil"] = [[Сохраняет таблицу в файл с заданным разделителем.]],
},
---------- matrix.lua ----------
matrix = {
["diag()"]               = [[Извлекает диагональные элементы либо формирует новую матрицу из вектора. n - индекс диагонали.]],
["M:reshape(row_N=size, col_N=1) --> upd_M"] = [[Изменить размер матрицы.]],
["V:dot(V2) --> num"]               = [[Скалярное произведение векторов.]],
["M:T() --> transpose_M"]                  = [[Транспонирование матрицы. Эквивалентно T().]],
["V:cross(V2) --> V3"]             = [[Векторное произведение 3-элементных векторов.]],
["M:det() --> num"]                = [[Определитель матрицы.]],
["M:chol() --> lower_M"]               = [[Преобразование Холески для положительно определённой симметричной матрицы.]],
["M:rref() --> upd_M"]               = [[Преобразование матрицы методом Гаусса.]],
["M:tr() --> sum"]                 = [[След матрицы.]],
["M:cols() --> N"]               = [[Число столбцов.]],
[":fill(row_N, col_N, val=1) --> M"] = [[Создать матрицу, заполненную заданным числом.]],
["__module__"]           = [[Операции с матрицами. На нулевые элементы память не расходуется. Индексация с единицы.]],
["M:norm() --> num"]               = [[Евклидова норма.]],
["M:eig() --> vectors_M, values_M"]                = [[Возвращает матрицы из собственных векторов и чисел.]],
[":zip(fn, M1, M2,..) --> res_M"]   = [[Поэлементно применяет функцию к матрицам для формирования новой матрицы.]],
["M:qr() --> Q_M, R_M"]                 = [[QR разложение матрицы. Возвращает Q и R.]],
["M:range(rows_t, cols_t) --> range_M"]         = [[Возвращает подматрицу с заданным интервалом строк и столбцов.]],
["M:inv() --> inv_M"]                = [[Обратная матрица.]],
[":zeros(row_N, col_N=row_N) --> M"] = [[Формирует матрицу нулей.]],
["M:lu() --> L_M, U_M, perm_M()"]                 = [[LU преобразование матрицы. Возвращает L, U и P.]],
["M:copy()"]               = [[Возвращает копию матрицы.]],
[" {row1_t, row2_t,..} --> new_M"]    = [[Создаёт матрицу на основе списка строк.]],
["M:rows() --> N"]               = [[Число строк.]],
["M:round(N=6) --> nil"]         = [[Округлить все элементы матрицы до заданного числа знаков.]],
[":eye(row_N, col_N=row_N) --> M"] = [[Единичная матрица.]],
["M:H() --> conj_M"]                  = [[Сопряженная транспонированная матрица.]],
["M:concat(M2,dir_s) --> comb_M"]       = [[Объединяет две матрица горизонтально (dir='h') или вертикально (dir='v').
Горизонтальная конкатенация доступна в виде M1 .. M2, а вертикальная - M1 // M2.]],
["M:insert(rows_t, cols_t, M2) --> nil"]      = [[Вставляет матрицу в заданный диапазон строк и столбцов.]],
["M:table() --> tbl"]              = [[Преобразует матрицу в обыкновенную Lua таблицу.]],
[":V {...}"]            = [[Преобразует список чисел в вектор.]],
["M:rank() --> N"]               = [[Возвращает ранг матрицы.]],
["M:pinv() --> inv_M"]               = [[Вовзращает псевдо-обратную матрицу.]],
["M:map(fn) --> found_M"]              = [[Формирует новую матрицу путём применения указанной функции к исходной. Функция может зависеть как от элементов, f(x) так и от индексов f(x,row,col).]],
--["comparison"]           = [[a==b, a~=b]],
["M:bidiag() --> U_M, B_M, V_M"]            = [[Бидиагонализация матрицы, возвращает U, B, V.]],
[":givensRot(elt1_v, elt2_v) --> cos_d, sin_d, len_d"]    = [[Возвращает параметры вращения Гивенса (c,s,r).]],
["M:householder(V, start_N) --> hh_M"]    = [[Возвращает матрицу преобразования Хаусхолдера.]],
--["arithmetic"]           = [[a+b, a-b, a*b, a/b, a^b, -a]],
["M:svd() --> U_M, S_M, V_M"]               = [[Сингулярное разложение матрицы, возвращает U, S, V.]],
},
}
