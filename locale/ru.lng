---------- locale/ru.lng ----------
{
language = 'Русский',
authors  = [[Станистав Михель]],
---------- dialog ----------
Dialog = {
["done"]                 = [[Выполнено.]],
["intro"]                = [[-------- help([функция]) = справка --------------
---------- use([модуль]) = импорт функций -------
----------------- quit() = выход ----------------
]],
["use_import"]           = [[Используйте
  use 'модуль' или use {'модульA','модульB' ...}
для подключения дополнительных модулей.
]],
},
---------- main.lua ----------
Main = {
["__module__"]           = [[Программа для математических расчётов на Lua.]],
["sqrt(dPos)"]           = [[Квадратный корень.]],
["rand()"]               = [[Случайное число от 0 до 1.]],
["Range(dBegin,dEnd,[dStep])"] = [[Генерация диапазона чисел.]],
["_pi"]                  = [[Число pi.]],
["randi(N)"]             = [[Случайное целое число от 1 до N.]],
["exp(d)"]               = [[Экспонента.]],
["sinh(d)"]              = [[Гиперболический синус.]],
["acosh(x)"]             = [[Гиперболический арккосинус.]],
["Log(sFlag)"]           = [[Сохранение сессии в файл лога. Используйте 'on'/'off' чтобы запустить/остановить процесс.]],
["randn([dMean=0,dev=1])"] = [[Нормально распределённая случайная величина с заданным средним значением и дисперсией.]],
["Round(f,[N=0])"]       = [[Округление числа до заданного количества десятичных знаков.]],
["asin(d)"]              = [[Арксинус x.]],
["log(dPos)"]            = [[Натуральный логарифм.]],
["Type(v)"]              = [[Печатает тип объекта, распознаёт типы, заданные в Sonata.]],
["Map(fn,t)"]            = [[Вычисляет функцию для всех элементов списка (таблицы), возвращает новый список.]],
["Print(...)"]           = [[Дополненная функция печати, показывает элементы таблицы, представляет числа в н "научно" виде.]],
["cosh(d)"]              = [[Гиперболический косинус.]],
["asinh(x)"]             = [[Гиперболический арксинус.]],
["Run(sFile,[bInt=false])"] = [[Выполнить lua- or note- файл. Установите флаг bInt для интерактивного выполнения.]],
["_ans"]                 = [[Результат последней операции.]],
["_e"]                   = [[Число Эйлера.]],
["atanh(x)"]             = [[Гиперболический арктангенс.]],
["cos(d)"]               = [[Косинус x.]],
["atan2(dy,dx)"]         = [[Арктангенс dy/dx с учётом знака.]],
["sin(d)"]               = [[Синус x.]],
["tan(d)"]               = [[Тангенс x.]],
["tanh(d)"]              = [[Гиперболический тангенс.]],
["acos(d)"]              = [[Арккосинус x.]],
["abs(d)"]               = [[Абсолютная величина.]],
},
---------- data.lua ----------
Data = {
["__module__"]           = [[Обработка данных и статистические расчёты.]],
["Data:mean(t,[tw])"]         = [[Вычисляет среднее значение.]],
["Data:cov2(t1,t2)"]          = [[Вычисляет ковариацию для двух списков.]],
["Data:harmmean(t,[tw])"]     = [[Гармоническое среднее.]],
["Data:xEq(d)"]               = [[Возвращает функцию для условия x == d.]],
["Dat:moment(N,t,[tw])"]     = [[Центральный момент x порядка N (с весами tw).]],
["Data:Fn(sExpr,[iArg=2])"]   = [[Генерирует функцию из строки с параметрами x1, x2 и т.д.]],
["Data:max(t)"]               = [[Максимальный элемент и его индекс.]],
["Data:xGt(d)"]               = [[Возвращает функцию для условия x > d.]],
["Data:geomean(t,[tw])"]      = [[Геометрическое среднее.]],
["Data:ref(t,[iBeg=1,iEnd=#t])"] = [[Возвращает "ссылку" на таблицу элементов.]],
["Data:zip(fn,...)"]          = [[Последовательно применяет функцию к списку векторов.]],
["Data:tcdf(d,N)"]            = [[Распределение Стьюдента.]],
["Data:min(t)"]               = [[Возвращает наименьший элемент и его индекс.]],
["Data:csvread(sFile,[delim=',',bCol=false])"] = [[Формирует таблицу на основе файла с заданным разделителем.]],
["Data:xIn(d1,d2)"]           = [[Возвращает функцию для условия d1 <= x <= d2.]],
["Data:isNot(t,fn)"]          = [[Возвращает инвертированные веса для булевой функции.]],
["Data:freq(t)"]              = [[Возвращает таблицу частот элементов.]],
["Data:tpdf(d,N)"]            = [[Плотность распределения Стьюдента.]],
["Data:xLt(d)"]               = [[Возвращает функцию для условия x < d.]],
["Data:histcounts(X,[rng=10])"] = [[Распределение данных по интервалам. Можно указать число интервалов разбиения, либо задать границы в виде таблицы.]],
["Data:std(t,[tw])"]          = [[Возвращает стандартное отклонение и дисперсию.]],
["Data:filter(t,vCond)"]      = [[Вильтрует список данных. Условием является булева функция или массив весов.]],
["Data:csvwrite(sFile,t,[char=',',bCol=false])"] = [[Сохраняет таблицу в файл с заданным разделителем.]],
["Data:sum(t)"]               = [[Возвращает сумму элементов.]],
["Data:cov(t)"]               = [[Возвращает матрицу ковариации для списка векторов.]],
["Data:is(t,fn)"]             = [[Возвращает массив весов на основе булевой функции.]],
["Data:median(t)"]            = [[Возвращает медиану распределения.]],
},
---------- numeric.lua ----------
Num = {
["__module__"]           = [[Функции для численных расчётов. Все функции работают с точностью, определяемой параметром TOL.]],
["Num:trapez(fn,a,b)"]       = [[Интегрирование методом трапеций.]],
["TOL[=0.001]"]          = [[Точность решения.]],
["Num:Newton(fn,d0)"]        = [[Поиск корня методом Ньютона в окрестностях заданной точки.]],
["Num:der(fn,x)"]            = [[Оценка производной функции в точке.]],
["Num:ode45(fn,tDelta,y0,[param])"] = [[Численное решение ОДУ.
Первый параметр задаёт уравнение, второй - временной интервал, третий - начальное значение функции. Дополнительно можно определить такие параметры как шаг интегрирования и условие прерывания.
Возвращает таблицу промежуточных точек и конечное значение yn.]],
["Num:solve(fn,dA,dB)"]      = [[Поиск корня уравнения fn(x)=0 на интервале [a,b].]],
},
---------- asciiplot.lua ----------
Ap = {
["__module__"]           = [[Визуализация данных с помощью псевдо-графики.]],
["Ap:concat(...)"]          = [[Горизонтальное объединение графиков равного размера. Для двух объектов можно использовать оператор '..' .]],
["reset()"]             = [[Очистка холста.]],
["bar(t,[vy=2,ix=1])"] = [[Столбчатая диаграмма. vy может быть индексом y в таблице t либо списком y-в.]],
["plot(...)"]          = [[Построение графиков данных для аргументов типа 't', 't1,t1', 'fn,nm', 'fn1,fn2' и т.д.]],
["Ap([iWidth=75,iHeight=23])"] = [[Новый график.]],
["tplot(t,[tOpt={}])"] = [[Построение графика на основе таблицы, можно указать номера столбцов и дополнительные опции.]],
["scale(factor,[bDefault=false])"] = [[Изменить размер графика относительно начальных размеров.]],
["copy()"]              = [[Возвращает копию объекта.]],
["addString(ir,ic,s)"] = [[Добавление строки в указанную позицию.]],
["addPose(ir,ic,s)"]   = [[Установка символа s в указанную позицию.]],
["addPoint(dx,dy,s)"]  = [[Добавить точку с координатами (dx,dy) с помощью символа 's'.]],
},
---------- quaternion.lua ----------
Quat = {
["__module__"]           = [[Операции над кватернионами.]],
["im()"]              = [[Возвращает таблицу мнимых элементов кватерниона.]],
["normalize(Q)"]         = [[Приводит кватернион к единичной форме.]],
["slerp(Q,f)"]       = [[Сферическая линейная интерполяция двух кватернионов.]],
["copy(t)"]              = [[Возвращает копию кватерниона.]],
["toAA()"]              = [[Возвращает угол поворота и ось вращения.]],
["Quat {w,i,j,k}"]       = [[Определение кватерниона через таблицу коэффициентов.]],
["toRot()"]             = [[Возвращает эквивалентную матрицу вращения.]],
--["comparison"]           = [[a == b, a ~= b]],
["Quat:fromAA(fAng,vAxe)"]    = [[Возвращает кватернион для заданного угла и оси вращения.]],
["inv()"]               = [[Возвращает крватернион, обратный к данному.]],
["conj()"]              = [[Сопряжённый кватернион.]],
--["arithmetic"]           = [[a + b, a - b, a * b, a ^ k, -a]],
["mat()"]               = [[Представление в виде эквивалентной матрицы.]],
["Quat:fromRot(M)"]           = [[Строит кватернион на основе угла поворота и оси вращения.]],
["rotate(vec)"]        = [[Возвращает вектор, полученный при вращении с помощью заданного кватерниона.]],
["abs()"]               = [[Норма кватерниона.]],
["re()"]              = [[Действительная часть (эквивалентно Q.w).]],
},
---------- rational.lua ----------
Rat = {
["__module__"]           = [[Операции с числами, представленными в виде дроби.]],
["Rat:gcd(va,vb)"]           = [[Наибольший общий делитель.]],
--["comparison"]           = [[R1<R2, R1<=R2, R1>R2, R1>=R2, R1==R2, R1~=R2]],
["Rat:from(f,[N=5])"]        = [[Получение дроби из числа в десятичном виде.]],
["copy(R)"]              = [[Возвращает копию рационального числа.]],
["float()"]             = [[Представление рационального числа в десятичном виде.]],
["eq(R)"]            = [[Проверка равенства двух чисел.]],
["num()"]                = [[Возвращает числитель.]],
--["arithmetic"]           = [[R1+R2, R1-R2, R1*R2, R1/R2, -R, R1^R2]],
["Rat(m,[n=1])"]         = [[Для создания рационального числа укажите числитель и (опционально) знаменатель.]],
["denom()"]                = [[Возвращает знаменатель.]],
},
---------- complex.lua ----------
Comp = {
["__module__"]           = [[Вычисления с комплексными числами.]],
["sqrt()"]              = [[Комплексный квадратный корень.]],
["angle()"]             = [[Аргумент комплексного числа.]],
["acosh()"]             = [[Комплексный обратный гиперболический косинус.]],
["cos()"]               = [[Комплексный косинус.]],
["abs()"]               = [[Модуль комплексного числа.]],
["exp()"]               = [[Комплексная экспонента.]],
["sinh()"]              = [[Комплексный гиперболический синус.]],
["tanh()"]              = [[Комплексный гиперболический тангенс.]],
["tan()"]               = [[Комплексный тангенс.]],
--["comparison"]           = [[a==b, a~=b]],
["acos()"]              = [[Комплексный обратный косинус.]],
["_i"]                   = [[Комплексная единица.]],
["Comp:trig(vModule,vAngle)"] = [[Формирует комплексное число через модуль и агрумент.]],
["sin()"]               = [[Комплексный синус.]],
["atanh()"]             = [[Комплексный обратный гиперболический тангенс.]],
["log()"]               = [[Комплексный логарифм.]],
["conj()"]              = [[Комплексно-сопряженное число. Эквивалентно ~C.]],
["cosh()"]              = [[Комплексный гиперболический косинус.]],
["asinh()"]             = [[Комплексный обратный гиперболический синус.]],
["Comp([vRe=0,vIm=0])"]  = [[Создаёт новое комплексное число.]],
["atan()"]              = [[Комплексный обратный тангенс.]],
--["arithmetic"]           = [[a+b, a-b, a*b, a/b, a^b, -a]],
["copy(C)"]              = [[Возвращает копию комплексного числа.]],
["asin()"]              = [[Комплексный обратный синус.]],
},
---------- units.lua ----------
Unit = {
["__module__"]           = [[Операции с единицами измерения.]],
["Unit:add(U,rule)"]          = [[Добавление нового правила преобразования единиц измерения.]],
--["comparison"]           = [[U1==U2, U1~=U2, U1<U2, U1<=U2, U1>U2, U1>=U2]],
["Unit(v,[u])"]          = [[Создание числа и/или единиц измерения.]],
["prefix"]               = [[Таблица дольных и кратных приставок.]],
--["arithmetic"]           = [[U1+U2, U1-U2, U1*U2, U1/U2, U1^N]],
["convert(v, fn)"]       = [[Преобразование между единицами измерения, функция возвращает новый объект или nil.]],
["copy()"]              = [[Создание копии объекта с его единицами измерения.]],
},
---------- const.lua ----------
_C = {
["__module__"]           = [[Разнообразные константы.]],
["astro.pc"]             = [[Один парсек.]],
["phy.e"]                = [[Заряд электрона.]],
["phy.sigma"]            = [[Постоянная Стефана-Больцмана.]],
["phy.NA"]               = [[Число Авогадро.]],
["math.phi"]             = [[Золотое сечение.]],
["math.pi"]              = [[Отношение длины окружности к её диаметру.]],
["phy.c"]                = [[Скорость света.]],
["phy.Rinf"]             = [[Постоянная Ридберга.]],
["phy.Vm"]               = [[Объём моля идеального газа.]],
["phy.g"]                = [[Ускорение свободного падения.]],
["phy.G"]                = [[Гравитационная постоянная.]],
["phy.k"]                = [[Постоянная Больцмана.]],
["_C:remove(sName)"]        = [[Удаление константы.]],
["_C:add(sName,value,[sUnits])"] = [[Добавление временной константы.]],
["math.e"]               = [[Основание натурального логарифма.]],
["phy.h"]                = [[Число планка.]],
["phy.eps0"]             = [[Электрическая постоянная.]],
["phy.mu0"]              = [[Магнитная постоянная.]],
["phy.R"]                = [[Универсальная газовая постоянная.]],
["astro.ly"]             = [[Световой год.]],
},
---------- special.lua ----------
Spec = {
["__module__"]           = [[Специальные функции.]],
["Spec:gammp(N,x)"]           = [[Неполная гамма-функция P(N,x).]],
["Spec:gammainc(x,N,[type='lower'])"] = [[Неполная гамма-функция, P (lower - нижняя) или Q (upper - верхняя).]],
["Spec:expint(n,x)"]          = [[Экспоненциальный интеграл En(x).]],
["Spec:besseli(N,x)"]         = [[Модифицированная функция Бесселя In(x).]],
["Spec:gammaln(z)"]           = [[Натуральный логарифм гамма-функции.]],
["Spec:gamma(z)"]             = [[Гамма-функция.]],
["Spec:legendre(n,x)"]        = [[Список коэффициентов полиномов Лежандра.]],
["Spec:betaln(z,w)"]          = [[Натуральный логарифм бета-функции.]],
["Spec:besselk(N,x)"]         = [[Модифицированная функция Бесселя Kn(x).]],
["Spec:betainc(x,a,b)"]       = [[Неполная бета-функция Ix(a,b).]],
["Spec:bessely(n,x)"]         = [[Функция Бесселя второго рода.]],
["Spec:erf(x)"]               = [[Функция ошибки.]],
["Spec:besselj(N,x)"]         = [[Функция Бесселя первого рода.]],
["Spec:gammq(N,x)"]           = [[Неполная гамма-функция Q(N,x) = 1-P(N,x).]],
["Spec:erfc(x)"]              = [[Дополнительная функция ошибки.]],
["Spec:beta(z,w)"]            = [[Бета-функция.]],
["Spec:dawson(x)"]            = [[Интеграл Доусона.]],
},
---------- bigint.lua ----------
Int = {
["__module__"]           = [[Вычисления с целыми числами произвольной длины.]],
["rebase(N)"]          = [[Конвертирует число в новую систему счисления.]],
--["comparison"]           = [[a<b, a<=b, a>b, a>=b, a==b, a~=b]],
["fact()"]              = [[Вычисляет факториал целого неотрицательного числа.]],
["isPrime([sMethod])"] = [[Проверка числа на простоту. Установите метод 'Fermat' для использования малой теоремы Ферма.]],
["eq(B)"]            = [[Проверка равенства двух чисел.]],
["gcd(B)"]           = [[Наибольший общий делитель.]],
["base()"]              = [[Возвращает основание системы счисления.]],
["Int:random(B)"]            = [[Псевдо-случайное число от 0 до B.]],
["copy(B)"]              = [[Возвращает копию числа.]],
["float()"]             = [[Представление в виде числа с плавающей точкой.]],
["Int(v)"]               = [[Создаёт большое целое число на основе числа, строки или таблицы.]],
--["arithmetic"]           = [[a+b, a-b, a*b, a/b, a%b, a^b, -a, #a]],
["abs()"]               = [[Возвращает модуль числа.]],
["factorize()"]         = [[Возвращает список простых множителей для данного числа.]],
},
---------- lens.lua ----------
Lens = {
["__module__"]           = [[Матричные методы в параксиальной оптике.]],
["inv(L)"]               = [[Инвертированная матрица системы.]],
["Lens:afocal(dm)"]           = [[Возвращает матрицу для афокальной системы.]],
["det()"]               = [[Возвращает определитель матрицы.]],
["Lens:ref(dr,dn1,dn2)"]      = [[Возвращает матрицу для преломления с учётом показателей преломления и радиуса кривизны поверхности.]],
["Lens {dA,dB,dC,dD}"]   = [[Новый объект с произвольными параметрами A, B, C, D.]],
["transform(dy,dV)"]   = [[Определяет положение луча 'dy' и оптический угол 'dV' (= v*n) на выходе оптической системы. Эквивалентно вызову L(dy,dV).]],
--["operations"]           = [[L1 == L2, L1 .. L2]],
["Lens:mirror(dr,dn)"]        = [[Возвращает матрицу отражения на кривой поверхности с учётом показателя преломления.]],
["cardinal([dn1=1,dn2=1])"] = [[Поиск положения кардинальных точек системы относительно входных и выходных плоскостей, с учётом показателей преломления. Возвращает список расстояний.]],
["Lens:trans(dt,dn)"]         = [[Возвращает матрицу перемещения с учётом показателя преломления.]],
["isUnit()"]            = [[Проверка, является ли матрица единичной.]],
["copy()"]              = [[Возвращает копию объекта.]],
["Lens:thin(df)"]             = [[Возвращает матрицу для тонкой линзы при заданном фокальном расстоянии.]],
["Lens:solve(fn,ind,d0)"]     = [[Поиск условий, при которых компонент с заданным индексом равен 0. d0 - начальное предположение.]],
},
---------- matrix.lua ----------
Mat = {
["__module__"]           = [[Операции с матрицами. На нулевые элементы память не расходуется. Индексация с единицы.]],
["Mat:fill(iRows,iCols,fn)"] = [[Генерирует матрицу на основе функции fn(строка,столбец).]],
["Mat:eye(iRows,[iCols=iRows,val=1])"] = [[Возвращает единичную матрицу. Диагональные элементы могут быть отличны от 1.]],
["copy()"]              = [[Возвращает копию матрицы.]],
["Mat:zeros(rows,[cols=rows])"] = [[Формирует матрицу нулей.]],
["map(fn)"]            = [[Формирует новую матрицу путём применения указанной функции к исходной. Функция может зависеть как от элементов, f(x) так и от индексов f(x,row,col).]],
["pinv()"]              = [[Вовзращает псевдо-обратную матрицу.]],
["table()"]             = [[Преобразует матрицу в обыкновенную Lua таблицу.]],
["apply(fn,M1,M2,...)"]  = [[Применяет функцию к одной или нескольким матрицам.]],
["tr()"]                = [[След матрицы.]],
["T()"]         = [[Транспонирование матрицы. Эквивалентно T().]],
["rand(iRows,[iCols=iRows])"] = [[Возвращает матрицу случайных чисел от 0 до 1.]],
["inv()"]               = [[Обратная матрица.]],
["chol()"]              = [[Преобразование Холески для положительно определённой симметричной матрицы.]],
["norm()"]              = [[Евклидова норма.]],
["det()"]               = [[Определитель матрицы.]],
--["comparison"]           = [[a==b, a~=b]],
["reshape([iRows=size,iCols=1])"] = [[Изменить размер матрицы.]],
["lu()"]                = [[LU преобразование матрицы. Возвращает L,U и P.]],
["concat(M,sDir)"]   = [[Объединяет две матрица горизонтально (dir='h') или вертикально (dir='v').
Горизонтальная конкатенация доступна в виде M1 .. M2, а вертикальная - M1 // M2.]],
["rref()"]              = [[Преобразование матрицы методом Гаусса.]],
["randn(iRows,[iCols=iRows])"] = [[Возвращает матрицу нормально распределённых случайных чисел (с нулевым средним и единичной дисперсией).]],
["randi([M],N,[rows,cols=rows])"] = [[Создаёт матрицу случайных целых чисел от 1 до N. Возможен вызов в виде 'randi(M,N)' или 'randi(N,r,c)'.]],
["diag()"]        = [[Извлекает диагональные элементы либо формирует новую матрицу из вектора. n - индекс диагонали.]],
["ones(iRows,[iCols=iRows,val=1])"] = [[Формирует матрицу из единиц (или заданного числа).]],
["size(M)"]              = [[Возвращает число строк и столбцов матрицы.]],
["dot(V)"]           = [[Скалярное произведение векторов.]],
["rank()"]              = [[Возвращает ранг матрицы.]],
--["arithmetic"]           = [[a+b, a-b, a*b, a/b, a^b, -a]],
["cross(V)"]         = [[Векторное произведение 3-элементных векторов.]],
["Mat {tRow1,tRow2,..}"] = [[Создаёт матрицу на основе списка строк.]],
},
---------- polynomial.lua ----------
Poly = {
["__module__"]           = [[Действия над полиномами.]],
["int([d0=0])"]        = [[Первообразная полинома, x0 - свободный коэффициент.]],
["Poly:ppval(tP,d,[N]"]       = [[Вычисляет значение интерполяции из таблицы полиномов, можно использовать индекс полинома для ускорения расчёта.]],
["Poly:lagrange(tX,tY)"]      = [[Интерполяция данных полиномом Лагранжа.]],
["real()"]              = [[Возвращает список действительных корней полинома.]],
["Poly:taylor(v,vF,[vF',vF''..])"] = [[Формирует полином Тейлора в окрестности заданной точки.]],
--["comparison"]           = [[a==b, a~=b]],
["val(v)"]             = [[Вычисляет значение полинома в заданной точке. Эквивалентно вызаву P(x).]],
["der()"]               = [[Первая производная полинома.]],
["Poly:build(root1,root2,...)"] = [[Строит полином на основе списка корней.]],
["roots()"]             = [[Поиск действительных и комплексных корней полинома.]],
["Poly:fit(tX,tY,N)"]         = [[Аппроксимация точек полиномом заданной степени.]],
["Poly {..,v1,v0}"]      = [[Создаёт полином на основе списка коэффициентов.]],
["copy()"]              = [[Возвращает копию полинома.]],
--["arithmetic"]           = [[a+b, a-b, a*b, a/b, a^n, -a]],
["Poly:lin(tX,tY,[v0=0,vN=v0])"] = [[Линейная интерполяция. Возвращает таблицу полиномов.]],
["Poly:spline(tX,tY)"]        = [[Интерполяция данных кубическими сплайнами. Возвращает таблицу полиномов.]],
},
---------- array.lua ----------
Arr = {
["__module__"]           = [[Операции с массивами, т.е. многомерными упорядоченными последовательностями элементов. Индексы задаются в виде таблицы. Индексация с единицы.]],
["Arr {n1,n2,..}"]       = [[Создаёт пустой массив заданного размера.]],
--["comparison"]           = [[a == b, a ~= b]],
["get(tInd)"]          = [[Возвращает значение заданного элемента.]],
["capacity()"]          = [[Возвращает максимальное число элементов в массиве. Эквивалентно #A.]],
["sub(tInd1,tInd2)"]   = [[Возвращает массив, ограниченный двумя индексами.]],
["set(tInd,v)"]        = [[Присваивание значения заданному элементу.]],
["apply(fn, ...)"]       = [[Формирует новый массив путём применения функции к одному или нескольким исходным.]],
["dim()"]               = [[Возвращает размерность массива.]],
["rand(tSize)"]          = [[Создаёт массив случайных чисел от 0 до 1.]],
["ipairs()"]              = [[Итератор, который при каждом вызове возвращает индекс и элемент множества.]],
["copy()"]              = [[Возвращает копию массива.]],
["map(fn)"]            = [[Формирует новый массив путём применения функции к элементам исходного.]],
--["arithmetic"]           = [[a+b, a-b, a*b, a/b, -a, a^b]],
["concat(A,iAxis)"]  = [[Формирует новый массив путём объединения двух исходных по заданной оси.]],
["isEqual(A)"]       = [[Сравнение размерностей массивов.]],
},
---------- gnuplot.lua ----------
Gp = {
["__module__"]           = [[Интерфейс для взаимодействия с Gnuplot.]],
["Gp:tplot(v[,x,y1,y2..])"] = [[Построение графика на основе таблицы, матрицы или файла. Опциональные элементы определяют необходимые столбцы.]],
["Gp:plot(x1[,y1,nm,x2,..])"] = [['x' - список чисел, 'y' - список или функция, 'nm' - имя кривой.]],
["show()"]              = [[Строит график на основе параметров, представленных в виде таблицы Lua.]],
["keys"]                 = [[  Описание параметров:
{math.sin, title='sin'}                      -- строит график для Lua функции, добавляет текст в легенду
{'sin.dat', ln=1, lw=2}                      -- строит график для файла с учётом цвета и толщины маркеров
{tbl, with='lines'}                          -- строит график для Lua таблицы с помощью линий
title='Graph name'                           -- имя графика в целом
xrange={0,10}                                -- диапазон x от 0 до 10
yrange={-2,2}                                -- диапазон y
zrange={0,5}                                 -- диапазон z
trange={1,2}                                 -- изменение параметра в случае параметрической функции
xtitle='A', ytitle='B'                       -- имена осей
terminal='jpeg'                              -- сохранение результата в файл
output='my_plot.jpg'                         -- имя файла для вывода результата
parametric=true                              -- параметрическое представление функции
size='square'                                -- установить квадратный размер изображения
polar=true                                   -- график в полярных координатах
grid='polar'                                 -- изменить тип сетки на полярный
legend=false                                 -- отключить легенду
surface=true                                 -- построение трёхмерного графика
samples=200                                  -- задать число точек на графике
raw='set pm3d'                               -- позволяет написать команды Gnuplot в явном виде
]],
["Gp:polarplot(x1,y1,[nm,x2,y2..])"] = [[График в полярных координатах. 'x' - список чисел, 'y' - список либо функция, 'nm' - имя кривой.]],
["Gp()"]                 = [[Подготовка таблицы для Gnuplot.]],
["Gp:surfplot(x1,y1,fn1,[nm,x2,y2..])"] = [[Построение поверхности. 'x' и 'y' - списки чисел, 'fn' - функция двух агрументов, 'nm' - имя поверхности.]],
["Gp:tpolar(v,[x,y1,y2..])"] = [[График в полярных координатах для таблицы, матрицы или файла. Опциональные элементы определяют стоблцы.]],
["copy()"]              = [[Возвращает копию параметров графика.]],
["tsurf(v,[x1,y1,z1,z2..])"] = [[Построение графика поверхности на основе таблицы, матрицы или файла. Опциональные элементы определяют необходимые столбцы.]],
["add(tCurve)"]          = [[Добавить функцию для построения.]],
},
---------- geodesy.lua ----------
Geo = {
["__module__"]           = [[Преобразования координат и другие геодезические задачи.]],
["A.blhInto[B]"]         = [[Возвращает функцию для преобразования геодезических координат из A в B с помощью метода Молоденского.]],
["toBLH(tXYZ)"]        = [[Приобразовать геоцентрические координаты в геодезические.]],
["Geo:fromENU(tBLr,tXYZr,tTop)"] = [[Преобразовать топоцентрические координаты точки в геоцентрические.]],
["projGK(tBL)"]        = [[Вовзращает северное и восточное положение точки в проекции Гаусса-Крюгера.]],
["toXYZ(tBLH)"]        = [[Преобразует геодезические координаты в геоцентрические.]],
["solveDir(BLH,azimuth,dist)"] = [[Решение прямой задачи геодезии, поиск положения и азимута второй точки при заданных начальной точке, направлении и расстоянии.]],
["projM(tBL)"]         = [[Возвращает северное и восточное положение точки в проекции Меркатора.]],
["Geo:toENU(tBLr,tXYZr,tCatr)"] = [[Преобразовать геоцентрические координаты точки в топоцентрические.]],
["A.xyzInto[B]"]         = [[Возвращает функцию для преобразования геоцентрических координат из системы A в B.]],
["Geo:grav(dB)"]             = [[Международная формула гравитации, аргумент в радианах.]],
["solveInv(BLH1,BLH2)"] = [[Решение обратной задачи геодеции, поиск расстояния и азимутов для двух заданных точек.]],
["Geo:deg2dms(d)"]           = [[Возвращает градусы, минуты и секунды для заданного угла в градусах.]],
["Geo:dms2rad(d,[m=0,s=0])"] = [[Преобразует градусы, минуты и секунды в радианы.]],
},
---------- graph.lua ----------
Graph = {
["__module__"]           = [[Операции с графами.]],
["edges()"]             = [[Возвращает список рёбер.]],
["isWeighted()"]        = [[True если граф взвешенный.]],
["copy()"]              = [[Создаёт копию графа.]],
["add(v)"]             = [[Добавляет узел (одиночное имя) или ребро. Ребро представлено списком, содержащим начало, конец и, при необходимости, вес (веса).]],
["isNegative()"]        = [[True если граф содержит отрицательные веса.]],
["pathD(vStart,[vGoal])"] = [[Поиск кратчайшего пути алгоритмом Дейкстры. Возвращает таблицу расстояний и узлов. Если задана цель, возвращает путь и его длину.]],
["bfs(vStart,vGoal)"]  = [[Поиск в ширину. Возвращает флаг результата и найденный путь.]],
["isDirected()"]        = [[True если граф направленный.]],
["isComplete()"]        = [[True если граф полный.]],
["remove(v)"]          = [[Удаляет узел или ребро. Узлы представляются именем, рёбра - двухэлементным списком.]],
["pathBF(vStart,[vGoal])"] = [[Поиск кратчайшего пути алгоритмом Беллмана-Форда. Возвращает таблицу расстояний и узлов. Если задана цель, возвращает путь и его длину.]],
["nodes()"]             = [[Возвращает список узвло графа.]],
["dfs(vStart,vGoal)"]  = [[Поиск в глубину. Возвращает флаг результата и найденный путь.]],
["Graph {v1,v2,..}"]     = [[Создает новый граф.]],
},
}
