<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Sonata LC Help</title>
</head><body>
<style type="text/css">
H3 {text-align:center;}
P {line-height:1.3;}
UL {column-count: 4; border: 2px solid blue; border-radius: 5px; padding: 5px 5px 5px 30px;}
DIV {margin-left: 10px;}
.EXAMPLE {border: 2px solid blue; border-radius: 5px; background: lightgrey; padding: 15px; margin: 10px 0px; color:navy; }
.DESCRIPT {text-align:center; font-style:italic; }
</style>
<a name="Top"></a>
<div><h1 align="center">Sonata Lua Calculus</h1>
<ul>
<li><a href="#Arr">array</a></li>
<li><a href="#Int">bigint</a></li>
<li><a href="#Comp">complex</a></li>
<li><a href="#_C">const</a></li>
<li><a href="#Gp">gnuplot</a></li>
<li><a href="#Graph">graph</a></li>
<li><a href="#Mat">matrix</a></li>
<li><a href="#Num">numeric</a></li>
<li><a href="#Poly">polynom</a></li>
<li><a href="#Quat">quaternion</a></li>
<li><a href="#Rat">rational</a></li>
<li><a href="#Spec">special</a></li>
<li><a href="#Stat">stat</a></li>
<li><a href="#Unit">units</a></li>
</ul></div>
<div><h3># About #</h3>
<p><br>
'Sonata LC' is a Lua based program for mathematical calculations.<br>
<br>
<b>USAGE</b>:<br>
	lua [-i] sonata.lua [flag] [arg1 arg2 ...]<br>
(option '-i' can be used for working in native Lua interpreter)<br>
<br>
<b>FLAGS</b>:<br>
	--help, -h - Get this help message.<br>
		{Development}<br>
	--test   - Apply the unit tests to the desired module. Call all modules if the name is not defined.<br>
	  (e.g. --test array)<br>
	--doc    - Creating/updating a documentation file.<br>
	  (e.g. --doc ru)<br>
	--new    - Create a template for a new module.<br>
	  (e.g. --new  signal  Sig  "Signal processing functions.")<br>
	--lang   - Creating/updating a file for localization.<br>
	  (e.g. --lang eo)<br>
	 No flag  - Evaluate file(s).<br>
<br>
<b>VERSION</b>: 0.9.22<br>
<br>
<b>MODULES</b>: rational, quaternion, stat, numeric, polynom, units, special, complex, graph, matrix, array, bigint, gnuplot, const.<br>
<br>
<b>BUGS</b>: mail to 'SonataLC@yandex.ru'<br>
</p>
<p><a href="https://github.com/mikhel1984/sonata/wiki">Project Wiki</a></p></div>
<div><a name="Main"></a>
<h3># Main (main) #</h3>
<p class="descript">Программа для математических расчётов на Lua.</p>
<p><b>_ans</b> - Результат последней операции.<br>
<b>_e</b> - Число Эйлера.<br>
<b>_pi</b> - Число pi.<br>
<b>abs(x)</b> - Абсолютное значение (модуль) числа.<br>
<b>acos(x)</b> - Арккосинус x.<br>
<b>acosh(x)</b> - Гиперболический арккосинус.<br>
<b>asin(x)</b> - Арксинус x.<br>
<b>asinh(x)</b> - Гиперболический арксинус.<br>
<b>atan2(y,x)</b> - Арктангенс, который учитывает знаки агрументов.<br>
<b>atanh(x)</b> - Гиперболический арктангенс.<br>
<b>cos(x)</b> - Косинус x.<br>
<b>cosh(x)</b> - Гиперболический косинус.<br>
<b>exp(x)</b> - Экспоненциальная зависимость.<br>
<b>lc.dsvRead(fName[,delim=','])</b> - Read delimiter separated data as Lua table.<br>
<b>lc.dsvWrite(fname,tbl[,delim=','])</b> - Save Lua table as delimiter separated data into file.<br>
<b>lc.map(fn,tbl)</b> - Вычисляет функцию для всех элементов списка (таблицы), возвращает новый список.<br>
<b>lc.print(...)</b> - Дополненная функция печати, показывает элементы таблицы, представляет числа в н "научно" виде.<br>
<b>lc.range([from=1,]to[,step=1])</b> - Генерация последовательности чисел в заданном диапазоне.<br>
<b>lc.round(x[,n=0])</b> - Округление числа до заданного количества десятичных знаков.<br>
<b>lc.tblImport(fName)</b> - Import Lua table, saved into file.<br>
<b>lc.type(t)</b> - Печатает тип объекта, распознаёт типы, заданные в Sonata.<br>
<b>log(x)</b> - Натуральный логарифм.<br>
<b>logging(flag)</b> - Сохранение сессии в файл. Используйте 'on'/true для начала и 'off'/false для окончания.<br>
<b>rand()</b> - Случайное число от 0 до 1.<br>
<b>randi(N)</b> - Случайное целое число от 1 до N.<br>
<b>randn()</b> - Нормально распределённая случайная величина с нулевым средним и единичной дисперсией.<br>
<b>sin(x)</b> - Синус x.<br>
<b>sinh(x)</b> - Гиперболический синус.<br>
<b>sqrt(a)</b> - Квадратный корень числа.<br>
<b>tan(x)</b> - Тангенс x.<br>
<b>tanh(x)</b> - Гиперболический тангенс.<br></p>
<pre class="example">

lc = require 'core.main'

-- constants starts from _
ans = _pi                     --> math.pi

-- standard functions 
ans = exp(0)+sin(_pi/2)+cosh(0)  --1> 3.0

-- round number
ans = lc.round(0.9)           --> 1.0

-- save 2 digits
ans = lc.round(math.pi, 2)    --> 3.14

-- random between 0 and 1
p = rand()
ans = (p >= 0) and (p <= 1)   --> true

-- random integer (1 to 10)
p = randi(10)
ans = (p >= 1) and (p <= 10)  --> true

-- normal distributed random
print(randn())

-- get object type
-- "knows" types for Sonata objects
ans = lc.type(25)             --> 'integer'

-- modified print function 
a = {a=1,b=2, 3,4,5}
lc.print(a, 0.123)

-- generate 'sequence'
b = lc.range(3)
ans = b[3]                    --> 3

-- even numbers
b = lc.range(2,10,2)
ans = b[2]                    --> 4

-- calculate function values
c = lc.map(sin, b)
ans = c[1]                   --3> 0.909

-- use Lua functions if need
ans = math.floor(_pi)

ans = math.deg(_pi)

-- prepare file name
nm = os.tmpname()

-- save table 
-- separate elements with ';'
t = {{1,2,3},{4,5,6}}
lc.dsvWrite(nm, t, ';')

-- read table from file
-- with separator ';'
tt = lc.dsvRead(nm, ';')
ans = tt[2][2]                --> 5

-- read table from file
f = io.open(nm,'w')
f:write("{1,2.0,a='pqr',b={3,4,c='abc'}}")
f:close()
aa = lc.tblImport(nm)
ans = aa.b.c                  --> 'abc'

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Arr"></a>
<h3># Arr (array) #</h3>
<p class="descript">Операции с массивами, т.е. многомерными упорядоченными последовательностями элементов. Индексы задаются в виде таблицы. Индексация с единицы.</p>
<p><b>Arr(tSize)</b> - Создаёт пустой массив заданного размера.<br>
<b>apply(func, ...)</b> - Формирует новый массив путём применения функции к одному или нескольким исходным.<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, -a, a^b<br>
<b>capacity(A)</b> - Возвращает максимальное число элементов в массиве. Эквивалентно #A.<br>
<b>comparison</b> - a == b, a ~= b<br>
<b>concat(A1,A2,nAxis)</b> - Формирует новый массив путём объединения двух исходных по заданной оси.<br>
<b>copy(A)</b> - Возвращает копию массива.<br>
<b>dim(A)</b> - Возвращает размерность массива.<br>
<b>get(A,tInd)</b> - Возвращает значение заданного элемента.<br>
<b>isEqual(A1,A2)</b> - Сравнение размерностей массивов.<br>
<b>map(A,func)</b> - Формирует новый массив путём применения функции к элементам исходного.<br>
<b>next(A)</b> - Итератор, который при каждом вызове возвращает индекс и элемент множества.<br>
<b>rand(tSize)</b> - Создаёт массив случайных чисел от 0 до 1.<br>
<b>set(A,tInd,val)</b> - Присваивание значения заданному элементу.<br>
<b>sub(A,tInd1,tInd2)</b> - Возвращает массив, ограниченный двумя индексами.<br></p>
<pre class="example">

-- use 'array'
Arr = require 'lib.array'

-- empty array
a = Arr {2,3,4}
ans = a:get{1,2,1}            --> nil

-- set values
a:set({1,2,1},4)
ans = a:get{1,2,1}            --> 4

-- random array
b = Arr.rand {5,2,1}
-- max number of elements
ans = #b                      --> 10

ans = b:copy()                --> b

-- compare sizes
ans = b:isEqual(Arr.rand{5,2,1})  --> true

-- arithmetical operations
c = b + b
ans = c:get{1,1,1}            --> 2*b:get{1,1,1}

-- get sub array
g = a:sub({1,1,1},{-1,-1,2})
ans = g:isEqual(Arr{2,3,2})   --> true

-- concatenate along the 3-rd axes
d = Arr.concat(b,b,3)
-- size for given dimension
ans = d:dim()[3]              --> 2

-- apply function of several arguments
a1 = Arr.rand{2,2}
a2 = Arr.rand{2,2}
a3 = Arr.rand{2,2}
fn = function (x,y,z) return x*y+z end
a4 = Arr.apply(fn, a1,a2,a3)
ans = a4:get{1,2}             --> a1:get{1,2}*a2:get{1,2}+a3:get{1,2}


-- apply function of 1 argument
-- to get new array
f = b:map(function (x) return 10*x end)
ans = f:get{1,1,1}            --> b:get{1,1,1}*10

-- simple print
print(a)

-- iterate over array 
-- prepare 
g = Arr {2,2}
g:set({1,1}, 1)
g:set({2,1}, 2)
g:set({1,2}, 3)
g:set({2,2}, 4)
-- show
for ind, val in g:next() do io.write('{',ind[1],',',ind[2],'}\t',val, '\n') end

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Int"></a>
<h3># Int (bigint) #</h3>
<p class="descript">Вычисления с целыми числами произвольной длины.</p>
<p><b>Int(v)</b> - Создаёт большое целое число на основе числа, строки или таблицы.<br>
<b>abs(v)</b> - Возвращает модуль числа.<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, a%b, a^b, -a, #a<br>
<b>base(B)</b> - Возвращает основание системы счисления.<br>
<b>comparison</b> - a<b, a<=b, a>b, a>=b, a==b, a~=b<br>
<b>copy(v)</b> - Возвращает копию числа.<br>
<b>eq(a,b)</b> - Проверка равенства двух чисел.<br>
<b>fact(B)</b> - Вычисляет факториал целого неотрицательного числа.<br>
<b>factorize(B)</b> - Возвращает список простых множителей для данного числа.<br>
<b>gcd(B1,B2)</b> - Наибольший общий делитель.<br>
<b>isPrime(B[,method])</b> - Проверка числа на простоту. Установите метод 'Fermat' для использования малой теоремы Ферма.<br>
<b>random(B)</b> - Псевдо-случайное число от 0 до B.<br>
<b>rebase(B,base)</b> - Конвертирует число в новую систему счисления.<br>
<b>val(N)</b> - Представление в виде числа с плавающей точкой.<br></p>
<pre class="example">
-- use 'bigint'
Int = require 'lib.bigint'

-- from integer
a = Int(123)
ans = a:val()                 --> 123

-- from string
b = Int('456')
ans = b:val()                 --> 456

-- from table 
-- 'sign' and 'base' can be skipped
g = Int {1,2,3,sign=-1,base=10}
ans = g:val()                 --> -123

-- check equality
ans = (a == -g)               --> true

-- arithmetical operations
ans = Int.val(a+b)            --> 579

ans = Int.val(a-b)            --> -333

ans = Int.val(a*Int(2))       --> 246

ans = Int.val(b/2)            --> 228

ans = Int.val(b%a)            --> 87

ans = Int.val(a^3)            --> 1860867

-- absolute value
ans = Int.abs('-25'):val()    --> 25

-- factorial
c = Int(10):fact()
ans = Int.val(c)              --> 3628800

-- make copy, comparison
d = a:copy()
ans = (a == d)                --> true

ans = (a > b)                 --> false

ans = (a == b)                --> false

-- compare with number
ans = a:eq(123)               --> true

-- number of digits
ans = #a                      --> 3

-- 2nd digit (from the lowest)
ans = a[2]                    --> 2

-- get numeric base 
ans = g:base()                --> 10

-- change numeric base
v = g:rebase(60)
ans = tostring(v)             --> '-2|3'

-- still the same value
ans = (v == g)                --> true

-- operations with different bases
-- transform to the biggest common base
w = v + b
ans = tostring(w)             --> '5|33'

-- simple print
print(a)

-- check if it prime
-- iterate though multipliers 
ans = Int.isPrime(1229)       --> true

-- Fermat theorem 
ans = Int.isPrime(1229,'Fermat') --> true

-- factorize 
t = b:factorize()
ans = #t                      --> 5

-- check factorization
ans = 1
for i = 1,#t do
  ans = ans * (t[i]:val())
end                           --> 456

-- pseudo-random number
-- from 0 to b
print(b:random())

-- greatest common divisor
ans = a:gcd(b):val()          --> 3

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Comp"></a>
<h3># Comp (complex) #</h3>
<p class="descript">Вычисления с комплексными числами.</p>
<p><b>Comp([re=0],[im=0])</b> - Создаёт новое комплексное число.<br>
<b>_i</b> - Комплексная единица.<br>
<b>abs(Z)</b> - Модуль комплексного числа.<br>
<b>acos(Z)</b> - Комплексный обратный косинус.<br>
<b>acosh(Z)</b> - Комплексный обратный гиперболический косинус.<br>
<b>angle(Z)</b> - Аргумент комплексного числа.<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, a^b, -a<br>
<b>asin(Z)</b> - Комплексный обратный синус.<br>
<b>asinh(Z)</b> - Комплексный обратный гиперболический синус.<br>
<b>atan(Z)</b> - Комплексный обратный тангенс.<br>
<b>atanh(Z)</b> - Комплексный обратный гиперболический тангенс.<br>
<b>comparison</b> - a==b, a~=b<br>
<b>conj(Z)</b> - Комплексно-сопряженное число. Эквивалентно ~Z.<br>
<b>copy(Z)</b> - Возвращает копию комплексного числа.<br>
<b>cos(Z)</b> - Комплексный косинус.<br>
<b>cosh(Z)</b> - Комплексный гиперболический косинус.<br>
<b>exp(Z)</b> - Комплексная экспонента.<br>
<b>log(Z)</b> - Комплексный логарифм.<br>
<b>sin(Z)</b> - Комплексный синус.<br>
<b>sinh(Z)</b> - Комплексный гиперболический синус.<br>
<b>sqrt(Z)</b> - Комплексный квадратный корень.<br>
<b>tan(Z)</b> - Комплексный тангенс.<br>
<b>tanh(Z)</b> - Комплексный гиперболический тангенс.<br>
<b>trig(module,angle)</b> - Формирует комплексное число через модуль и агрумент.<br></p>
<pre class="example">

-- use 'complex'
Comp = require 'lib.complex'

-- real and imaginary pars
a = Comp(1,2)
-- or just imaginary
b = Comp(0,3)

-- imaginary unit
j = Comp._i
ans = 3+4*j                   --> Comp(3,4)

-- use trigonometrical form
ans = Comp.trig(2,0)          --> Comp(2,0)

-- arithmetic
ans = a + b                   --> Comp(1,5)

ans = Comp(0,3) - b           --> Comp(0,0)

ans = a * b                   --> Comp(-6,3)

ans = a / Comp._i             --> Comp(2,-1)

-- power can be complex
c = Comp(1,1)^Comp(2,-2)

-- real part
ans = c.Re                   --3> 6.147

-- imaginary part
ans = c.Im                   --1> 7.4

-- comparison
ans = (a == b)                --> false

ans = (a ~= b)                --> true

-- absolute value
ans = a:abs()                --3> 2.236

-- argument (angle)
ans = a:angle()              --3> 1.107

-- conjugated number
ans = a:conj()                --> Comp(1,-2)

-- some functions after import 
-- become default, such as
d = Comp.sqrt(-2)
ans = d.Im                   --3> 1.414

-- exp
ans = Comp.exp(d).Re         --3> 0.156

-- log
ans = Comp.log(d).Re         --3> 0.3465

-- sin 
ans = Comp.sin(d).Im         --3> 1.935

-- cos 
ans = Comp.cos(d).Im         --1> 0

-- tan
ans = Comp.tan(d).Re         --1> 0

-- sinh
ans = Comp.sinh(d).Re        --1> 0

-- cosh
ans = Comp.cosh(d).Re        --3> 0.156

-- tanh
ans = Comp.tanh(d).Im        --3> 6.334

-- asin
z = Comp(2,3)
ans = z:asin().Im            --3> 1.983

-- acos 
ans = z:acos().Re            --2> 1.000

-- atan
ans = z:atan().Im            --3> 0.229

-- asinh
ans = z:asinh().Re           --3> 1.968

-- acosh
ans = z:acosh().Im           --1> 1.000

-- atanh
ans = z:atanh().Re           --3> 0.146

-- make copy
ans = a:copy()                --> a

-- show
print(a)

--</pre>
<a href="#Top">Top</a></div>
<div><a name="_C"></a>
<h3># _C (const) #</h3>
<p class="descript">Разнообразные константы.</p>
<p><b>add(name,value)</b> - Добавление неизменяемого значения.<br>
<b>astro.ly</b> - Световой год.<br>
<b>astro.pc</b> - Один парсек.<br>
<b>math.e</b> - Основание натурального логарифма.<br>
<b>math.phi</b> - Золотое сечение.<br>
<b>math.pi</b> - Отношение длины окружности к её диаметру.<br>
<b>phy.G</b> - Гравитационная постоянная.<br>
<b>phy.NA</b> - Число Авогадро.<br>
<b>phy.R</b> - Универсальная газовая постоянная.<br>
<b>phy.Rinf</b> - Постоянная Ридберга.<br>
<b>phy.Vm</b> - Объём моля идеального газа.<br>
<b>phy.c</b> - Скорость света.<br>
<b>phy.e</b> - Заряд электрона.<br>
<b>phy.eps0</b> - Электрическая постоянная.<br>
<b>phy.g</b> - Ускорение свободного падения.<br>
<b>phy.h</b> - Число планка.<br>
<b>phy.k</b> - Постоянная Больцмана.<br>
<b>phy.mu0</b> - Магнитная постоянная.<br>
<b>phy.sigma</b> - Постоянная Стефана-Больцмана.<br>
<b>remove(name)</b> - Удаление константы.<br></p>
<pre class="example">

-- use 'const'
_C = require 'lib.const'

-- charge of electron
ans = _C.phy.e * 1E19        --3> 1.602

-- units have postfix _u
ans = _C.phy.e_u              --> 'C'

-- create "immutable" value
_C.add('myConst', 10)
ans = _C.myConst              --> 10

-- modification generate error
ans = pcall(function() _C.myConst = 0 end)  --> false

-- remove constant
_C.remove('myConst')
ans = _C.myConst              --> nil

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Gp"></a>
<h3># Gp (gnuplot) #</h3>
<p class="descript">Интерфейс для взаимодействия с Gnuplot.</p>
<p><b>Gp()</b> - Подготовка таблицы для Gnuplot.<br>
<b>add(tCurve)</b> - Добавить функцию для построения.<br>
<b>copy(G)</b> - Возвращает копию параметров графика.<br>
<b>keys</b> -   Описание параметров:<br>
{math.sin, title='sin'}                      -- строит график для Lua функции, добавляет текст в легенду<br>
{'sin.dat', ln=1, lw=2}                      -- строит график для файла с учётом цвета и толщины маркеров<br>
{tbl, with='lines'}                          -- строит график для Lua таблицы с помощью линий<br>
title='Graph name'                           -- имя графика в целом<br>
xrange={0,10}                                -- диапазон x от 0 до 10<br>
yrange={-2,2}                                -- диапазон y<br>
zrange={0,5}                                 -- диапазон z<br>
trange={1,2}                                 -- изменение параметра в случае параметрической функции<br>
xtitle='A', ytitle='B'                       -- имена осей<br>
terminal='jpeg'                              -- сохранение результата в файл<br>
output='my_plot.jpg'                         -- имя файла для вывода результата<br>
parametric=true                              -- параметрическое представление функции<br>
size='square'                                -- установить квадратный размер изображения<br>
polar=true                                   -- график в полярных координатах<br>
grid='polar'                                 -- изменить тип сетки на полярный<br>
legend=false                                 -- отключить легенду<br>
surface=true                                 -- построение трёхмерного графика<br>
samples=200                                  -- задать число точек на графике<br>
raw='set pm3d'                               -- позволяет написать команды Gnuplot в явном виде<br>
<br>
<b>plot(x1,[y1,[nm,[x2,..]]])</b> - 'x' - список чисел, 'y' - список или функция, 'nm' - имя кривой.<br>
<b>polarplot(x1,y1,[nm,[x2,y2..]])</b> - График в полярных координатах. 'x' - список чисел, 'y' - список либо функция, 'nm' - имя кривой.<br>
<b>show(G)</b> - Строит график на основе параметров, представленных в виде таблицы Lua.<br>
<b>surfplot(x1,y1,fn1,[nm,[x2,y2..]])</b> - Построение поверхности. 'x' и 'y' - списки чисел, 'fn' - функция двух агрументов, 'nm' - имя поверхности.<br>
<b>tplot(t,[x,y1,y2..])</b> - Построение графика на основе таблицы, матрицы или файла. Опциональные элементы определяют необходимые столбцы.<br>
<b>tpolar(t,[x,y1,y2..])</b> - График в полярных координатах для таблицы, матрицы или файла. Опциональные элементы определяют стоблцы.<br>
<b>tsurf(t,[x1,y1,z1,z2..])</b> - Построение графика поверхности на основе таблицы, матрицы или файла. Опциональные элементы определяют необходимые столбцы.<br></p>
<pre class="example">

-- use 'gnuplot'
Gp = require 'lib.gnuplot'
Gp.testmode = true -- just for testing

-- simple plot 
t1 = {1,2,3,4,5}
t2 = {2,4,6,4,2}
-- in the dialog call "plot(t1,t2,'some curve')"
Gp.plot(t1,t2,'some curve')

-- simplified function plot
Gp.plot(t1, math.sin, 'sin')

-- name can be skipped 
Gp.plot(t1, math.sin, t1, math.cos)

-- plot table (or matrix, or datafile)
arr = {}
for i = 1,50 do 
  x = 0.1*i 
  arr[i] = {x, math.sin(x), math.cos(x)}
end
-- all columns by default (for table and matrix)
Gp.tplot(arr)

-- the same, but with explicit column specification
Gp.tplot(arr,1,2,3)

-- in polar coordinate system
Gp.polarplot(t1,t2,'some curve')

-- from table
Gp.tpolar(arr,1,2) 

-- plot surface
function fun(x,y) return x*x + y*y end
Gp.surfplot(t1,t2,fun,'some surf')

-- from table 
arr2 = {}
for _,v1 in ipairs(t1) do
  for _,v2 in ipairs(t2) do
    arr2[#arr2+1] = {v1,v2,fun(v1,v2)}
  end
end
Gp.tsurf(arr2)

-- direct use Gp object
a = Gp()
a:add {math.sin, title='sin'}
a:add {math.cos, title='cos'}
a:show()

-- additional parameters
a.xrange = {0,10}   -- add rangle
-- save to file 
a.terminal = 'png'
a.output = 'test.png'
a:show()

-- copy parameters to other object
b = a:copy()
print(b)

-- send 'raw' command to Gnuplot
c = Gp()
c.raw = 'plot x**2-2*x+1; set xlabel "X"; set ylabel "Y"'
c:show()

-- print Lua table
tmp = {
  {1,1},
  {2,2},
  {3,3},
  {4,4}
}
d = Gp()
d:add {tmp,with='lines'}
d:show()

-- define function
fn1 = function (x) return x^2-x end
f = Gp()
f:add {fn1,with='lines',title='x^2-x'}
f:show()

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Graph"></a>
<h3># Graph (graph) #</h3>
<p class="descript">Операции с графами.</p>
<p><b>Graph(t)</b> - Создает новый граф.<br>
<b>add(G,e)</b> - Добавляет узел (одиночное имя) или ребро. Ребро представлено списком, содержащим начало, конец и, при необходимости, вес (веса).<br>
<b>bfs(G,start,goal)</b> - Поиск в ширину. Возвращает флаг результата и найденный путь.<br>
<b>copy(G)</b> - Создаёт копию графа.<br>
<b>dfs(G,start,goal)</b> - Поиск в глубину. Возвращает флаг результата и найденный путь.<br>
<b>edges(G)</b> - Возвращает список рёбер.<br>
<b>isComplete(G)</b> - True если граф полный.<br>
<b>isDirected(G)</b> - True если граф направленный.<br>
<b>isNegative(G)</b> - True если граф содержит отрицательные веса.<br>
<b>isWeighted(G)</b> - True если граф взвешенный.<br>
<b>nodes(G)</b> - Возвращает список узвло графа.<br>
<b>pathBF(G,start[,goal])</b> - Поиск кратчайшего пути алгоритмом Беллмана-Форда. Возвращает таблицу расстояний и узлов. Если задана цель, возвращает путь и его длину.<br>
<b>pathD(G,start[,goal])</b> - Поиск кратчайшего пути алгоритмом Дейкстры. Возвращает таблицу расстояний и узлов. Если задана цель, возвращает путь и его длину.<br>
<b>remove(G,e)</b> - Удаляет узел или ребро. Узлы представляются именем, рёбра - двухэлементным списком.<br></p>
<pre class="example">

-- use 'graph'
Graph = require 'lib.graph'

-- build graph
-- single name - node, names in brackets - edges 
-- letter w denotes weight of non directed edge
-- numbers are weights of directed edges
a = Graph {'a','b',
  {'a','c'},
  {'d','e',w=2},
  {'d','b',4,3}
}

-- list of nodes
nd = a:nodes()
ans = #nd                     --> 5

-- list of edges
-- if an edge has different weight for different sizes
-- it is represented twice
ed = a:edges()
ans = #ed                     --> 4

-- has directed edges
ans = a:isDirected()          --> true

-- add node
a:add('h') 
-- add edge
a:add {'a','d'}
-- check size
-- (same as #a)
ans = a:size()                --> 6

-- remove edge
a:remove {'a','d'}
-- remove node
a:remove('a')
-- new edge number
ed = a:edges()
ans = #ed                     --> 3

-- directed edges
-- second way to define
-- from first to second node
a:add {'c','p',w12=2} 
-- and vise versa
a:add {'c','q',w21=3}
ed = a:edges()
ans = #ed                     --> 5

-- make copy
b = a:copy()

-- completeness 
ans = b:isComplete()          --> false

-- prepare graph
c = Graph {
  {'a','b'},
  {'a','c'},
  {'b','d'},
  {'b','e'},
  {'c','f'},
  {'f','g'},
  {'f','h'},
  {'e','g'}
}

-- is it weighted 
ans = c:isWeighted()          --> false

-- breadth first search
_,path = c:bfs('e','h')
ans = path[3]                 --> 'f'

-- depth first search
found,path = c:dfs('d','c')
ans = found                   --> true

-- update weight
-- (default is 1)
-- use 'add' for it
c:add{'a','b',w=0.5}
c:add{'b','e',w=0.4}
c:add{'c','f',w=2}

-- Dijkstra path search
dist,prev = c:pathD('a') 
ans = dist['g']               --> 1.9

-- Bellman-Ford path search
c:add{'f','h',w=-0.5}
dist,prev = c:pathBF('a')
ans = dist['h'] 

-- check negative edges
ans = c:isNegative()          --> true

-- show
print(b)

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Mat"></a>
<h3># Mat (matrix) #</h3>
<p class="descript">Операции с матрицами. На нулевые элементы память не расходуется. Индексация с единицы.</p>
<p><b>Mat(...)</b> - Создаёт матрицу на основе таблицы строк.<br>
<b>apply(fn,M1,M2,...)</b> - Применяет функцию к одной или нескольким матрицам.<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, a^b, -a<br>
<b>chol(M)</b> - Преобразование Холески для положительно определённой симметричной матрицы.<br>
<b>comparison</b> - a==b, a~=b<br>
<b>concat(M1,M2,dir)</b> - Объединяет две матрица горизонтально (dir='h') или вертикально (dir='v').<br>
Горизонтальная конкатенация доступна в виде M1 .. M2, а вертикальная - M1 // M2.<br>
<b>copy(M)</b> - Возвращает копию матрицы.<br>
<b>cross(V1,V2)</b> - Векторное произведение 3-элементных векторов.<br>
<b>det(M)</b> - Определитель матрицы.<br>
<b>diag(M[,n=0])</b> - Извлекает диагональные элементы либо формирует новую матрицу из вектора. n - индекс диагонали.<br>
<b>dot(V1,V2)</b> - Скалярное произведение 3-элементных векторов.<br>
<b>eye(rows[,cols=rows,init=1])</b> - Возвращает единичную матрицу. Диагональные элементы могут быть отличны от 1.<br>
<b>fill(rows,cols,fn)</b> - Генерирует матрицу на основе функции fn(строка,столбец).<br>
<b>inv(M)</b> - Обратная матрица.<br>
<b>lu(M)</b> - LU преобразование матрицы. Возвращает L,U и P.<br>
<b>map(M,fn)</b> - Формирует новую матрицу путём применения указанной функции к исходной. Функция может зависеть как от элементов, f(x) так и от индексов f(x,row,col).<br>
<b>norm(M)</b> - Евклидова норма.<br>
<b>ones(rows[,cols=rows,val=1])</b> - Формирует матрицу из единиц (или заданного числа).<br>
<b>pinv(M)</b> - Вовзращает псевдо-обратную матрицу.<br>
<b>rand(rows[,cols=rows])</b> - Создаёт матрицу случайных чисел от 0 до 1.<br>
<b>randi([M],N,[rows],[cols=rows])</b> - Создаёт матрицу случайных целых чисел от 1 до N. Возможен вызов в виде 'randi(M,N)' или 'randi(N,r,c)'.<br>
<b>randn(rows[,cols=rows])</b> - Возвращает матрицу нормально распределённых случайных чисел (с нулевым средним и единичной дисперсией).<br>
<b>rank(M)</b> - Возвращает ранг матрицы.<br>
<b>reshape(M,nRows[=size],nCols[=1])</b> - Изменение размера матрицы.<br>
<b>rref(M)</b> - Преобразование матрицы методом Гаусса.<br>
<b>size(M)</b> - Возвращает число строк и столбцов матрицы.<br>
<b>table(M)</b> - Преобразует матрицу в обыкновенную Lua таблицу.<br>
<b>tr(M)</b> - След матрицы.<br>
<b>transpose(M)</b> - Транспонирование матрицы. Эквивалентно T().<br>
<b>zeros(rows[,cols=rows])</b> - Формирует матрицу нулей.<br></p>
<pre class="example">

-- use 'matrix'
Mat = require 'lib.matrix'

-- define matrix objects
a = Mat {{1,2},{3,4}}
b = Mat {{5,6},{7,8}}
-- call in typical way
ans = a[2][2]                 --> 4 

b[1][1] = 5
-- transpose
c = a:T()
-- use () as alias for get()
ans = c(1,-1)                 --> 3

-- matrix rows and columns
_, ans = a:size()             --> 2

-- arithmetical operations
ans = a + b                   --> Mat {{6,8},{10,12}}

ans = b - a                   --> Mat {{4,4},{4,4}}

ans = a * b                   --> Mat {{19,22},{43,50}}

ans = a / b 
-- determinant
ans = ans:det()              --2> 1

-- multiply to scalar
ans = 2 * a                   --> Mat {{2,4},{6,8}}

-- add scalar (to all elements)
ans = a - 1                   --> Mat {{0,1},{2,3}}

ans = a ^ 2                   --> Mat {{7,10},{15,22}} 

-- determinant
ans = a:det()                 --> -2

-- inverse matrix
e = a:inv()
ans = e(2,1)                  --> 1.5

-- another call of inversion
e = a^-1
ans = e(2,1)                  --> 1.5

-- object copy
-- (it doesn't copy zeros)
f = a:copy()
ans = (f == a)                --> true

-- element-wise comparison
ans = (a == b)                --> false

-- identity matrix
ans = Mat.eye(2)              --> Mat {{1,0},
                                       {0,1}}

-- matrix argument
ans = Mat.eye(a)              --> Mat {{1,0},
                                       {0,1}}

-- matrix of zeros
ans = Mat.zeros(2,1)          --> Mat {{0},{0}}

-- matrix of constants = 4
ans = Mat.ones(2,3,4)         --> Mat {{4,4,4},
                                       {4,4,4}}

-- matrix of constants = 1
ans = Mat.ones(a,3)           --> Mat {{3,3},{3,3}}

-- define rule to fill
-- result matrix is 'dense'
fn = function (i,j) 
  return i == j and 1 or 0 
end
ans = Mat.fill(2,3,fn)        --> Mat {{1,0,0},
                                       {0,1,0}}

-- horizontal concatenation
ans = a .. b                  --> Mat {{1,2,5,6},
                                       {3,4,7,8}}

-- vertical concatenation
-- (a // b - for short)
ans = a:concat(b,'v')         --> Mat {{1,2},{3,4},{5,6},{7,8}}

-- apply function of 1 argument
ans = a:map(function (x) return x^2 end)       --> Mat {{1,4},{9,16}}

-- apply function which depends on index too
ans = a:map(function (x,r,c) return x-r-c end) --> Mat {{-1,-1},{-0,-0}}

-- apply function to matrices
-- element-wise
fn = function (x,y,z) return x*y+z end
aa = Mat.apply(fn, b,b,b) 
ans = aa[1][1]                --> 30

-- use Gauss transform to solve equation
ans = Mat.rref(a .. Mat{{5},{11}})             --> Mat {{1,0,1},
                                                        {0,1,2}}

-- create vector
ans = Mat.V {1,2,3}           --> Mat {{1},{2},{3}}

-- get submatrix
g = Mat {
  {1,2,3},
  {4,5,6},
  {7,8,9}
}
ans = g({2,-1},{2,3})         --> Mat {{5,6},
                                       {8,9}}

-- euclidean norm
ans = Mat.V({1,2,3}):norm()  --3> math.sqrt(14)

-- random matrix
h = Mat.rand(3,2)
print(h)

-- random integer matrix
-- from 1 to 20
print(h:randi(20))

-- random matrix with 
-- normal distribution
print(Mat.randn(2,2))

-- pseudo inverse matrix
m = Mat {
  {1,2},
  {3,4},
  {5,6}
}
n = m:pinv()
ans = n(2,2)                 --3> 0.333

-- copy as Lua table
-- (without methametods)
k = Mat.eye(3)
k = k:table()
ans = k[2][1]                 --> 0

-- make diagonal matrix
ans = Mat.diag({1,2,3})       --> Mat {{1,0,0},
                                       {0,2,0},
                                       {0,0,3}}

-- shifted diagonal
ans = g:diag(1)               --> Mat {{2},{6}}

-- cross-product of 2 vectors
x1 = Mat {{1,2,3}}
x2 = Mat {{4,5,6}}
ans = Mat.cross(x1,x2)        --> Mat {{-3},{6},{-3}}

-- dot product of 2 vectors
ans = Mat.dot(x1,x2)          --> 32

-- LU transform
l,u,p = b:lu()
ans = l[2][1]                --3> 0.714

-- Cholesky decomposition
m = Mat {{3,1},{1,3}}
m = m:chol()
ans = m[2][2]                --3> 1.633

-- matrix trace
ans = a:tr()                  --> 5

-- extract first row
m = a({},1)
-- vector doesn't need in 2 indices
ans = m(1)                    --> 1

-- extract last column
-- index can be negative 
m = a(-1,{})
ans = m:get(2)                --> 4

-- get rank
ans = Mat.ones(2,3):rank()    --> 1

-- change size
tmp = Mat{
  {1,2},
  {3,4},
  {5,6}
} 
ans = tmp:reshape(2,3)        --> Mat {{1,2,3},
                                       {4,5,6}}

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Num"></a>
<h3># Num (numeric) #</h3>
<p class="descript">Функции для численных расчётов. Все функции работают с точностью, определяемой параметром TOL.</p>
<p><b>Newton(fn,x0)</b> - Поиск корня методом Ньютона в окрестностях заданной точки.<br>
<b>TOL[=0.001]</b> - Точность решения.<br>
<b>der(fn,x)</b> - Оценка производной функции в точке.<br>
<b>ode45(fn,tDelta,y0[,param])</b> - Численное решение ОДУ.<br>
Первый параметр задаёт уравнение, второй - временной интервал, третий - начальное значение функции. Дополнительно можно определить такие параметры как шаг интегрирования и условие прерывания.<br>
Возвращает таблицу промежуточных точек и конечное значение yn.<br>
<b>solve(fn,a,b)</b> - Поиск корня уравнения fn(x)=0 на интервале [a,b].<br>
<b>trapez(fn,a,b)</b> - Интегрирование методом трапеций.<br></p>
<pre class="example">

-- use 'numeric'
Num = require 'lib.numeric'

-- define tolerance
Num.TOL = 1e-4
-- solve 'sin(x) = 0' for x in (pi/2...3*pi/2)
a = Num.solve(math.sin, math.pi*0.5, math.pi*1.5)
ans = a                      --3> math.pi

-- Newton method
-- only one initial value
d = Num.Newton(math.sin, math.pi*0.7)
ans = d                      --3> math.pi

-- numeric derivative
b = Num.der(math.sin, 0)
ans = b                      --0> 1

-- numeric integral
c = Num.trapez(math.sin, 0, math.pi)
ans = c                      --0> 2

-- solve ODE x*y = x'
-- for x = 0..3, y(0) = 1
-- return table of solutions and y(3)
tbl, yn = Num.ode45(function (x,y) return x*y end, 
                    {0,3}, 1)
ans = yn                     --2> 90.011

-- use matrices for high order equations
Mat = require 'lib.matrix'

-- y''-2*y'+2*y = 1
-- represent as: x1 = y, x2 = y'
-- so: x1' = x2, x2' = 1+2*x2-2*x1
myfun = function (t,x) 
  return Mat.V {x(2), 1+2*x(2)-2*x(1)}
end
_, xn = Num.ode45(myfun, {0,2}, Mat.V{3,2}, {dt=0.2}) 
ans = xn(1)                  --2>  -10.54

-- define exit condition
-- from time, current and previous results
cond = function (time,current,previous) 
  return current < 0.1 
end
myfun = function (t,x) return -x end
y = Num.ode45(myfun, {0,1E2}, 1, {exit=cond})
ans = y[#y][1]               --2> 2.56

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Poly"></a>
<h3># Poly (polynom) #</h3>
<p class="descript">Действия над полиномами.</p>
<p><b>Poly(...)</b> - Создаёт полином на основе списка коэффициентов.<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, a^n, -a<br>
<b>build(root1,root2,...)</b> - Строит полином на основе списка корней.<br>
<b>comparison</b> - a==b, a~=b<br>
<b>copy(P)</b> - Возвращает копию полинома.<br>
<b>der(P)</b> - Первая производная полинома.<br>
<b>fit(X,Y,ord)</b> - Аппроксимация точек полиномом заданной степени.<br>
<b>int(P[,x0=0])</b> - Первообразная полинома, x0 - свободный коэффициент.<br>
<b>real(p)</b> - Возвращает список действительных корней полинома.<br>
<b>val(P,x)</b> - Вычисляет значение полинома в заданной точке. Эквивалентно вызаву P(x).<br></p>
<pre class="example">

-- use 'polynom'
Poly = require 'lib.polynom'

-- coefficients in ascendant order
a = Poly {1,2,4,3}
b = Poly {1,1}  
-- polynomial value for x=0
ans = a:val(0)                --> 3

-- simplified call
ans = a(0)                    --> 3

-- arithmetic
ans = a + b                   --> Poly {1,2,5,4}

ans = a - b                   --> Poly {1,2,3,2}

ans = b * b                   --> Poly {1,2,1}

ans = a / b                   --> Poly {1,1,3}

ans = a % b                   --> Poly {0}

ans = b ^ 3                   --> Poly {1,3,3,1}

-- integration
-- free coefficient is 0
ans = b:int()                 --> Poly {0.5,1,0}

-- derivative
ader = a:der()
-- and its value for x=1
ans = ader(1)                 --> 11

-- build polynomial using roots
ans = Poly.build(1,-1)        --> Poly {1,0,-1}

-- make copy and compare
c = a:copy()
ans = (a == c)                --> true

-- not equal
ans = (b == c)                --> false

-- find real roots
e = a:real()
ans = e[1]                   --1> -1.00

-- fit curve with polynomial
-- of order 2
A={0,1,2,3}
B={-3,2,11,24}
p = Poly.fit(A,B,2)
ans = p(10)                  --0> 227.0

-- simple print
print(a)

-- human-friendly print
-- with variable 's' (default is 'x')
d = Poly {2,-2,1}
ans = d:str('s')              --> '2*s^2 -2*s +1'

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Quat"></a>
<h3># Quat (quaternion) #</h3>
<p class="descript">Операции над кватернионами.</p>
<p><b>Quat(t={0,0,0,0})</b> - Определение кватерниона через таблицу коэффициентов.<br>
<b>abs(Q)</b> - Норма кватерниона.<br>
<b>arithmetic</b> - a + b, a - b, a * b, a ^ k, -a<br>
<b>comparison</b> - a == b, a ~= b<br>
<b>conj(Q)</b> - Сопряжённый кватернион.<br>
<b>copy(t)</b> - Возвращает копию кватерниона.<br>
<b>fromAA(fAng,vAxe)</b> - Возвращает кватернион для заданного угла и оси вращения.<br>
<b>fromRot(M)</b> - Строит кватернион на основе угла поворота и оси вращения.<br>
<b>imag(Q)</b> - Возвращает таблицу мнимых элементов кватерниона.<br>
<b>inv(Q)</b> - Возвращает крватернион, обратный к данному.<br>
<b>mat(Q)</b> - Представление в виде эквивалентной матрицы.<br>
<b>normalize(Q)</b> - Приводит кватернион к единичной форме.<br>
<b>real(Q)</b> - Действительная часть (эквивалентно Q.w).<br>
<b>rotate(Q,vec)</b> - Возвращает вектор, полученный при вращении с помощью заданного кватерниона.<br>
<b>slerp(Q1,Q2,t)</b> - Сферическая линейная интерполяция двух кватернионов.<br>
<b>toAA(Q)</b> - Возвращает угол поворота и ось вращения.<br>
<b>toRot(Q)</b> - Возвращает эквивалентную матрицу вращения.<br></p>
<pre class="example">

-- use 'quaternion'
Quat = require 'lib.quaternion'

-- new quaternion
-- set {w,i,j,k}
a = Quat {1,2,3,4}
-- part of elements
b = Quat {w=3, i=4}
ans = b                       --> Quat{3,4,0,0}

-- conjugation
ans = a:conj()                --> Quat{1,-2,-3,-4}

-- norm
ans = b:abs()                --1> 5.000

-- inversion
c = a*a:inv()
ans = c.w                    --1> 1.000

-- arithmetic
ans = a+b                     --> Quat{4,6,3,4}

ans = a*b                     --> Quat{-5,10,25}

ans = 3*b                     --> Quat{9,12,0,0}

-- power
ans = b^3                     --> b * b * b

-- unit quaternion
a:normalize()
ans = a:abs()                --1> 1.000

-- unit power
aa = a^1.5
ans = aa.i                   --3> 0.324

ans = aa.j                   --3> 0.486

ans = aa.k                   --3> 0.648

-- rotation matrix
m = a:toRot()
d = Quat.fromRot(m)
ans = Quat.abs(d-a)          --1> 0.000

-- use angle 
-- and axis
ang = 0.5
axis = {1,1,1}
f = Quat.fromAA(ang,axis)
ans,_ = f:toAA()             --3> ang

-- rotate vector
p = a:rotate({1,0,0})
ans = p[1]                   --3> -0.667

-- spherical interpolation
d = Quat.slerp(a,b,0.5)
ans = d.w                    --3> 0.467

-- make copy
ans = d:copy()                --> d

-- show 
print(d)

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Rat"></a>
<h3># Rat (rational) #</h3>
<p class="descript">Операции с числами, представленными в виде дроби.</p>
<p><b>De(R)</b> - Возвращает знаменатель.<br>
<b>Nu(R)</b> - Возвращает числитель.<br>
<b>Rat(m[,n=1])</b> - Для создания рационального числа укажите числитель и (опционально) знаменатель.<br>
<b>arithmetic</b> - R1+R2, R1-R2, R1*R2, R1/R2, -R, R1^R2} <br>
<b>comparison</b> - R1<R2, R1<=R2, R1>R2, R1>=R2, R1==R2, R1~=R2<br>
<b>copy(R)</b> - Возвращает копию рационального числа.<br>
<b>gcd(a,b)</b> - Наибольший общий делитель.<br>
<b>val(R)</b> - Представление рационального числа в десятичном виде.<br></p>
<pre class="example">

-- use 'rational'
Rat = require 'lib.rational'

-- numerator, denominator
a = Rat(1,2)
-- only numerator
b = Rat(2)
ans = b                       --> Rat(2,1)

-- simplification
k = 234781
ans = Rat(2*k,3*k)            --> Rat(2,3)

-- arithmetic
ans = a + b                   --> Rat(5,2)

ans = 2 * a                   --> Rat(1)

ans = Rat(2,3)*Rat(3,2)       --> Rat(1)

ans = a / Rat(1,3)            --> Rat(3,2)

ans = a ^ 3                   --> Rat(1,8)

ans = 2 ^ a                  --3> 1.414

-- comparison
ans = (b == b)                --> true

ans = (a >= b)                --> false

-- greatest common division
ans = Rat.gcd(125,65)         --> 5

-- represent as decimal
ans = a:val()                 --> 0.5

-- numerator
ans = b:Nu()                  --> 2

-- denominator
ans = b:De()                  --> 1

-- make copy
ans = a:copy()                --> a

-- show
print(a)

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Spec"></a>
<h3># Spec (special) #</h3>
<p class="descript">Специальные функции.</p>
<p><b>besseli(n,x)</b> - Модифицированная функция Бесселя In(x).<br>
<b>besselj(n,x)</b> - Функция Бесселя первого рода.<br>
<b>besselk(n,x)</b> - Модифицированная функция Бесселя Kn(x).<br>
<b>bessely(n,x)</b> - Функция Бесселя второго рода.<br>
<b>beta(z,w)</b> - Бета-функция.<br>
<b>betainc(x,a,b)</b> - Неполная бета-функция Ix(a,b).<br>
<b>betaln(z,w)</b> - Натуральный логарифм бета-функции.<br>
<b>dawson(x)</b> - Интеграл Доусона.<br>
<b>erf(x)</b> - Функция ошибки.<br>
<b>erfc(x)</b> - Дополнительная функция ошибки.<br>
<b>expint(n,x)</b> - Экспоненциальный интеграл En(x).<br>
<b>gamma(z)</b> - Гамма-функция.<br>
<b>gammainc(x,a[,type='lower')</b> - Неполная гамма-функция, P (lower - нижняя) или Q (upper - верхняя).<br>
<b>gammaln(z)</b> - Натуральный логарифм гамма-функции.<br>
<b>gammp(a,x)</b> - Неполная гамма-функция P(a,x).<br>
<b>gammq(a,x)</b> - Неполная гамма-функция Q(a,x) = 1-P(a,x).<br>
<b>legendre(n,x)</b> - Список коэффициентов полиномов Лежандра.<br></p>
<pre class="example">

-- use 'special'
Spec = require 'lib.special'

-- beta functions
ans = Spec.beta(3,4) * 1E2   --3> 1.667

ans = Spec.betaln(10,20)     --3> -19.115

ans = Spec.betainc(0.5, 2, 3.3)  --3> 0.7309

-- error functions
ans = Spec.erf(1)            --3> 0.8427

ans = Spec.erfc(0.5)         --3> 0.4795

-- Ei(x)
ans = Spec.expint(3.3) * 1E3     --3> 8.939

-- E3(x)
ans = Spec.expint(2, 5) * 1E4    --3> 9.965

-- gamma functions
ans = Spec.gamma(-1.5)       --3> 2.3633

ans = Spec.gammaln(100)      --3> 359.1342

ans = Spec.gammp(7.7, 2.3) * 1E3 --2> 3.85

ans = Spec.gammq(1.5, 4.8) * 1E2 --2> 2.23

-- another syntax
ans = Spec.gammainc(2.1, 0.3, 'upper') * 1E2 --3> 1.942

-- Bessel functions
ans = Spec.besselj(3, 1.5) * 1E2 --3> 6.096

ans = Spec.bessely(4, 0.8)   --3> -78.751

ans = Spec.besseli(2, -3.6)  --3> 4.254

ans = Spec.besselk(5, 5) * 1E2   --3> 3.2706

-- Legendre function
lst = Spec.legendre(3, 0.5)
ans = lst[1]                 --3> -0.4375

-- Dawson function
ans = Spec.dawson(3.3)       --3> 0.1598

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Stat"></a>
<h3># Stat (stat) #</h3>
<p class="descript">Статистические вычисления. Исходные данные представлены в виде Lua таблиц.</p>
<p><b>freq(t)</b> - Возвращает таблицу частот элементов.<br>
<b>geomean(t[,w])</b> - Геометрическое среднее.<br>
<b>harmmean(t[,w])</b> - Гармоническое среднее.<br>
<b>histcounts(X[,rng=10])</b> - Распределение данных по интервалам. Можно указать число интервалов разбиения, либо задать границы в виде таблицы.<br>
<b>max(t)</b> - Максимальный элемент и его индекс.<br>
<b>mean(t[,w])</b> - Вычисляет среднее значение.<br>
<b>median(t)</b> - Медиана списка.<br>
<b>min(t)</b> - Возвращает наименьший элемент и его индекс.<br>
<b>moment(n,x[,p])</b> - Центральный момент x порядка n (с весами p).<br>
<b>std(t[,w])</b> - Возвращает математическое ожидание и дисперсию.<br>
<b>sum(t)</b> - Возвращает сумму элементов.<br>
<b>tcdf(x,nu)</b> - Распределение Стьюдента.<br>
<b>tpdf(x,nu)</b> - Плотность распределения Стьюдента.<br></p>
<pre class="example">

-- use 'stat'
Stat = require 'lib.stat'

-- initial data (tables)
X = {3,2,5,6,3,4,3,1}
w = {1,1,0,1,2,2,1,1}
-- average
ans = Stat.mean(X)           --3> 3.375

-- standard deviation
ans, tmp = Stat.std(X,W)     --3> 1.495

-- variance
ans = tmp                    --3> 2.234

-- maximum element and index
_,ans = Stat.max(X)           --> 4 

-- median
ans = Stat.median(X)          --> 3

-- table of frequencies
tmp = Stat.freq(X)
ans = tmp[3]                  --> 3

-- central moment
ans = Stat.moment(2,X)       --3> 2.234

-- summ of elements
ans = Stat.sum(X)             --> 27

-- minimum value
ans = Stat.min(X)             --> 1

-- geometrical mean
ans = Stat.geomean(X)        --3> 2.995

-- harmonic mean
ans = Stat.harmmean(X,W)     --3> 2.567

-- find histogram
a,b = Stat.histcounts(X, 3)
ans = b[1]                    --> 1

-- define edges 
a,b = Stat.histcounts(X,{0,4,7})  
ans = a[1]                    --> 5 

-- Student cdf and pdf
ans = Stat.tcdf(4, 2.5)      --3> 0.9805

ans = Stat.tpdf(2, 3.3)      --3> 0.0672

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Unit"></a>
<h3># Unit (units) #</h3>
<p class="descript">Операции с единицами измерения.</p>
<p><b>Unit(v[,u])</b> - Создание числа и/или единиц измерения.<br>
<b>add(U,rule)</b> - Добавление нового правила преобразования единиц измерения.<br>
<b>arithmetic</b> - U1+U2, U1-U2, U1*u2, U1/U2, U1^n<br>
<b>comparison</b> - U1==U2, U1~=U2, U1<U2, U1<=U2, U1>U2, U1>=U2<br>
<b>convert(v, units)</b> - Преобразование между единицами измерения, функция возвращает новый объект или nil.<br>
<b>copy(U)</b> - Создание копии объекта с его единицами измерения.<br>
<b>prefix</b> - Таблица дольных и кратных приставок.<br></p>
<pre class="example">

-- use 'units'
Unit = require 'lib.units'

-- add some rules
Unit.add('h', Unit(60,'min'))
Unit.add('min', Unit(60,'s'))

-- define variable
a = Unit(1,'m/s')
-- convert to km/h, get only value
ans = a['km/h']               --> 3.6

-- get numerical value
-- (the save as #a)
ans = a:val()                 --> 1

-- make copy
cp = a:copy() 
ans = cp                      --> Unit(1,'m/s')

-- get converted variable
b = a:convert('km/h')
ans = b                       --> Unit(3.6, 'km/h')

-- arithmetic
b = 3 * b
ans = a + b                   --> Unit(4, 'm/s')

ans = b - a                   --> Unit(2, 'm/s')

ans = a * b                   --> Unit(3, 'm^2/s^2')

ans = b / a                   --> Unit(3)

ans = (a < b)                 --> true

ans = b ^ 3                   --> Unit(27, 'm^3/s^3')

-- new rule
Unit.add('snake', Unit(48, 'parrot'))
-- define variable
c = Unit(2,'snake')
-- convert
ans = c['parrot']             --> 96

-- convert using prefix
ans = c['ksnake']             --> 0.002

-- complex rule
d = Unit(1,'W')
-- define function for conversation, apply it
lg = function (x) 
  return math.log(x)/math.log(10) 
end
e = d:convert(function (x) 
  return Unit( 10*lg((x/Unit('mW')):simp()), 'dBm') 
end)
ans = #e                     --0> 30

-- another definition syntax
ans = 2 * Unit('N')           --> Unit(2,'N')

-- show result
print(a)
--</pre>
<a href="#Top">Top</a></div>
<div><p align="center"><i>2021, Stanislav Mikhel</i></p></div>
</body></html>