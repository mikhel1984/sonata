<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Sonata Help</title>
</head><body>
<style type="text/css">
H3 {text-align:center;}
P {line-height:1.3;}
UL {column-count: 4; border: 2px solid blue; border-radius: 5px; padding: 5px 5px 5px 30px;}
DIV {margin-left: 10px;}
.EXAMPLE {border: 2px solid blue; border-radius: 5px; background: lightgrey; padding: 15px; margin: 10px 0px; color:navy; }
.DESCRIPT {text-align:center; font-style:italic; }
</style>
<a name="Top"></a>
<div><h1 align="center">Sonata Lua Calculus</h1>
<ul>
<li><a href="#Arr">array</a></li>
<li><a href="#Ap">asciiplot</a></li>
<li><a href="#Int">bigint</a></li>
<li><a href="#_Z">complex</a></li>
<li><a href="#_C">const</a></li>
<li><a href="#_D">data</a></li>
<li><a href="#Geo">geodesy</a></li>
<li><a href="#Gp">gnuplot</a></li>
<li><a href="#Graph">graph</a></li>
<li><a href="#Lens">lens</a></li>
<li><a href="#Main">main</a></li>
<li><a href="#Mat">matrix</a></li>
<li><a href="#Num">numeric</a></li>
<li><a href="#Poly">polynomial</a></li>
<li><a href="#Quat">quaternion</a></li>
<li><a href="#Rat">rational</a></li>
<li><a href="#Spec">special</a></li>
<li><a href="#Sym">symbolic</a></li>
<li><a href="#Unit">units</a></li>
</ul></div>
<div><h3># About #</h3>
<p><br>
'Sonata' is a Lua based program for mathematical calculations.<br>
<br>
<b>USAGE</b>:<br>
	lua [-i] sonata.lua [flag] [arg1 arg2 ...]<br>
(option '-i' can be used for working in native Lua interpreter)<br>
<br>
<b>FLAGS</b>:<br>
	-h	Get this help message.<br>
	-e	Evaluate command line expression.<br>
		e.g. -e "2+2"<br>
<br>
	--test	Apply the unit tests to the desired module. Call all modules if the name is not defined.<br>
		e.g. --test array<br>
	--doc	Creating/updating a documentation file.<br>
		e.g. --doc ru<br>
	--lang	Creating/updating a file for localization.<br>
		e.g. --lang eo<br>
	--new	Create template file for a new module.<br>
		e.g. --new  matrices  Mat  "Matrix operations."<br>
	 No flag  - Evaluate file(s).<br>
<br>
<b>VERSION</b>: 0.9.32<br>
<br>
<b>MODULES</b>: graph, rational, polynomial, complex, bigint, geodesy, asciiplot, special, matrix, const, array, gnuplot, data, quaternion, lens, numeric, symbolic, main, units.<br>
<br>
<b>BUGS</b>: mail to 'mikhel.sk@gmail.com'<br>
</p>
<p><a href="https://github.com/mikhel1984/sonata/wiki">Project Wiki</a></p></div>
<div><a name="Arr"></a>
<h3># Arr (array) #</h3>
<p class="descript">Manipulations with arrays of elements. Indices have form of tables. Indexation from 1.</p>
<p><b>Arr {n1,n2,..}</b> - Create empty array with the given size.<br>
<b>Arr:zip(fn, ...)</b> - Apply function of several arguments. Return new array.<br>
<b>capacity()</b> - Maximal number of elements in the array. The same as #A.<br>
<b>comparison</b> - a == b, a ~= b<br>
<b>concat(A,iAxis)</b> - Concatenate along the given array along the given axis.<br>
<b>copy()</b> - Get copy of the array.<br>
<b>dim()</b> - Return size of the array.<br>
<b>get(tInd)</b> - Get array element.<br>
<b>ipairs()</b> - Return iterator along all indexes.<br>
<b>isEqual(A)</b> - Check size equality.<br>
<b>map(fn)</b> - Apply function fn(x,[ind]) to all elements, return new array.<br>
<b>set(tInd,v)</b> - Set value to the array.<br>
<b>sub(tInd1,tInd2)</b> - Return sub array restricted by 2 indexes.<br></p>
<pre class="example">

-- use 'array'
Arr = require 'lib.array'

-- empty array
a = Arr {2,3,4}
ans = a:get{1,2,1}            --> nil

-- set values
a:set({1,2,1},4)
ans = a:get{1,2,1}            --> 4

-- random array
rnd = function () return math.random() end
b = Arr{5,2,1}:map(rnd)
-- max number of elements
ans = #b                      --> 10

-- compare sizes
ans = b:isEqual(Arr{5,2,1})   --> true

-- compare elements
ans = (b == b:copy())         --> true

-- get sub array
g = a:sub({1,1,1},{-1,-1,2})
ans = g:isEqual(Arr{2,3,2})   --> true

-- apply function with indeces
eye = function (x,t) return (t[1]==t[2] and t[1]==t[3]) and 1 or 0 end
f = Arr{3,3,3}:map(eye)
ans = f:get{2,2,2}            --> 1

-- apply function of several arguments
a1 = Arr{2,2}:map(rnd)
a2 = Arr{2,2}:map(rnd)
a3 = Arr{2,2}:map(rnd)
-- 'lazy' function definition
a4 = Arr:zip('x1*x2+x3', a1,a2,a3)
ans = a4:get{1,2}             --> a1:get{1,2}*a2:get{1,2}+a3:get{1,2}

-- iterate over array
g = Arr {2,2}
g:set({1,1}, 1)
g:set({2,1}, 2)
g:set({1,2}, 3)
g:set({2,2}, 4)
-- show
for ind, val in g:ipairs() do
  io.write('{',ind[1],',',ind[2],'}\t',val, '\n')
end

-- simple iteration
n = g:capacity()   -- number of elements
for i = 1,n do
  io.write(i,':',g[i],'\n')
end

-- concatenate along the 3-rd axes
d = b:concat(b,3)
-- size for given dimension
ans = d:dim()[3]              --> 2

-- simple print
print(a)

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Ap"></a>
<h3># Ap (asciiplot) #</h3>
<p class="descript">Use pseudography for data visualization.</p>
<p><b>Ap([iWidth=75,iHeight=23])</b> - Create new asciiplot.<br>
<b>Ap:concat(...)</b> - Horizontal concatenation of figures with the same height. For two object operator '..' can be used.<br>
<b>addPoint(dx,dy,s)</b> - Add point (dx,dy) using char 's'.<br>
<b>addPose(ir,ic,s)</b> - Add character s to the given position.<br>
<b>addString(ir,ic,s)</b> - Set string from the given position.<br>
<b>bar(t,[vy=2,ix=1])</b> - Plot bar diargram for data. vy can be y index in t (optional) or table of y-s.<br>
<b>contour(F,fn,[{view='XY'}])</b> - Find contours of projection for a function fn(x,y).<br>
<b>copy()</b> - Create a copy of the object.<br>
<b>plot(...)</b> - Plot arguments in form 't', 't1,t1', 'fn,nm', 'fn1,fn2' etc.<br>
<b>reset()</b> - Prepare a clear canvas.<br>
<b>scale(factor,[bDefault=false])</b> - Change figure size w.r.t. initial size.<br>
<b>tplot(t,[{yfix=false}])</b> - Plot the table data, choose columns if need.<br></p>
<pre class="example">

-- use 'asciiplot'
Ap = require 'lib.asciiplot'

-- figure with default size
fig1 = Ap()
print(fig1.width, fig1.height)

-- print functions
fig1.xrange = {-3.14, 3.14}   -- default is (-1,1)
fig1:plot(math.sin, 'sin', math.cos, 'cos')
fig1.title = 'Trigonometry'
print(fig1)

-- print data
x = {1,2,3,4,5}
y = {1,3,5,7,9}
print(fig1:plot(x,y))

-- combine different sources
fig1.yaxis = 'L'  -- left axis
fig1:plot(x,'single',x,y,'pair',math.log, 'function')
print(fig1)

-- define arbitrary figure size
-- odd is preferable
fig2 = Ap(21,11)    -- width=21, height = 11
print(fig2:plot(function (x) return 2*x end))

-- show table
tbl = {}
for x = 0, 3, 0.1 do
  --             x      y1          y2
  tbl[#tbl+1] = {x, math.sin(x), math.cos(x)}
end
fig2.xaxis = 'D'  -- down
print(fig2:tplot(tbl))

-- plot only y2, don't rescale
fig2.xrange = {-1, 4}
fig2.yrange = {0, 1}
print(fig2:tplot(tbl, {2, yfix=true}))

-- scale figure w.r.t. initial size
fig1:scale(0.8)
ans = fig1.width             --> 61

-- horizontal concatenation
-- first
fig1:scale(0.5, true)
fig1.xrange = {0, 1.57}
fig1.yaxis = 'C'; fig1.xaxis = 'D'
fig1:plot(sin, 'sin')
fig1.title = 'First'
-- second
fig2:scale(0.5, true)
fig2.xrange = {0, 1.57}
fig2:plot(cos, 'cos')
fig2.title = 'Second'
print(Ap:concat(fig1, fig2))   -- similar to fig1..fig2 for 2 objects

-- call 'API' functions
fig3 = Ap():scale(0.5)
fig3.xrange = {-2,2}
fig3.yrange = {-1,4}
-- no axes and limits
fig3.xaxis = nil; fig3.yaxis = nil
fig3:reset()
-- set function
for x = -1.2, 1.2, 0.1 do
  fig3:addPoint(x, x*x-0.5, Ap.char[1])
end
-- set to position
fig3:addPose(3, 13, '#')   -- characters
fig3:addPose(3, 24, '#')
fig3:addString(2,3,'Hi!')  -- text
print(fig3)

-- print surface contours
fig4 = Ap()
fig4.xrange = {-5, 5}
fig4.yrange = {-5, 5}
print(fig4:contour(function (x,y) return x*x - y*y end))

-- bar diagram
data = {}
k = 2*3.14/20
for i = 1, 20 do data[#data+1] = {k*i, math.sin(k*i)} end
fig5 = Ap()
print(fig5:bar(data))

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Int"></a>
<h3># Int (bigint) #</h3>
<p class="descript">Operations with arbitrary long integers.</p>
<p><b>Int(v)</b> - Create number from integer, string or table.<br>
<b>Int:random(B)</b> - Generate pseudo-random value from 0 to B.<br>
<b>abs()</b> - Return module of arbitrary long number.<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, a%b, a^b, -a, #a<br>
<b>at(N)</b> - Get N-th digit.<br>
<b>base()</b> - Current numeric base.<br>
<b>comparison</b> - a<b, a<=b, a>b, a>=b, a==b, a~=b<br>
<b>eq(B)</b> - Check equality with the second value.<br>
<b>fact()</b> - Return factorial of non-negative integer B.<br>
<b>factorize()</b> - Find the list of multipliers.<br>
<b>float()</b> - Represent current big integer as number if it possible.<br>
<b>gcd(B)</b> - Find the greatest common divisor for two integers.<br>
<b>isPrime([sMethod])</b> - Check if the number is prime. Set 'Fermat' method to use the small Fermat theorem.<br>
<b>rebase(N)</b> - Convert number to the new numeric base.<br></p>
<pre class="example">
-- use 'bigint'
Int = require 'lib.bigint'

-- from integer
a = Int(123)
ans = a:float()               --> 123

-- from string
b = Int('456')
ans = b:float()               --> 456

-- from table
-- 'sign' and 'base' can be skipped
g = Int {1,2,3,sign=-1,base=10}
ans = g:float()               --> -123

-- check equality
ans = (a == -g)               --> true

-- arithmetical operations
ans = (a+b):float()           --> 579

ans = (a-b):float()           --> -333

ans = (a*Int(2)):float()      --> 246

ans = (b/2):float()           --> 228

ans = (b%a):float()           --> 87

ans = (a^3):float()           --> 1860867

-- absolute value
ans = Int('-25'):abs():float()  --> 25

-- factorial
c = Int(10):fact()
ans = c:float()               --> 3628800

ans = (a > b)                 --> false

-- compare with number
ans = a:eq(123)               --> true

-- number of digits
ans = #a                      --> 3

-- 2nd digit (from the lowest)
ans = a:at(2)                 --> 2

-- get numeric base
ans = g:base()                --> 10

-- change numeric base
v = g:rebase(60)
ans = tostring(v)             --> '-2|3'

-- operations with different bases
-- transform to the biggest common base
w = v + b
ans = tostring(w)             --> '5|33'

-- comparison
ans = (v == g)                --> true

-- simple print
print(a)

-- check if it prime
-- iterate though multipliers
ans = Int(1229):isPrime()       --> true

-- Fermat theorem
ans = Int(1229):isPrime('Fermat') --> true

-- factorize
t = b:factorize()
ans = #t                      --> 5

-- check factorization
ans = 1
for i = 1,#t do
  ans = ans * (t[i]:float())
end                           --> 456

-- pseudo-random number
-- from 0 to b
print(Int:random(b))

-- greatest common divisor
ans = a:gcd(b):float()        --> 3

-- with numbers
-- result is bigint
ans = a + 1.0                 --> Int(124)

-- result is float
ans = a - 0.5                 --> 122.5

--</pre>
<a href="#Top">Top</a></div>
<div><a name="_Z"></a>
<h3># _Z (complex) #</h3>
<p class="descript">Manipulations with complex numbers.</p>
<p><b>_Z([vRe=0,vIm=0])</b> - Create new complex number.<br>
<b>_Z:i([v=1])</b> - Return v*i.<br>
<b>_Z:trig(vModule,vAngle)</b> - Create complex number using module and angle.<br>
<b>abs()</b> - Return module of complex number.<br>
<b>acos()</b> - Complex inverse cosine.<br>
<b>acosh()</b> - Complex inverse hyperbolic cosine.<br>
<b>arg()</b> - Return argument of complex number.<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, a^b, -a<br>
<b>asin()</b> - Complex inverse sine.<br>
<b>asinh()</b> - Complex inverse hyperbolic sine.<br>
<b>atan()</b> - Complex inverse tangent.<br>
<b>atanh()</b> - Complex inverse hyperbolic tangent.<br>
<b>comparison</b> - a==b, a~=b<br>
<b>conj()</b> - Return the complex conjugate. Equal to ~C.<br>
<b>cos()</b> - Return cosine of a complex number.<br>
<b>cosh()</b> - Return hyperbolic cosine of a real or complex number.<br>
<b>exp()</b> - Return exponent in for complex argument.<br>
<b>im()</b> - Get imaginary part.<br>
<b>log()</b> - Complex logarithm.<br>
<b>re()</b> - Get real part.<br>
<b>round([N=6])</b> - Round in-place to specified number of digits.<br>
<b>sin()</b> - Return sinus of a complex number.<br>
<b>sinh()</b> - Return hyperbolic sinus of a complex number.<br>
<b>sqrt()</b> - Return square root. Result can be real of complex.<br>
<b>tan()</b> - Return tangent of a complex number.<br>
<b>tanh()</b> - Return hyperbolic tangent of a complex number.<br></p>
<pre class="example">

-- use 'complex'
_Z = require 'lib.complex'

-- real and imaginary pars
a = _Z(1,2)
-- or just imaginary
b = _Z(0,3)

-- imaginary unit
ans = 3+_Z:i(4)                --> _Z(3,4)

-- use trigonometrical form
ans = _Z:trig(2,0)            --> _Z(2,0)

-- arithmetic
ans = a + b                   --> _Z(1,5)

ans = _Z:i(3) - b             --> 0

ans = a * b                   --> _Z(-6,3)

ans = a / _Z:i()              --> _Z(2,-1)

-- power can be complex
c = _Z(1,1)^_Z(2,-2)

-- real part
ans = c:re()                 --3> 6.147

-- imaginary part
ans = c:im()                 --1> 7.4

-- comparison
ans = (a == b)                --> false

ans = (a ~= b)                --> true

-- absolute value
ans = a:abs()                --3> 2.236

-- argument
ans = a:arg()              --3> 1.107

-- conjugated number
ans = a:conj()                --> _Z(1,-2)

-- some functions after import
-- become default, such as
d = _Z(-2):sqrt()
ans = d:im()                  --3> 1.414

-- exp
ans = d:exp():re()            --3> 0.156

-- log
ans = d:log():re()            --3> 0.3465

-- sin
ans = d:sin():im()            --3> 1.935

-- cos
ans = d:cos():re()            --3> 2.178

-- tan
ans = d:tan():re()            --1> 0

-- sinh
ans = d:sinh():re()           --1> 0

-- cosh
ans = d:cosh():re()           --3> 0.156

-- tanh
ans = d:tanh():im()           --3> 6.334

-- asin
z = _Z(2,3)
ans = z:asin():im()          --3> 1.983

-- acos
ans = z:acos():re()          --2> 1.000

-- atan
ans = z:atan():im()          --3> 0.229

-- asinh
ans = z:asinh():re()         --3> 1.968

-- acosh
ans = z:acosh():im()         --1> 1.000

-- atanh
ans = z:atanh():re()         --3> 0.146

-- round in-place
z = _Z(1+1E-3, 2+1e-20)
z = z:round(5)
ans = z:re()                 --3> 1.001

ans = z:im()                  --> 2

-- show
print(a)

--</pre>
<a href="#Top">Top</a></div>
<div><a name="_C"></a>
<h3># _C (const) #</h3>
<p class="descript">Collection of constants.</p>
<p><b>_C:add(sName,value,[sUnits])</b> - Create new constant.<br>
<b>_C:remove(sName)</b> - Delete user-defined constant.<br>
<b>astro.au</b> - Astronomic unit.<br>
<b>astro.ly</b> - One light year.<br>
<b>astro.pc</b> - One parsec.<br>
<b>math.e</b> - Base of the natural logarithm.<br>
<b>math.phi</b> - Golden ratio.<br>
<b>math.pi</b> - Ratio of a circle's circumference to its diameter.<br>
<b>phi.Da</b> - Unified atomic mass unit.<br>
<b>phy.G</b> - Gravitational constant.<br>
<b>phy.NA</b> - Avogadro's number.<br>
<b>phy.R</b> - Universal gas constant.<br>
<b>phy.Rinf</b> - Rydberg constant.<br>
<b>phy.Vm</b> - Volume of one mole of ideal gas.<br>
<b>phy.c</b> - Speed of light.<br>
<b>phy.e</b> - Electron charge.<br>
<b>phy.eps0</b> - Permittivity of free space.<br>
<b>phy.g</b> - Acceleration of free fall.<br>
<b>phy.h</b> - Planck's constant.<br>
<b>phy.k</b> - Boltzmann's constant.<br>
<b>phy.mu0</b> - Permeability of free space.<br>
<b>phy.sigma</b> - Stefan-Boltzmann constant.<br></p>
<pre class="example">

-- use 'const'
_C = require 'lib.const'
-- external dependencies, can be loaded implicitly
require 'lib.units'  -- convert into Unit object

-- charge of electron
ans = _C.phy.e * 1E19        --3> 1.602

-- convert to Unit object (add _U)
e = _C.phy.e_U
ans = e:key()                 --> _C.phy.e_u_

-- change units
ans = e['nC']                --3> _C.phy.e * 1E9

-- create "immutable" value
_C:add('myConst', 10)
ans = _C.myConst              --> 10

-- modification generates error
ans = pcall(function() _C.myConst = 0 end)  --> false

-- remove constant
_C:remove('myConst')
ans = _C.myConst              --> nil

--</pre>
<a href="#Top">Top</a></div>
<div><a name="_D"></a>
<h3># _D (data) #</h3>
<p class="descript">Data processing and statistics.</p>
<p><b>_D:Fn(sExpr,[iArg=2])</b> - Generate function from expression of x1, x2 etc.<br>
<b>_D:cov(t)</b> - Find covariance matrix for list of vectors.<br>
<b>_D:cov2(t1,t2)</b> - Find covariance value for two vectors.<br>
<b>_D:csvread(sFile,[delim=',',bCol=false])</b> - Read delimiter separated data as Lua table.<br>
<b>_D:csvwrite(sFile,t,[char=',',bCol=false])</b> - Save Lua table as delimiter separated data into file.<br>
<b>_D:filter(t,vCond)</b> - Get result of the table filtering. Condition is either boolean function or table of weights.<br>
<b>_D:freq(t)</b> - Return table with frequencies of elements.<br>
<b>_D:geomean(t,[tw])</b> - Geometrical mean.<br>
<b>_D:harmmean(t,[tw])</b> - Harmonic mean.<br>
<b>_D:histcounts(X,[rng=10])</b> - Calculate amount of bins. Edges can be either number or table.<br>
<b>_D:is(t,fn)</b> - Find weights using boolean function.<br>
<b>_D:isNot(t,fn)</b> - Find inverted weights using boolean function.<br>
<b>_D:max(t)</b> - Maximal element and its index.<br>
<b>_D:mean(t,[tw])</b> - Calculate average value. Weights can be used.<br>
<b>_D:median(t)</b> - Median of the list.<br>
<b>_D:min(t)</b> - Minimal element and its index.<br>
<b>_D:moment(N,t,[tw])</b> - Central moment of t order N, tw is a list of weights.<br>
<b>_D:ref(t,[iBeg=1,iEnd=#t])</b> - Return reference to the range of elements.<br>
<b>_D:std(t,[tw])</b> - Standard deviation and variance. Weights can be used.<br>
<b>_D:sum(t)</b> - Get sum of all elements.<br>
<b>_D:tcdf(d,N)</b> - Student's cumulative distribution.<br>
<b>_D:tpdf(d,N)</b> - Student's distribution density.<br>
<b>_D:xEq(d)</b> - Return function for condition x == d.<br>
<b>_D:xGt(d)</b> - Return function for condition x > d.<br>
<b>_D:xIn(d1,d2)</b> - Return function for condition d1 <= x <= d2.<br>
<b>_D:xLt(d)</b> - Return function for condition x < d.<br>
<b>_D:zip(fn,...)</b> - Sequentially apply function to list of tables.<br></p>
<pre class="example">

-- use 'data'
_D = require 'lib.data'
-- external dependencies, can be loaded implicitly
require 'lib.special'
require 'lib.matrix'

-- initial data (tables)
X = {3,2,5,6,3,4,3,1}
-- weight
w = {1,1,0}
-- enought to define w[i] ~= 1
w[5] = 2; w[6] = 2
-- average
ans = _D:mean(X)           --3> 3.375

-- standard deviation
ans, tmp = _D:std(X,W)     --3> 1.495

-- variance
ans = tmp                    --3> 2.234

-- covariance for two vectors
Y = {0,2,1,3,7,5,8,4}
a = _D:cov2(X,Y)
ans = a                      --3> -0.65625

-- covariance matrix
tmp = _D:cov({X,Y})
ans = tmp[1][2]              --3> a

-- maximum element and index
_,ans = _D:max(X)           --> 4

-- median
ans = _D:median(X)          --> 3

-- table of frequencies
tmp = _D:freq(X)
ans = tmp[3]                  --> 3

-- central moment
ans = _D:moment(2,X)       --3> 2.234

-- summ of elements
ans = _D:sum(X)             --> 27

-- minimum value
ans = _D:min(X)             --> 1

-- geometrical mean
ans = _D:geomean(X)        --3> 2.995

-- harmonic mean
ans = _D:harmmean(X,W)     --3> 2.567

-- check if X[i] > 2
a = _D:is(X, _D:xGt(2))
ans = a[1]                    --> 1

-- get elements X[i] > 2
tmp = _D:filter(X, a)
ans = tmp[1]                  --> X[1]

-- filtration using explicit function
fn = function (x) return x > 2 end
tmp = _D:filter(X, fn)
ans = tmp[1]                  --> X[1]

-- generate new list
-- use 'lazy' function definition
tmp = _D:zip("{x1-x2,x1+x2}", X, Y)
ans = tmp[1][2]               --> X[1]+Y[1]

-- find histogram
a,b = _D:histcounts(X, 3)
ans = b[1]                    --> 2.25

-- define edges
a,b = _D:histcounts(X,{2,4,7})
ans = a[1]                    --> 1

-- table range reference
a = _D:ref(X, 3, 6)
ans = #a                      --> 4

ans = a[1]                    --> X[3]

-- Student cdf and pdf
ans = _D:tcdf(4, 2.5)      --3> 0.9805

ans = _D:tpdf(2, 3.3)      --3> 0.0672

-- dsv write
nm = os.tmpname()
-- separate elements with ';'
t = {{1,2,3},{4,5,6}}
_D:csvwrite(nm, t, ';')

-- dsv read
-- with separator ';'
tt = _D:csvread(nm, ';')
ans = tt[2][2]                --> 5

-- csv write by columns
_D:csvwrite(nm, t, ',', true)

-- csv read by columns
tt = _D:csvread(nm, ',', true)
ans = tt[1][3]                --> 3

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Geo"></a>
<h3># Geo (geodesy) #</h3>
<p class="descript">Coordinate transformations and other geodetic tasks.</p>
<p><b>A.blhInto[B]</b> - Get function to transform geodetic coordinates from A to B system using the Molodensky method.<br>
<b>A.xyzInto[B]</b> - Get function to transform coordinates from A to B system.<br>
<b>Geo:deg2dms(d)</b> - Return degrees, minutes and seconds for the given angle value.<br>
<b>Geo:dms2rad(d,[m=0,s=0])</b> - Convert degrees, minutes and seconds to radians.<br>
<b>Geo:fromENU(tBLr,tXYZr,tTop)</b> - Get cartesian coordinates of a local point in reference frame.<br>
<b>Geo:grav(dB)</b> - International gravity formula, angle in degrees.<br>
<b>Geo:hashDecode(sHash)</b> - Find central point and range of the zone.<br>
<b>Geo:hashEncode(t[,N=6])</b> - Find hash for the given point.<br>
<b>Geo:toENU(tBLr,tXYZr,tCatr)</b> - Get topocentric coordinates of a point in reference frame.<br>
<b>projGK(tBL)</b> - Return north and east positions of the point after Gauss-Kruger projection.<br>
<b>projM(tBL)</b> - Return north and east positions of the point after Mercator projectoin.<br>
<b>solveDir(BLH,azimuth,dist)</b> - Solve direct geodetic problem, find second point position and its orientation if the first point, azimuth and distance are given.<br>
<b>solveInv(BLH1,BLH2)</b> - Solve inverse geodetic problem, find distance and azimuths for two points.<br>
<b>toBLH(tXYZ)</b> - Transform Cartesian coordinates to Geodetic.<br>
<b>toXYZ(tBLH)</b> - Transform Geodetic coordinates to Cartesian.<br></p>
<pre class="example">

-- use 'geodesy'
Geo = require 'lib.geodesy'

-- generate random from number -1 to 1
rnd = function () return 2*math.random()-1 end
-- random coordinates (degrees and meters)
t0 = {B=rnd()*90, L=rnd()*180, H=rnd()*1000}
-- latitude, longitude, height
print(t0.B, t0.L, t0.H)

--test in WGS84
wgs84 = Geo.WGS84
-- BLH to XYZ
t1 = wgs84:toXYZ(t0)
print(t1.X, t1.Y, t1.Z)

-- XYZ to BHL
t2 = wgs84:toBLH(t1)
print(t2.B, t2.L, t2.H)
ans = t2.B                 --3> t0.B

ans = t2.L                 --3> t0.L

ans = t2.H                 --3> t0.H

-- find topocentric coordinates
tg = {X=t1.X+10, Y=t1.Y+20, Z=t1.Z+30}
tc = Geo:toENU(t0, t1, tg)

-- back to cartesian
tg2 = Geo:fromENU(t0, t1, tc)
ans = tg2.X                --3> tg.X

-- transform XYZ from WGS84 to PZ90
pz90 = Geo.PZ90
-- get function
xyz_wgs84_pz90 = wgs84.xyzInto[pz90]
t3 = xyz_wgs84_pz90(t1)

-- backward transformation
xyz_pz90_wgs84 = pz90.xyzInto[wgs84]
t4 = xyz_pz90_wgs84(t3)
ans = t4.X                 --2> t1.X

-- datum transformation
blh_wgs84_pz90 = wgs84.blhInto[pz90]
t5 = blh_wgs84_pz90(t0)

-- Gauss-Kruger projection
sk = Geo.SK42
pt = {B=55.752, L=37.618}
t6 = sk:projGK(pt)
ans = t6.N                  --2> 6181924.245

ans = t6.E                  --2> 7413223.481

-- Merkator projection
t7 = wgs84:projM(pt)
print(t7.N, t7.E)

-- inverse problem
p1 = {B=rnd()*50, L=rnd()*50}
p2 = {B=rnd()*50, L=rnd()*50}
s, a1, a2 = wgs84:solveInv(p1,p2)
ans = (s >= 0)               --> true

-- direct problem
p3, a3 = wgs84:solveDir(p1,a1,s)
ans = a3                    --2> a2

ans = p3.B                  --2> p2.B

-- equator acceleration
ans = Geo:grav(0)           --1> 9.78

-- find geohash
h = Geo:hashEncode(p1, 7)
print(h)

-- position from geohash
p4, _ = Geo:hashDecode(h)
ans = p4.B                  --2> p1.B

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Gp"></a>
<h3># Gp (gnuplot) #</h3>
<p class="descript">Interface for calling Gnuplot from Sonata.</p>
<p><b>Gp()</b> - Prepare Gnuplot object.<br>
<b>Gp:plot(x1[,y1,nm,x2,..])</b> - 'x' is list of numbers, 'y' is either list or functin, 'nm' - curve name.<br>
<b>Gp:polarplot(x1,y1,[nm,x2,y2..])</b> - Make polar plot. 'x' is list of numbers, 'y' is either list or functin, 'nm' - curve name.<br>
<b>Gp:surfplot(x1,y1,fn1,[nm,x2,y2..])</b> - Make surfacе plot. 'x' and 'y' are lists of numbers, 'fn' is functin, 'nm' - surface name.<br>
<b>Gp:tplot(v[,x,y1,y2..])</b> - Plot table, matrix or data file. Optional elements define columns.<br>
<b>Gp:tpolar(v,[x,y1,y2..])</b> - Polar plot for table, matrix or data file. Optional elements define columns.<br>
<b>Gp:tsurf(v,[x1,y1,z1,z2..])</b> - Surface plot for table, matrix or data file. Optional elements define columns.<br>
<b>add(tCurve)</b> - Add new curve to figure.<br>
<b>copy()</b> - Get copy of the plot options.<br>
<b>keys</b> -   Options / examples:<br>
{math.sin, title='sin'}       -- plot using function, define in Lua; add legend<br>
{'sin.dat', ln=1, lw=2}       -- plot data from file, use given color and width<br>
{tbl, with='lines'}           -- plot data from Lua table, use lines<br>
title='Graph name'            -- set title<br>
xrange={0,10}                 -- range of x from 0 to 10<br>
yrange={-2,2}                 -- range of y<br>
zrange={0,5}                  -- range of z<br>
trange={1,2}                  -- range for parametric functions<br>
xtitle='A', ytitle='B'        -- axes names<br>
terminal='jpeg'               -- save result as jpeg image<br>
output='my_plot.jpg'          -- file name<br>
parametric=true               -- create parametric plot<br>
size='square'                 -- set square size<br>
polar=true                    -- use polar coordinate system<br>
grid='polar'                  -- polar grid<br>
legend=false                  -- don't use legend<br>
surface=true                  -- plot surface in 3D<br>
samples=200                   -- define number of points<br>
raw='set pm3d'                -- set Gnuplot options manually<br>
<br>
<b>show()</b> - Plot data, represented as Lua table.<br></p>
<pre class="example">

-- use 'gnuplot'
Gp = require 'lib.gnuplot'
Gp.testmode = true -- just for testing

-- simple plot
t1 = {1,2,3,4,5}
t2 = {2,4,6,4,2}
-- in the dialog call "plot(t1,t2,'some curve')"
Gp:plot(t1,t2,'some curve')

-- simplified function plot
Gp:plot(t1, math.sin, 'sin')

-- name can be skipped
Gp:plot(t1, math.sin, t1, math.cos)

-- plot table (or matrix, or datafile)
arr = {}
for i = 1,50 do
  x = 0.1*i
  arr[i] = {x, math.sin(x), math.cos(x)}
end
-- all columns by default (for table and matrix)
Gp:tplot(arr)

-- the same, but with explicit column specification
Gp:tplot(arr,1,2,3)

-- in polar coordinate system
Gp:polarplot(t1,t2,'some curve')

-- from table
Gp:tpolar(arr,1,2)

-- plot surface
function fun(x,y) return x*x + y*y end
Gp:surfplot(t1,t2,fun,'some surf')

-- from table
arr2 = {}
for _,v1 in ipairs(t1) do
  for _,v2 in ipairs(t2) do
    arr2[#arr2+1] = {v1,v2,fun(v1,v2)}
  end
end
Gp:tsurf(arr2)

-- direct use Gp object
a = Gp()
a:add {math.sin, title='sin'}
a:add {math.cos, title='cos'}
a:show()

-- additional parameters
a.xrange = {0,10}   -- add rangle
-- save to file
a.terminal = 'png'
a.output = 'test.png'
a:show()

-- copy parameters to other object
b = a:copy()
print(b)

-- send 'raw' command to Gnuplot
c = Gp()
c.raw = 'plot x**2-2*x+1; set xlabel "X"; set ylabel "Y"'
c:show()

-- print Lua table
tmp = {
  {1,1},
  {2,2},
  {3,3},
  {4,4}
}
d = Gp()
d:add {tmp,with='lines'}
d:show()

-- define function
fn1 = function (x) return x^2-x end
f = Gp()
f:add {fn1,with='lines',title='x^2-x'}
f:show()

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Graph"></a>
<h3># Graph (graph) #</h3>
<p class="descript">Operations with graphs.</p>
<p><b>Graph {v1,v2,..}</b> - Create new graph.<br>
<b>add(v)</b> - Add new node or edge to graph G. Node denoted as a single name, edge is a table of names (and weights if need).<br>
<b>bfs(vStart,vGoal)</b> - Breadth first search. Return result and found path.<br>
<b>copy()</b> - Get copy of the graph.<br>
<b>dfs(vStart,vGoal)</b> - Depth first search. Return result and found path.<br>
<b>edges()</b> - List of graph edges.<br>
<b>isComplete()</b> - Check completeness of the graph.<br>
<b>isDirected()</b> - Check if the graph has directed edges.<br>
<b>isNegative()</b> - Check if the graph has negative edges.<br>
<b>isWeighted()</b> - Check if any edge has weight different from 1.<br>
<b>nodes()</b> - List of graph nodes.<br>
<b>pathBF(vStart,[vGoal])</b> - Shortest path search using Bellman-Ford algorithm.<br>
<b>pathD(vStart,[vGoal])</b> - Find shortest path using Dijkstra's algorithm. Return table of distances and predecessors. If goal is defined, return path and its length.<br>
<b>remove(v)</b> - Remove node or edge from the graph G. Node is a single name, edge - table of names.<br></p>
<pre class="example">

-- use 'graph'
Graph = require 'lib.graph'

-- build graph
-- single name - node, names in brackets - edges
-- letter w denotes weight of non directed edge
-- numbers are weights of directed edges
a = Graph {'a','b',
  {'a','c'},
  {'d','e',w=2},
  {'d','b',4,3}
}

-- list of nodes
nd = a:nodes()
ans = #nd                     --> 5

-- list of edges
-- if an edge has different weight for different sizes
-- it is represented twice
ed = a:edges()
ans = #ed                     --> 4

-- has directed edges
ans = a:isDirected()          --> true

-- add node
a:add('h')
-- add edge
a:add {'a','d'}
-- check size
-- (same as #a)
ans = a:size()                --> 6

-- remove edge
a:remove {'a','d'}
-- remove node
a:remove('a')
-- new edge number
ed = a:edges()
ans = #ed                     --> 3

-- directed edges
-- second way to define
-- from first to second node
a:add {'c','p',w12=2}
-- and vise versa
a:add {'c','q',w21=3}
ed = a:edges()
ans = #ed                     --> 5

-- make copy
b = a:copy()

-- completeness
ans = b:isComplete()          --> false

-- prepare graph
c = Graph {
  {'a','b'},
  {'a','c'},
  {'b','d'},
  {'b','e'},
  {'c','f'},
  {'f','g'},
  {'f','h'},
  {'e','g'}
}

-- is it weighted
ans = c:isWeighted()          --> false

-- breadth first search
_,path = c:bfs('e','h')
ans = path[3]                 --> 'f'

-- depth first search
found,path = c:dfs('d','c')
ans = found                   --> true

-- update weight (default is 1)
-- use 'add' method
c:add{'a','b',w=0.5}
c:add{'b','e',w=0.4}
c:add{'c','f',w=2}

-- Dijkstra path search
dist,prev = c:pathD('a')
ans = dist['g']               --> 1.9

-- Bellman-Ford path search
c:add{'f','h',w=-0.5}
dist,prev = c:pathBF('a')
ans = dist['h']

-- check negative edges
ans = c:isNegative()          --> true

-- show
print(b)

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Lens"></a>
<h3># Lens (lens) #</h3>
<p class="descript">Matrix methods in paraxial optics.</p>
<p><b>Lens {dA,dB,dC,dD}</b> - Make new lens component.<br>
<b>Lens:afocal(dm)</b> - Find matrix for the afocal system.<br>
<b>Lens:gausParam(dW0,dLam)</b> - Find divergence angle and Raileigh range for a Gaussian beam.<br>
<b>Lens:gaussSize(dW0,dLam,dist)</b> - Find Gaussian beam radius and curvature at some distance.<br>
<b>Lens:mirror(dr,dn)</b> - Find reflection matrix for the given radius and refractive index.<br>
<b>Lens:ref(dr,dn1,dn2)</b> - Find refraction matrix for the given radius of surface and input and output refractive indeces.<br>
<b>Lens:solve(fn,ind,d0)</b> - Find condition when component with the given index is equal to 0, d0 is the initial assumption.<br>
<b>Lens:thin(df)</b> - Find the thin lens system matrix for the given focal distance.<br>
<b>Lens:trans(dt,dn)</b> - Find translation matrix for the given distance and refractive index.<br>
<b>beam(dW,dR,dLam)</b> - Find output beam radius and curvature.<br>
<b>cardinal([dn1=1,dn2=1])</b> - Find location of the cardinal points of the given system w.r.t input and output planes, use refractive indeces if need. Return table of distances.<br>
<b>copy()</b> - Create a copy of the object.<br>
<b>det()</b> - Find determinant of the system matrix.<br>
<b>inv()</b> - Get the inverted system matrix.<br>
<b>isUnit()</b> - Check if the system matrix is unit.<br>
<b>operations</b> - L1 == L2, L1 .. L2<br>
<b>transform(dy,dV)</b> - Find the output ray position 'dy' and optical angle 'dV' (= v*n). Equal to call L(dy,dV).<br></p>
<pre class="example">

-- use 'lens'
Lens = require 'lib.lens'
-- external dependencies, can be loaded implicitly
Num = require 'lib.numeric' -- for root searching

-- define a simple lense
n1 = 1      -- air
n2 = 1.56   -- glass
-- radius 200 mm, thickness 5 mm
lens1 = Lens:ref(200,n1,n2)..Lens:trans(5,n2)..Lens:ref(-200,n2,n1)
ans = lens1:isUnit()          --> true

-- get matrix element
ans = lens1.D                --2> 1

-- find cardinal points
pts = lens1:cardinal()
ans = pts.F1                 --2> -177.76

-- print points
print(pts)

-- object is located 250 mm to the left
-- from the lens, find position of
-- the image
d1 = 250
fn = function (d2)
  return Lens:trans(d1,n1)..lens1..Lens:trans(d2,n1)
end
-- solve for B = 0, initial guess dist = 100
d2 = Lens:solve(fn, Lens.key.B, 100)
ans = d2                     --2>  623.21

-- check solution
-- assume the lens it thin
f = -pts.F1
ans = 1/d1 + 1/d2            --2> 1/f

-- ray transformation
y1 = 10          -- mm, height
V1 = n1 * 0.05   -- optical angle
sys1 = fn(d2)
y2, V2 = sys1(y1,V1)
ans = y2                     --2> -24.83

-- from image to object
sys2 = sys1:inv()  -- transpose
ans, _ = sys2(y2, V2)        --3> y1

-- system matrix determinant
ans = lens1:det()            --3> 1

-- create thin lens
lens2 = Lens:thin(f)
_, V3 = lens1(y1,V1)
_, ans = lens2(y1,V1)        --2> V3

-- flat mirror
lens3 = Lens:mirror(math.huge, n1)
_, ans = lens3(y1,V1)        --2> V1

-- afocal system
m = 10
lens4 = Lens:afocal(m)
ans, _ = lens4(y1,V1)        --2> m*y1

-- arbitrary system matrix
lens5 = Lens {1, 0, -0.5, 1}
print(lens5)

-- make copy
ans = lens1:copy()            --> lens1

-- gaussian beam parameters
ans, _ = Lens:gaussParam(1E-3, 1.024E-6) --2> 3.26E-4

-- laser beam radius
ans, _ = Lens:gaussSize(1E-3, 1.024E-6, 100) --2> 0.033

-- laser beam transformation
ans, _ = lens1:beam(1E-3, 1E3, 1.024E-6)  --2> 1.44E-3

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Main"></a>
<h3># Main (main) #</h3>
<p class="descript">Lua based mathematics.</p>
<p><b>Log(sFlag)</b> - Save session into the log file. Use 'on'/'off' to start/stop logging.<br>
<b>Map(fn,t)</b> - Evaluate function for each table element.<br>
<b>Print(...)</b> - Extenden print function, it shows elements of tables and scientific form of numbers.<br>
<b>Range(dBegin,dEnd,[dStep])</b> - Generate range object.<br>
<b>Round(f,[N=0])</b> - Round value, define number of decimal digits.<br>
<b>Run(sFile,[bInt=false])</b> - Execute lua- or note- file. Set bInt for interaction.<br>
<b>Type(v)</b> - Show type of the object.<br>
<b>_ans</b> - Result of the last operation.<br>
<b>_e</b> - Euler number.<br>
<b>_pi</b> - Number pi.<br>
<b>abs(d)</b> - Absolute value.<br>
<b>acos(d)</b> - Inverse cosine x.<br>
<b>acosh(x)</b> - Hyperbolic arc cosine.<br>
<b>asin(d)</b> - Inverse sine x.<br>
<b>asinh(x)</b> - Hyperbolic inverse sine.<br>
<b>atan2(dy,dx)</b> - Inverse tangent of dy/dx, use signs.<br>
<b>atanh(x)</b> - Hyperbolic inverse tangent.<br>
<b>cos(d)</b> - Cosine x.<br>
<b>cosh(d)</b> - Hyperbolic cosine.<br>
<b>exp(d)</b> - Exponent.<br>
<b>log(dPos)</b> - Natural logarithm.<br>
<b>rand()</b> - Random number between 0 and 1.<br>
<b>randi(N)</b> - Random integer in range from 1 to N.<br>
<b>randn([dMean=0,dev=1])</b> - Normal distributed random value with the given mean and deviation.<br>
<b>sin(d)</b> - Sinus x.<br>
<b>sinh(d)</b> - Hyperbolic sinus.<br>
<b>sqrt(dPos)</b> - Square root.<br>
<b>tan(d)</b> - Tangent x.<br>
<b>tanh(d)</b> - Hyperbolic tangent.<br></p>
<pre class="example">

require 'lib.main'

-- constants starts from _
ans = _pi                     --> math.pi

-- standard functions
ans = exp(0)+sin(_pi/2)+cosh(0)  --1> 3.0

-- round number
ans = Round(0.9)              --> 1.0

-- save 2 digits
ans = Round(math.pi, 2)       --> 3.14

-- random between 0 and 1
p = rand()
ans = (p >= 0) and (p <= 1)   --> true

-- random integer (1 to 10)
p = randi(10)
ans = (p >= 1) and (p <= 10)  --> true

-- normal distributed random
print(randn())

-- get type
-- "knows" Sonata objects
ans = Type(25)                --> 'integer'

-- modified print function
a = {a=1,b=2, 3,4,5}
Print(a, 0.123)

-- generate 'sequence'
b = Range(1,3)
ans = b[3]                    --> 3

-- even numbers
b = Range(2,10,2)
ans = b[2]                    --> 4

-- linear transformations
-- with range Range objects
b2 = 2*b + 4
ans = b2[1]                   --> 8

-- calculate function values
c = Map(sin, b)
ans = c[1]                   --3> 0.909

-- use Lua functions if need
ans = math.floor(_pi)

ans = math.deg(_pi)

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Mat"></a>
<h3># Mat (matrix) #</h3>
<p class="descript">Matrix operations. The matrices are spares by default.</p>
<p><b>H()</b> - Return conjugabe transpose. <br>
<b>Mat {tRow1,tRow2,..}</b> - Create matrix from list of strings (tables).<br>
<b>Mat:V({...})</b> - Create vector from list of numbers.<br>
<b>Mat:eye(iRows,[iCols=iRows])</b> - Create identity matrix.<br>
<b>Mat:fill(iRows,iCols,[val=1])</b> - Create matrix of given numbers (default is 1).<br>
<b>Mat:zeros(rows,[cols=rows])</b> - Create matrix of zeros.<br>
<b>Mat:zip(fn,M1,M2,...)</b> - Apply function to the given matrices element-wise.<br>
<b>T()</b> - Return matrix transpose.<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, a^b, -a<br>
<b>chol()</b> - Cholesky decomposition of positive definite symmetric matrix.<br>
<b>cols()</b> - Get number of columns.<br>
<b>comparison</b> - a==b, a~=b<br>
<b>concat(M,sDir)</b> - Concatenate two matrices, dir='h' - in horizontal direction, dir='v' - in vertical<br>
Use M1 .. M2 for horizontal concatenation and M1 // M2 for vertical.<br>
<b>copy()</b> - Return copy of matrix.<br>
<b>cross(V)</b> - Cross product or two 3-element vectors.<br>
<b>det()</b> - Calculate determinant.<br>
<b>diag()</b> - Get diagonal of the matrix or create new matrix which diagonal elements are given.<br>
<b>dot(V)</b> - Scalar product of two vectors.<br>
<b>eig()</b> - Find matrices of eigenvectors and eigenvalues.<br>
<b>insert(tR,tC,M)</b> - Insert second matrix into the given range of indeces.<br>
<b>inv()</b> - Return inverse matrix.<br>
<b>lu()</b> - LU decomposition for the matrix. Return L,U and P matrices.<br>
<b>map(fn)</b> - Apply the given function to all elements, return new matrix. Function can be in form f(x) or f(x,row,col).<br>
<b>norm()</b> - Euclidean norm.<br>
<b>pinv()</b> - Pseudo inverse matrix calculation.<br>
<b>qr()</b> - QR decomposition of the matrix.<br>
<b>range(tR,tC)</b> - Get submatrix for the given range of rows and columnts.<br>
<b>rank()</b> - Find rank of the matrix.<br>
<b>reshape([iRows=size,iCols=1])</b> - Get matrix with changed size.<br>
<b>round([N=6])</b> - Round matrix elements in place.<br>
<b>rows()</b> - Get number of rows.<br>
<b>rref()</b> - Perform transformations using Gauss method.<br>
<b>table()</b> - Convert to simple Lua table.<br>
<b>tr()</b> - Get trace of the matrix.<br></p>
<pre class="example">

-- use 'matrix'
Mat = require 'lib.matrix'

-- define matrix objects
a = Mat {{1,2},{3,4}}
b = Mat {{5,6},{7,8}}
-- call in typical way
ans = a[2][2]                 --> 4

b[1][1] = 5
-- transpose
c = a:T()
-- 'smart' getter
ans = c(1,-1)                 --> 3

-- matrix columns and rows
ans = a:cols()                --> 2

ans = a:rows()                --> 2

-- arithmetical operations
ans = a + b                   --> Mat {{6,8},{10,12}}

ans = b - a                   --> Mat {{4,4},{4,4}}

ans = a * b                   --> Mat {{19,22},{43,50}}

ans = a / b
-- determinant
ans = ans:det()              --2> 1

-- multiply to scalar
ans = 2 * a                   --> Mat {{2,4},{6,8}}

-- add scalar (to all elements)
ans = a - 1                   --> Mat {{0,1},{2,3}}

ans = a ^ 2                   --> Mat {{7,10},{15,22}}

-- determinant
ans = a:det()                 --> -2

-- inverse matrix
e = a:inv()
ans = e(2,1)                  --> 1.5

-- another call of inversion
e = a^-1
ans = e(2,1)                  --> 1.5

-- object copy
-- (it doesn't copy zeros)
f = a:copy()
ans = (f == a)                --> true

-- element-wise comparison
ans = (a == b)                --> false

-- identity matrix
ans = Mat:eye(2)              --> Mat {{1,0},
                                       {0,1}}

-- matrix argument
ans = Mat:eye(a)              --> Mat {{1,0},
                                       {0,1}}

-- matrix of zeros
ans = Mat:zeros(2,1)          --> Mat {{0},{0}}

-- matrix of constants = 4
ans = Mat:fill(2,3,4)         --> Mat {{4,4,4},
                                       {4,4,4}}

-- horizontal concatenation
ans = a .. b                  --> Mat {{1,2,5,6},
                                       {3,4,7,8}}

-- vertical concatenation
-- (a // b - for short)
ans = a:concat(b,'v')         --> Mat {{1,2},{3,4},{5,6},{7,8}}

-- apply function of 1 argument
ans = a:map(function (x) return x^2 end)       --> Mat {{1,4},{9,16}}

-- apply function which depends on index too
ans = a:map(function (x,r,c) return x-r-c end) --> Mat {{-1,-1},{-0,-0}}

-- apply function to matrices
-- element-wise
fn = function (x,y,z) return x*y+z end
aa = Mat:zip(fn, b,b,b)
ans = aa[1][1]                --> 30

-- use Gauss transform to solve equation
ans = (a .. Mat{{5},{11}}):rref()            --> Mat {{1,0,1},
                                                        {0,1,2}}

-- create vector
ans = Mat:V {1,2,3}           --> Mat {{1},{2},{3}}

-- get submatrix
g = Mat {
  {1,2,3},
  {4,5,6},
  {7,8,9}
}
-- same as g:range({2,-1},{2,3})
ans = g({2,-1},{2,3})         --> Mat {{5,6},
                                       {8,9}}

-- insert elements
gg = Mat:eye(3)
gg:insert({1,2},{1,2}, a)
ans = gg:range({1,2},{1,2})   --> a

-- euclidean norm
ans = Mat:V({1,2,3}):norm()  --3> math.sqrt(14)

-- random matrix
rnd = function () return math.random() end
h = Mat:zeros(2,3):map(rnd)
print(h)

-- round elements
noize = function (v) return v + math.random()*1E-8 end
hh = a:map(noize)
hh:round(3)
ans = hh                      --> a

-- pseudo inverse matrix
m = Mat {
  {1,2},
  {3,4},
  {5,6}
}
n = m:pinv()
ans = n(2,2)                 --3> 0.333

-- copy as Lua table
-- (without methametods)
k = Mat:eye(3)
k = k:table()
ans = k[2][1]                 --> 0

-- make diagonal matrix
ans = Mat:diag({1,2,3})       --> Mat {{1,0,0},
                                       {0,2,0},
                                       {0,0,3}}

-- get diagonal
ans = g:diag()               --> Mat {{1},{5},{9}}

-- cross-product of 2 vectors
x1 = Mat {{1,2,3}}
x2 = Mat {{4,5,6}}
ans = x1:cross(x2)            --> Mat {{-3},{6},{-3}}

-- dot product of 2 vectors
ans = x1:dot(x2)              --> 32

-- LU decomposition
l,u,p = b:lu()
ans = l[2][1]                --3> 0.714

-- QR decomposition
q,r = m:qr()
ans = (q*r)[2][2]            --3> m[2][2]

ans = q:det()                --3> 1.0

-- Cholesky decomposition
m = Mat {{3,1},{1,3}}
m = m:chol()
ans = m[2][2]                --3> 1.633

-- matrix trace
ans = a:tr()                  --> 5

-- extract first row
m = a({},1)
-- vector doesn't need in 2 indices
ans = m(1)                    --> 1

-- extract last column
-- index can be negative
m = a(-1,{})
ans = m(2)                    --> 4

-- get rank
ans = Mat:fill(2,3):rank()    --> 1

-- change size
tmp = Mat{
  {1,2},
  {3,4},
  {5,6}
}
ans = tmp:reshape(2,3)        --> Mat {{1,2,3},
                                       {4,5,6}}

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Num"></a>
<h3># Num (numeric) #</h3>
<p class="descript">Group of functions for numerical calculations. Tolerance for all functions is defined with parameter TOL.</p>
<p><b>Num:der(fn,x)</b> - Calculate the derivative value for given function.<br>
<b>Num:newton(fn,d0)</b> - Find root of equation using Newton's rule with only one initial condition.<br>
<b>Num:ode45(fn,tDelta,y0,[param])</b> - Numerical approximation of the ODE solution.<br>
First parameter is differential equation, second - time interval, third - initial function value. List of parameters is optional and can includes time step or exit condition.<br>
Return table of intermediate points and result yn.<br>
<b>Num:solve(fn,dA,dB)</b> - Find root of equation fn(x)=0 at interval [a,b].<br>
<b>Num:trapez(fn,a,b)</b> - Get integral using trapezoidal rule.<br>
<b>TOL[=0.001]</b> - The solution tolerance.<br></p>
<pre class="example">

-- use 'numeric'
Num = require 'lib.numeric'

-- define tolerance
Num.TOL = 1e-4
-- solve 'sin(x) = 0' for x in (pi/2...3*pi/2)
a = Num:solve(math.sin, math.pi*0.5, math.pi*1.5)
ans = a                      --3> math.pi

-- Newton method
-- only one initial value
d = Num:newton(math.sin, math.pi*0.7)
ans = d                      --3> math.pi

-- numeric derivative
b = Num:der(math.sin, 0)
ans = b                      --0> 1

-- numeric integral
c = Num:trapez(math.sin, 0, math.pi)
ans = c                      --0> 2

-- solve ODE x*y = x'
-- for x = 0..3, y(0) = 1
-- return table of solutions and y(3)
tbl, yn = Num:ode45(function (x,y) return x*y end,
                    {0,3}, 1)
ans = yn                     --2> 90.011

-- use matrices for high order equations
Mat = require 'lib.matrix'

-- y''-2*y'+2*y = 1
-- represent as: x1 = y, x2 = y'
-- so: x1' = x2, x2' = 1+2*x2-2*x1
myfun = function (t,x)
  return Mat:V {x(2), 1+2*x(2)-2*x(1)}
end
_, xn = Num:ode45(myfun, {0,2}, Mat:V{3,2}, {dt=0.2})
ans = xn(1)                  --2>  -10.54

-- define exit condition
-- from time, current and previous results
cond = function (time,current,previous)
  return current < 0.1
end
myfun = function (t,x) return -x end
y = Num:ode45(myfun, {0,1E2}, 1, {exit=cond})
ans = y[#y][1]               --2> 2.56

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Poly"></a>
<h3># Poly (polynomial) #</h3>
<p class="descript">Operations with polynomials.</p>
<p><b>Poly {..,v1,v0}</b> - Create a polynomial.<br>
<b>Poly:build(root1,root2,...)</b> - Return polynomial with given roots.<br>
<b>Poly:char(M)</b> - Return characteristic polinomial for the given matrix.<br>
<b>Poly:fit(tX,tY,N)</b> - Find polynomial approximation for the line.<br>
<b>Poly:lagrange(tX,tY)</b> - Find interpolation polynomial in the Lagrange form.<br>
<b>Poly:lin(tX,tY,[v0=0,vN=v0])</b> - Linear data interpolation. Return table with polynomials.<br>
<b>Poly:ppval(tP,d,[N]</b> - Return value of a piecewise polynomial in the point and the polynomial index.<br>
<b>Poly:spline(tX,tY)</b> - Cubic spline data interpolation. Return table with polynomials.<br>
<b>Poly:taylor(v,vF,[vF',vF''..])</b> - Get Taylor series.<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, a^n, -a<br>
<b>comparison</b> - a==b, a~=b<br>
<b>copy()</b> - Get copy of the polynomial.<br>
<b>der()</b> - Calculate derivative of polynomial.<br>
<b>int([d0=0])</b> - Calculate integral, d0 - free coefficient.<br>
<b>real()</b> - Find real roots of the polynomial.<br>
<b>roots()</b> - Find all the polynomial roots.<br>
<b>val(v)</b> - Get value of polynomial P in point x.<br></p>
<pre class="example">

-- use 'polynomial'
Poly = require 'lib.polynomial'
-- external dependencies, can be loaded implicitly
require 'lib.matrix'         -- in Poly.fit
Comp = require 'lib.complex' -- for complex roots

-- coefficients in ascendant order
a = Poly {1,2,4,3}
b = Poly {1,1}
-- polynomial value for x=0
ans = a:val(0)                --> 3

-- simplified call
ans = a(0)                    --> 3

-- coefficient for x^3
ans = a[3]                    --> 1

-- arithmetic
ans = a + b                   --> Poly {1,2,5,4}

ans = a - b                   --> Poly {1,2,3,2}

ans = b * b                   --> Poly {1,2,1}

ans = a / b                   --> Poly {1,1,3}

ans = a % b                   --> 0

ans = b ^ 3                   --> Poly {1,3,3,1}

-- integration
-- free coefficient is 0
ans = b:int()                 --> Poly {0.5,1,0}

-- derivative
ader = a:der()
-- and its value for x=1
ans = ader(1)                 --> 11

-- build polynomial using roots
ans = Poly:build(1,-1)        --> Poly {1,0,-1}

-- use complex roots
-- don't add conjugated toots
ans = Poly:build(1, Comp(2,3))  --> Poly {1, -5, 17, -13}

-- make copy and compare
c = a:copy()
ans = (a == c)                --> true

-- not equal
ans = (b == c)                --> false

-- find real roots
e = a:real()
ans = e[1]                   --1> -1.00

-- find all roots
g = Poly:build(2, Comp(3,4))
e = g:roots()
ans = e[2]:re()              --1> 3

-- fit curve with polynomial
-- of order 2
A={0,1,2,3}
B={-3,2,11,24}
p = Poly:fit(A,B,2)
ans = p(10)                  --0> 227.0

-- simple print
print(a)

-- human-friendly print
-- with variable 's' (default is 'x')
d = Poly {2,-2,1}
ans = d:str('s')              --> '2*s^2-2*s+1'

-- Lagrange polynomial
-- for tx(x)
X = {-1.5, -0.75, 0, 0.75, 1.5}
Y = {-14.101,-0.931596,0,0.931596,14.101}
p = Poly:lagrange(X,Y)
ans = p[3]                   --3> 4.83485

-- Taylor series
-- for exp(x) near 0
p = Poly:taylor(0, 1, 1, 1, 1)
ans = p(0.3)                 --2> math.exp(0.3)

-- linear interpolation
-- use constant values out the interval
p = Poly:lin(X,Y, Y[1], Y[#Y])
y1, n = Poly:ppval(p, 0.5)
ans = y1                     --2> 0.621

-- polynomial index
ans = n                       --> 4

-- simplify call when index is known
ans = Poly:ppval(p, 0.5, n)  --2> y1

-- cubic spline
p = Poly:spline(X, Y)
-- can be called without 'ppval'
ans = p(0.5)                 --2> -0.512

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Quat"></a>
<h3># Quat (quaternion) #</h3>
<p class="descript">Operations with quaternions.</p>
<p><b>Quat {w,x,y,z}</b> - Create new quaternion.<br>
<b>Quat:fromAA(fAng,vAxe)</b> - Create quaternion using angle and axis.<br>
<b>Quat:fromRot(M)</b> - Convert rotation matrix to quaternion.<br>
<b>abs()</b> - Value of the norm.<br>
<b>arithmetic</b> - a + b, a - b, a * b, a ^ k, -a<br>
<b>comparison</b> - a == b, a ~= b<br>
<b>conj()</b> - Get conjugation.<br>
<b>im()</b> - Get table of the imaginary part.<br>
<b>inv()</b> - Find inverted quaternion.<br>
<b>mat()</b> - Equivalent matrix representation.<br>
<b>normalize()</b> - Return unit quaternion.<br>
<b>re()</b> - Real part.<br>
<b>rotate(vec)</b> - Apply quaternion to rotate the vector.<br>
<b>slerp(Q,f)</b> - Spherical linear interpolation for part t.<br>
<b>toAA()</b> - Get angle and axis of rotation.<br>
<b>toRot()</b> - Get equal rotation matrix.<br>
<b>w()</b> - Get w component.<br>
<b>x()</b> - Get x component.<br>
<b>y()</b> - Get y component.<br>
<b>z()</b> - Get z component.<br></p>
<pre class="example">

-- use 'quaternion'
Quat = require 'lib.quaternion'
-- external dependencies, can be loaded implicitly
require 'lib.matrix'

-- quaternion
-- set {w,x,y,z}
a = Quat {1,2,3,4}
-- part of elements
b = Quat {w=3, x=4}
ans = b                       --> Quat{3,4,0,0}

-- conjugation
ans = a:conj()                --> Quat{1,-2,-3,-4}

-- real when imaginary are zeros
ans = a + a:conj()            --> 2

-- norm
ans = b:abs()                --1> 5.000

-- inversion
c = a*a:inv()
ans = c:w()                  --1> 1.000

-- arithmetic
ans = a+b                     --> Quat{4,6,3,4}

ans = a*b                     --> Quat{-5,10,25}

ans = 3*b                     --> Quat{9,12,0,0}

-- power
ans = b^3                     --> b * b * b

-- unit quaternion
a = a:normalize()
ans = a:abs()                --1> 1.000

-- unit power
aa = a^1.5
ans = aa:x()                 --3> 0.324

ans = aa:y()                 --3> 0.486

ans = aa:z()                 --3> 0.648

-- rotation matrix
m = a:toRot()
d = Quat:fromRot(m)
ans = (d-a):abs()            --1> 0.000

-- use angle
-- and axis
ang = 0.5
axis = {1,1,1}
f = Quat:fromAA(ang,axis)
ans,_ = f:toAA()             --3> ang

-- rotate vector
p = a:rotate({1,0,0})
ans = p[1]                   --3> -0.667

-- spherical interpolation
d = a:slerp(b,0.5)
ans = d:w()                  --3> 0.467

-- show
print(d)

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Rat"></a>
<h3># Rat (rational) #</h3>
<p class="descript">Computations with rational numbers.</p>
<p><b>Rat(m,[n=1])</b> - Create rational number using num (and denom).<br>
<b>Rat:from(f,[fErr=1E-3])</b> - Estimate ratio from floating point value.<br>
<b>Rat:fromCont(t)</b> - Transform continued fraction to rational number.<br>
<b>Rat:gcd(va,vb)</b> - Calculate the greatest common divisor for two integers.<br>
<b>arithmetic</b> - R1+R2, R1-R2, R1*R2, R1/R2, -R, R1^R2<br>
<b>comparison</b> - R1<R2, R1<=R2, R1>R2, R1>=R2, R1==R2, R1~=R2<br>
<b>denom()</b> - Return the denominator of the rational number.<br>
<b>eq(R)</b> - Compare two objects.<br>
<b>float()</b> - Return rational number as decimal.<br>
<b>num()</b> - Return the numerator of rational number.<br>
<b>toCont()</b> - Transform rational number to continued fraction.<br></p>
<pre class="example">

-- use 'rational'
Rat = require 'lib.rational'

-- numerator, denominator
a = Rat(1,2)
-- only numerator
b = Rat(2)
ans = b                       --> Rat(2,1)

-- simplification
k = 234781
ans = Rat(2*k,3*k)            --> Rat(2,3)

-- arithmetic
ans = a + b                   --> Rat(5,2)

ans = 2 * a                   --> 1

ans = Rat(2,3)*Rat(3,2)       --> 1

ans = a / Rat(1,3)            --> Rat(3,2)

ans = a ^ 3                   --> Rat(1,8)

ans = 2 ^ a                  --3> 1.414

-- comparison
ans = (b == b)                --> true

ans = (a >= b)                --> false

-- greatest common division
ans = Rat:gcd(125,65)         --> 5

-- represent as decimal
ans = a:float()               --> 0.5

-- from decimal
ans = Rat:from(math.pi)       --> Rat(333, 106)

-- numerator
ans = b:num()                 --> 2

-- denominator
ans = b:denom()               --> 1

-- show
print(a)

-- result is rational
ans = a + 1                   --> Rat(3,2)

-- result is float
ans = a + 0.5                 --> 1

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Spec"></a>
<h3># Spec (special) #</h3>
<p class="descript">Special mathematical functions.</p>
<p><b>Spec:besseli(N,x)</b> - Modified Bessel function In(x).<br>
<b>Spec:besselj(N,x)</b> - Bessel function of the first kind.<br>
<b>Spec:besselk(N,x)</b> - Modified Bessel function Kn(x).<br>
<b>Spec:bessely(n,x)</b> - Bessel function of the second kind.<br>
<b>Spec:beta(z,w)</b> - Beta function.<br>
<b>Spec:betainc(x,a,b)</b> - Incomplete beta function Ix(a,b).<br>
<b>Spec:betaln(z,w)</b> - Natural logarithm of beta function.<br>
<b>Spec:dawson(x)</b> - Dawson integral.<br>
<b>Spec:erf(x)</b> - Error function.<br>
<b>Spec:erfc(x)</b> - Complementary error function.<br>
<b>Spec:expint(n,x)</b> - Exponential integral En(x).<br>
<b>Spec:gamma(z)</b> - Gamma function.<br>
<b>Spec:gammainc(x,N,[type='lower'])</b> - Incomplete gamma function, P (type='lower') or Q (type='upper').<br>
<b>Spec:gammaln(z)</b> - Natural logarithm of gamma function.<br>
<b>Spec:gammp(N,x)</b> - Incomplete gamma function P(N,x).<br>
<b>Spec:gammq(N,x)</b> - Incomplete gamma function Q(N,x) = 1-P(N,x).<br>
<b>Spec:legendre(n,x)</b> - Return list of Legendre polynomial coefficients.<br></p>
<pre class="example">

-- use 'special'
Spec = require 'lib.special'

-- beta functions
ans = Spec:beta(3,4) * 1E2   --3> 1.667

ans = Spec:betaln(10,20)     --3> -19.115

ans = Spec:betainc(0.5, 2, 3.3)  --3> 0.7309

-- error functions
ans = Spec:erf(1)            --3> 0.8427

ans = Spec:erfc(0.5)         --3> 0.4795

-- Ei(x)
ans = Spec:expint(3.3) * 1E3     --3> 8.939

-- E3(x)
ans = Spec:expint(2, 5) * 1E4    --3> 9.965

-- gamma functions
ans = Spec:gamma(-1.5)       --3> 2.3633

ans = Spec:gammaln(100)      --3> 359.1342

ans = Spec:gammp(7.7, 2.3) * 1E3 --2> 3.85

ans = Spec:gammq(1.5, 4.8) * 1E2 --2> 2.23

-- another syntax
ans = Spec:gammainc(2.1, 0.3, 'upper') * 1E2 --3> 1.942

-- Bessel functions
ans = Spec:besselj(3, 1.5) * 1E2 --3> 6.096

ans = Spec:bessely(4, 0.8)   --3> -78.751

ans = Spec:besseli(2, -3.6)  --3> 4.254

ans = Spec:besselk(5, 5) * 1E2   --3> 3.2706

-- Legendre function
lst = Spec:legendre(3, 0.5)
ans = lst[1]                 --3> -0.4375

-- Dawson function
ans = Spec:dawson(3.3)       --3> 0.1598

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Sym"></a>
<h3># Sym (symbolic) #</h3>
<p class="descript">Symbolical calculations.</p>
<p><b>Sym(v)</b> - Create new symbolic variable.<br></p>
<pre class="example">

-- use 'symbolic'
Sym = require 'lib.symbolic'

-- create variables
x, y = Sym('x'), Sym('y')
ans = (x == y)            --> false

-- sum
ans = x + 2*y - x + y     --> 3*y

-- product
ans = x * y^2 / x * y     --> y^3

-- power
ans = x^y * x^(2*y)       --> x^(3*y)

-- evaluate
S = (x+y)*(x-y)
ans = S:eval{x=2, y=1}    --> Sym(3)

-- define function
foo = Sym:def('foo', {x, y}, x^y)
ans = foo(y, x)           --> y^x

-- numeric value
ans = foo(Sym(2), Sym(3)) --> Sym(8)


--</pre>
<a href="#Top">Top</a></div>
<div><a name="Unit"></a>
<h3># Unit (units) #</h3>
<p class="descript">Operations and conversations according the units.</p>
<p><b>Unit([v,]s)</b> - Create new elements with units.<br>
<b>Unit:setRule(s,U)</b> - Add new rule for conversation.<br>
<b>arithmetic</b> - U1+U2, U1-U2, U1*U2, U1/U2, U1^N<br>
<b>comparison</b> - U1==U2, U1~=U2, U1<U2, U1<=U2, U1>U2, U1>=U2<br>
<b>convert(s)</b> - Convert one units to another, return new object or nil.<br>
<b>copy()</b> - Create copy of the element.<br>
<b>key()</b> - Get units.<br>
<b>prefix</b> - Table of possible prefixes for units.<br>
<b>value()</b> - Get object value. Same as #U.<br></p>
<pre class="example">

-- use 'units'
Unit = require 'lib.units'

-- add some rules
Unit:setRule('h', Unit(60,'min'))
Unit:setRule('min', Unit(60,'s'))

-- define variable
a = Unit(1,'m/s')
-- convert to km/h, get only value
ans = a['km/h']              --2> 3.6

-- get numerical value
-- (the save as #a)
ans = a:value()               --> 1

-- get units
ans = a:key()                 --> 'm/s'

-- make copy
cp = a:copy()
ans = cp                      --> Unit(1,'m/s')

-- get converted variable
b = a:convert('km/h')
ans = b                       --> Unit(3.6, 'km/h')

-- arithmetic
b = 3 * b
ans = a + b                   --> Unit(4, 'm/s')

ans = b - a                   --> Unit(2, 'm/s')

ans = a * b                   --> Unit(3, 'm^2/s^2')

ans = b / a                   --> Unit(3, '')

ans = (a < b)                 --> true

ans = b ^ 3                   --> Unit(27, 'm^3/s^3')

-- new rule
Unit:setRule('snake', Unit(48, 'parrot'))
-- define variable
c = Unit(2,'snake')
-- convert
ans = c['parrot']             --> 96

-- convert using prefix
ans = c['ksnake']            --3> 0.002

-- another definition syntax
ans = 2 * Unit('N')           --> Unit(2,'N')

-- show result
print(a)
--</pre>
<a href="#Top">Top</a></div>
<div><p align="center"><i>2017-2022, Stanislav Mikhel</i></p></div>
</body></html>