<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Sonata Help</title>
</head><body>
<style type="text/css">
H3 {text-align:center;}
P {line-height:1.3;}
UL {column-count: 4; border: 2px solid blue; border-radius: 5px; padding: 5px 5px 5px 30px;}
DIV {margin-left: 10px;}
.EXAMPLE {border: 2px solid blue; border-radius: 5px; background: lightgrey; padding: 15px; margin: 10px 0px; color:navy; }
.DESCRIPT {text-align:center; font-style:italic; }
</style>
<a name="Top"></a>
<div><h1 align="center">Sonata Lua Calculus</h1>
<ul>
<li><a href="#Arr">array</a></li>
<li><a href="#Ap">asciiplot</a></li>
<li><a href="#Int">bigint</a></li>
<li><a href="#_Z">complex</a></li>
<li><a href="#_C">const</a></li>
<li><a href="#_D">data</a></li>
<li><a href="#Geo">geodesy</a></li>
<li><a href="#Gp">gnuplot</a></li>
<li><a href="#Graph">graph</a></li>
<li><a href="#Lens">lens</a></li>
<li><a href="#Main">main</a></li>
<li><a href="#Mat">matrix</a></li>
<li><a href="#Num">numeric</a></li>
<li><a href="#Poly">polynomial</a></li>
<li><a href="#Quat">quaternion</a></li>
<li><a href="#Rat">rational</a></li>
<li><a href="#Spec">special</a></li>
<li><a href="#Sym">symbolic</a></li>
<li><a href="#Unit">units</a></li>
</ul></div>
<div><h3># About #</h3>
<p><br>
'Sonata' is a Lua based program for mathematical calculations.<br>
<br>
<b>USAGE</b>:<br>
	lua [-i] sonata.lua [flag] [arg1 arg2 ...]<br>
(option '-i' can be used for working in native Lua interpreter)<br>
<br>
<b>FLAGS</b>:<br>
	-h	Get this help message.<br>
	-e	Evaluate command line expression.<br>
		e.g. -e "2+2"<br>
<br>
	--doc	Creating/updating a documentation file.<br>
		e.g. --doc ru<br>
	--lang	Creating/updating a file for localization.<br>
		e.g. --lang eo<br>
	--test	Apply the unit tests to the desired module. Call all modules if the name is not defined.<br>
		e.g. --test array<br>
	--new	Create template file for a new module.<br>
		e.g. --new  matrices  Mat  "Matrix operations."<br>
	 No flag  - Evaluate file(s).<br>
<br>
<b>VERSION</b>: 0.9.32<br>
<br>
<b>MODULES</b>: graph, asciiplot, data, complex, polynomial, special, matrix, gnuplot, symbolic, main, array, quaternion, geodesy, bigint, lens, numeric, rational, units, const.<br>
<br>
<b>BUGS</b>: mail to 'mikhel.sk@gmail.com'<br>
</p>
<p><a href="https://github.com/mikhel1984/sonata/wiki">Project Wiki</a></p></div>
<div><a name="Arr"></a>
<h3># Arr (array) #</h3>
<p class="descript">Операции с массивами, т.е. многомерными упорядоченными последовательностями элементов. Индексы задаются в виде таблицы. Индексация с единицы.</p>
<p><b>Arr {n1,n2,..}</b> - Создаёт пустой массив заданного размера.<br>
<b>Arr:zip(fn, ...)</b> - Применяет функцию к списку массивов для получения нового массива.<br>
<b>capacity()</b> - Возвращает максимальное число элементов в массиве. Эквивалентно #A.<br>
<b>comparison</b> - a == b, a ~= b<br>
<b>concat(A,iAxis)</b> - Формирует новый массив путём объединения двух исходных по заданной оси.<br>
<b>copy()</b> - Возвращает копию массива.<br>
<b>dim()</b> - Возвращает размерность массива.<br>
<b>get(tInd)</b> - Возвращает значение заданного элемента.<br>
<b>ipairs()</b> - Итератор, который при каждом вызове возвращает индекс и элемент множества.<br>
<b>isEqual(A)</b> - Сравнение размерностей массивов.<br>
<b>map(fn)</b> - Формирует новый массив путём применения функции к элементам исходного.<br>
<b>set(tInd,v)</b> - Присваивание значения заданному элементу.<br>
<b>sub(tInd1,tInd2)</b> - Возвращает массив, ограниченный двумя индексами.<br></p>
<pre class="example">

-- use 'array'
Arr = require 'lib.array'

-- empty array
a = Arr {2,3,4}
ans = a:get{1,2,1}            --> nil

-- set values
a:set({1,2,1},4)
ans = a:get{1,2,1}            --> 4

-- random array
rnd = function () return math.random() end
b = Arr{5,2,1}:map(rnd)
-- max number of elements
ans = #b                      --> 10

-- compare sizes
ans = b:isEqual(Arr{5,2,1})   --> true

-- compare elements
ans = (b == b:copy())         --> true

-- get sub array
g = a:sub({1,1,1},{-1,-1,2})
ans = g:isEqual(Arr{2,3,2})   --> true

-- apply function with indeces
eye = function (x,t) return (t[1]==t[2] and t[1]==t[3]) and 1 or 0 end
f = Arr{3,3,3}:map(eye)
ans = f:get{2,2,2}            --> 1

-- apply function of several arguments
a1 = Arr{2,2}:map(rnd)
a2 = Arr{2,2}:map(rnd)
a3 = Arr{2,2}:map(rnd)
-- 'lazy' function definition
a4 = Arr:zip('x1*x2+x3', a1,a2,a3)
ans = a4:get{1,2}             --> a1:get{1,2}*a2:get{1,2}+a3:get{1,2}

-- iterate over array
g = Arr {2,2}
g:set({1,1}, 1)
g:set({2,1}, 2)
g:set({1,2}, 3)
g:set({2,2}, 4)
-- show
for ind, val in g:ipairs() do
  io.write('{',ind[1],',',ind[2],'}\t',val, '\n')
end

-- simple iteration
n = g:capacity()   -- number of elements
for i = 1,n do
  io.write(i,':',g[i],'\n')
end

-- concatenate along the 3-rd axes
d = b:concat(b,3)
-- size for given dimension
ans = d:dim()[3]              --> 2

-- simple print
print(a)

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Ap"></a>
<h3># Ap (asciiplot) #</h3>
<p class="descript">Визуализация данных с помощью псевдо-графики.</p>
<p><b>Ap([iWidth=75,iHeight=23])</b> - Новый график.<br>
<b>Ap:concat(...)</b> - Горизонтальное объединение графиков равного размера. Для двух объектов можно использовать оператор '..' .<br>
<b>addPoint(dx,dy,s)</b> - Добавить точку с координатами (dx,dy) с помощью символа 's'.<br>
<b>addPose(ir,ic,s)</b> - Установка символа s в указанную позицию.<br>
<b>addString(ir,ic,s)</b> - Добавление строки в указанную позицию.<br>
<b>bar(t,[vy=2,ix=1])</b> - Столбчатая диаграмма. vy может быть индексом y в таблице t либо списком y-в.<br>
<b>contour(F,fn,[{view='XY'}])</b> - Find contours of projection for a function fn(x,y).<br>
<b>copy()</b> - Возвращает копию объекта.<br>
<b>plot(...)</b> - Построение графиков данных для аргументов типа 't', 't1,t1', 'fn,nm', 'fn1,fn2' и т.д.<br>
<b>reset()</b> - Очистка холста.<br>
<b>scale(factor,[bDefault=false])</b> - Изменить размер графика относительно начальных размеров.<br>
<b>tplot(t,[{yfix=false}])</b> - Plot the table data, choose columns if need.<br></p>
<pre class="example">

-- use 'asciiplot'
Ap = require 'lib.asciiplot'

-- figure with default size
fig1 = Ap()
print(fig1.width, fig1.height)

-- print functions
fig1.xrange = {-3.14, 3.14}   -- default is (-1,1)
fig1:plot(math.sin, 'sin', math.cos, 'cos')
fig1.title = 'Trigonometry'
print(fig1)

-- print data
x = {1,2,3,4,5}
y = {1,3,5,7,9}
print(fig1:plot(x,y))

-- combine different sources
fig1.yaxis = 'L'  -- left axis
fig1:plot(x,'single',x,y,'pair',math.log, 'function')
print(fig1)

-- define arbitrary figure size
-- odd is preferable
fig2 = Ap(21,11)    -- width=21, height = 11
print(fig2:plot(function (x) return 2*x end))

-- show table
tbl = {}
for x = 0, 3, 0.1 do
  --             x      y1          y2
  tbl[#tbl+1] = {x, math.sin(x), math.cos(x)}
end
fig2.xaxis = 'D'  -- down
print(fig2:tplot(tbl))

-- plot only y2, don't rescale
fig2.xrange = {-1, 4}
fig2.yrange = {0, 1}
print(fig2:tplot(tbl, {2, yfix=true}))

-- scale figure w.r.t. initial size
fig1:scale(0.8)
ans = fig1.width             --> 61

-- horizontal concatenation
-- first
fig1:scale(0.5, true)
fig1.xrange = {0, 1.57}
fig1.yaxis = 'C'; fig1.xaxis = 'D'
fig1:plot(sin, 'sin')
fig1.title = 'First'
-- second
fig2:scale(0.5, true)
fig2.xrange = {0, 1.57}
fig2:plot(cos, 'cos')
fig2.title = 'Second'
print(Ap:concat(fig1, fig2))   -- similar to fig1..fig2 for 2 objects

-- call 'API' functions
fig3 = Ap():scale(0.5)
fig3.xrange = {-2,2}
fig3.yrange = {-1,4}
-- no axes and limits
fig3.xaxis = nil; fig3.yaxis = nil
fig3:reset()
-- set function
for x = -1.2, 1.2, 0.1 do
  fig3:addPoint(x, x*x-0.5, Ap.char[1])
end
-- set to position
fig3:addPose(3, 13, '#')   -- characters
fig3:addPose(3, 24, '#')
fig3:addString(2,3,'Hi!')  -- text
print(fig3)

-- print surface contours
fig4 = Ap()
fig4.xrange = {-5, 5}
fig4.yrange = {-5, 5}
print(fig4:contour(function (x,y) return x*x - y*y end))

-- bar diagram
data = {}
k = 2*3.14/20
for i = 1, 20 do data[#data+1] = {k*i, math.sin(k*i)} end
fig5 = Ap()
print(fig5:bar(data))

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Int"></a>
<h3># Int (bigint) #</h3>
<p class="descript">Вычисления с целыми числами произвольной длины.</p>
<p><b>Int(v)</b> - Создаёт большое целое число на основе числа, строки или таблицы.<br>
<b>Int:random(B)</b> - Псевдо-случайное число от 0 до B.<br>
<b>abs()</b> - Возвращает модуль числа.<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, a%b, a^b, -a, #a<br>
<b>at(N)</b> - Возвращает цифру в позиции N.<br>
<b>base()</b> - Возвращает основание системы счисления.<br>
<b>comparison</b> - a<b, a<=b, a>b, a>=b, a==b, a~=b<br>
<b>eq(B)</b> - Проверка равенства двух чисел.<br>
<b>fact()</b> - Вычисляет факториал целого неотрицательного числа.<br>
<b>factorize()</b> - Возвращает список простых множителей для данного числа.<br>
<b>float()</b> - Представление в виде числа с плавающей точкой.<br>
<b>gcd(B)</b> - Наибольший общий делитель.<br>
<b>isPrime([sMethod])</b> - Проверка числа на простоту. Установите метод 'Fermat' для использования малой теоремы Ферма.<br>
<b>rebase(N)</b> - Конвертирует число в новую систему счисления.<br></p>
<pre class="example">
-- use 'bigint'
Int = require 'lib.bigint'

-- from integer
a = Int(123)
ans = a:float()               --> 123

-- from string
b = Int('456')
ans = b:float()               --> 456

-- from table
-- 'sign' and 'base' can be skipped
g = Int {1,2,3,sign=-1,base=10}
ans = g:float()               --> -123

-- check equality
ans = (a == -g)               --> true

-- arithmetical operations
ans = (a+b):float()           --> 579

ans = (a-b):float()           --> -333

ans = (a*Int(2)):float()      --> 246

ans = (b/2):float()           --> 228

ans = (b%a):float()           --> 87

ans = (a^3):float()           --> 1860867

-- absolute value
ans = Int('-25'):abs():float()  --> 25

-- factorial
c = Int(10):fact()
ans = c:float()               --> 3628800

ans = (a > b)                 --> false

-- compare with number
ans = a:eq(123)               --> true

-- number of digits
ans = #a                      --> 3

-- 2nd digit (from the lowest)
ans = a:at(2)                 --> 2

-- get numeric base
ans = g:base()                --> 10

-- change numeric base
v = g:rebase(60)
ans = tostring(v)             --> '-2|3'

-- operations with different bases
-- transform to the biggest common base
w = v + b
ans = tostring(w)             --> '5|33'

-- comparison
ans = (v == g)                --> true

-- simple print
print(a)

-- check if it prime
-- iterate though multipliers
ans = Int(1229):isPrime()       --> true

-- Fermat theorem
ans = Int(1229):isPrime('Fermat') --> true

-- factorize
t = b:factorize()
ans = #t                      --> 5

-- check factorization
ans = 1
for i = 1,#t do
  ans = ans * (t[i]:float())
end                           --> 456

-- pseudo-random number
-- from 0 to b
print(Int:random(b))

-- greatest common divisor
ans = a:gcd(b):float()        --> 3

-- with numbers
-- result is bigint
ans = a + 1.0                 --> Int(124)

-- result is float
ans = a - 0.5                 --> 122.5

--</pre>
<a href="#Top">Top</a></div>
<div><a name="_Z"></a>
<h3># _Z (complex) #</h3>
<p class="descript">Вычисления с комплексными числами.</p>
<p><b>_Z([vRe=0,vIm=0])</b> - Создание комплексного числа.<br>
<b>_Z:i([v=1])</b> - Возвращает комплексное число v*i.<br>
<b>_Z:trig(vModule,vAngle)</b> - Создание комплексного числа по модули и агрументу.<br>
<b>abs()</b> - Модуль комплексного числа.<br>
<b>acos()</b> - Комплексный обратный косинус.<br>
<b>acosh()</b> - Комплексный обратный гиперболический косинус.<br>
<b>arg()</b> - Возвращает агрумент комплексного числа.<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, a^b, -a<br>
<b>asin()</b> - Комплексный обратный синус.<br>
<b>asinh()</b> - Комплексный обратный гиперболический синус.<br>
<b>atan()</b> - Комплексный обратный тангенс.<br>
<b>atanh()</b> - Комплексный обратный гиперболический тангенс.<br>
<b>comparison</b> - a==b, a~=b<br>
<b>conj()</b> - Комплексно-сопряженное число. Эквивалентно ~C.<br>
<b>cos()</b> - Комплексный косинус.<br>
<b>cosh()</b> - Комплексный гиперболический косинус.<br>
<b>exp()</b> - Комплексная экспонента.<br>
<b>im()</b> - Мнимая часть.<br>
<b>log()</b> - Комплексный логарифм.<br>
<b>re()</b> - Действительная часть.<br>
<b>round([N=6])</b> - Возвращает число с округлением до заданного количества знаков.<br>
<b>sin()</b> - Комплексный синус.<br>
<b>sinh()</b> - Комплексный гиперболический синус.<br>
<b>sqrt()</b> - Комплексный квадратный корень.<br>
<b>tan()</b> - Комплексный тангенс.<br>
<b>tanh()</b> - Комплексный гиперболический тангенс.<br></p>
<pre class="example">

-- use 'complex'
_Z = require 'lib.complex'

-- real and imaginary pars
a = _Z(1,2)
-- or just imaginary
b = _Z(0,3)

-- imaginary unit
ans = 3+_Z:i(4)                --> _Z(3,4)

-- use trigonometrical form
ans = _Z:trig(2,0)            --> _Z(2,0)

-- arithmetic
ans = a + b                   --> _Z(1,5)

ans = _Z:i(3) - b             --> 0

ans = a * b                   --> _Z(-6,3)

ans = a / _Z:i()              --> _Z(2,-1)

-- power can be complex
c = _Z(1,1)^_Z(2,-2)

-- real part
ans = c:re()                 --3> 6.147

-- imaginary part
ans = c:im()                 --1> 7.4

-- comparison
ans = (a == b)                --> false

ans = (a ~= b)                --> true

-- absolute value
ans = a:abs()                --3> 2.236

-- argument
ans = a:arg()              --3> 1.107

-- conjugated number
ans = a:conj()                --> _Z(1,-2)

-- some functions after import
-- become default, such as
d = _Z(-2):sqrt()
ans = d:im()                  --3> 1.414

-- exp
ans = d:exp():re()            --3> 0.156

-- log
ans = d:log():re()            --3> 0.3465

-- sin
ans = d:sin():im()            --3> 1.935

-- cos
ans = d:cos():re()            --3> 2.178

-- tan
ans = d:tan():re()            --1> 0

-- sinh
ans = d:sinh():re()           --1> 0

-- cosh
ans = d:cosh():re()           --3> 0.156

-- tanh
ans = d:tanh():im()           --3> 6.334

-- asin
z = _Z(2,3)
ans = z:asin():im()          --3> 1.983

-- acos
ans = z:acos():re()          --2> 1.000

-- atan
ans = z:atan():im()          --3> 0.229

-- asinh
ans = z:asinh():re()         --3> 1.968

-- acosh
ans = z:acosh():im()         --1> 1.000

-- atanh
ans = z:atanh():re()         --3> 0.146

-- round in-place
z = _Z(1+1E-3, 2+1e-20)
z = z:round(5)
ans = z:re()                 --3> 1.001

ans = z:im()                  --> 2

-- show
print(a)

--</pre>
<a href="#Top">Top</a></div>
<div><a name="_C"></a>
<h3># _C (const) #</h3>
<p class="descript">Разнообразные константы.</p>
<p><b>_C:add(sName,value,[sUnits])</b> - Добавление временной константы.<br>
<b>_C:remove(sName)</b> - Удаление константы.<br>
<b>astro.au</b> - Астрономическая единица.<br>
<b>astro.ly</b> - Световой год.<br>
<b>astro.pc</b> - Один парсек.<br>
<b>math.e</b> - Основание натурального логарифма.<br>
<b>math.phi</b> - Золотое сечение.<br>
<b>math.pi</b> - Отношение длины окружности к её диаметру.<br>
<b>phi.Da</b> - Атомная единица массы.<br>
<b>phy.G</b> - Гравитационная постоянная.<br>
<b>phy.NA</b> - Число Авогадро.<br>
<b>phy.R</b> - Универсальная газовая постоянная.<br>
<b>phy.Rinf</b> - Постоянная Ридберга.<br>
<b>phy.Vm</b> - Объём моля идеального газа.<br>
<b>phy.c</b> - Скорость света.<br>
<b>phy.e</b> - Заряд электрона.<br>
<b>phy.eps0</b> - Электрическая постоянная.<br>
<b>phy.g</b> - Ускорение свободного падения.<br>
<b>phy.h</b> - Число планка.<br>
<b>phy.k</b> - Постоянная Больцмана.<br>
<b>phy.mu0</b> - Магнитная постоянная.<br>
<b>phy.sigma</b> - Постоянная Стефана-Больцмана.<br></p>
<pre class="example">

-- use 'const'
_C = require 'lib.const'
-- external dependencies, can be loaded implicitly
require 'lib.units'  -- convert into Unit object

-- charge of electron
ans = _C.phy.e * 1E19        --3> 1.602

-- convert to Unit object (add _U)
e = _C.phy.e_U
ans = e:key()                 --> _C.phy.e_u_

-- change units
ans = e['nC']                --3> _C.phy.e * 1E9

-- create "immutable" value
_C:add('myConst', 10)
ans = _C.myConst              --> 10

-- modification generates error
ans = pcall(function() _C.myConst = 0 end)  --> false

-- remove constant
_C:remove('myConst')
ans = _C.myConst              --> nil

--</pre>
<a href="#Top">Top</a></div>
<div><a name="_D"></a>
<h3># _D (data) #</h3>
<p class="descript">Обработка данных и статистические расчёты.</p>
<p><b>_D:Fn(sExpr,[iArg=2])</b> - Генерирует функцию из строки с параметрами x1, x2 и т.д.<br>
<b>_D:cov(t)</b> - Возвращает матрицу ковариации для списка векторов.<br>
<b>_D:cov2(t1,t2)</b> - Вычисляет ковариацию для двух списков.<br>
<b>_D:csvread(sFile,[delim=',',bCol=false])</b> - Формирует таблицу на основе файла с заданным разделителем.<br>
<b>_D:csvwrite(sFile,t,[char=',',bCol=false])</b> - Сохраняет таблицу в файл с заданным разделителем.<br>
<b>_D:filter(t,vCond)</b> - Вильтрует список данных. Условием является булева функция или массив весов.<br>
<b>_D:freq(t)</b> - Возвращает таблицу частот элементов.<br>
<b>_D:geomean(t,[tw])</b> - Геометрическое среднее.<br>
<b>_D:harmmean(t,[tw])</b> - Гармоническое среднее.<br>
<b>_D:histcounts(X,[rng=10])</b> - Распределение данных по интервалам. Можно указать число интервалов разбиения, либо задать границы в виде таблицы.<br>
<b>_D:is(t,fn)</b> - Возвращает массив весов на основе булевой функции.<br>
<b>_D:isNot(t,fn)</b> - Возвращает инвертированные веса для булевой функции.<br>
<b>_D:max(t)</b> - Максимальный элемент и его индекс.<br>
<b>_D:mean(t,[tw])</b> - Вычисляет среднее значение.<br>
<b>_D:median(t)</b> - Возвращает медиану распределения.<br>
<b>_D:min(t)</b> - Возвращает наименьший элемент и его индекс.<br>
<b>_D:moment(N,t,[tw])</b> - Центральный момент t порядка N (с весами tw).<br>
<b>_D:ref(t,[iBeg=1,iEnd=#t])</b> - Возвращает "ссылку" на таблицу элементов.<br>
<b>_D:std(t,[tw])</b> - Возвращает стандартное отклонение и дисперсию.<br>
<b>_D:sum(t)</b> - Возвращает сумму элементов.<br>
<b>_D:tcdf(d,N)</b> - Распределение Стьюдента.<br>
<b>_D:tpdf(d,N)</b> - Плотность распределения Стьюдента.<br>
<b>_D:xEq(d)</b> - Возвращает функцию для условия x == d.<br>
<b>_D:xGt(d)</b> - Возвращает функцию для условия x > d.<br>
<b>_D:xIn(d1,d2)</b> - Возвращает функцию для условия d1 <= x <= d2.<br>
<b>_D:xLt(d)</b> - Возвращает функцию для условия x < d.<br>
<b>_D:zip(fn,...)</b> - Последовательно применяет функцию к списку векторов.<br></p>
<pre class="example">

-- use 'data'
_D = require 'lib.data'
-- external dependencies, can be loaded implicitly
require 'lib.special'
require 'lib.matrix'

-- initial data (tables)
X = {3,2,5,6,3,4,3,1}
-- weight
w = {1,1,0}
-- enought to define w[i] ~= 1
w[5] = 2; w[6] = 2
-- average
ans = _D:mean(X)           --3> 3.375

-- standard deviation
ans, tmp = _D:std(X,W)     --3> 1.495

-- variance
ans = tmp                    --3> 2.234

-- covariance for two vectors
Y = {0,2,1,3,7,5,8,4}
a = _D:cov2(X,Y)
ans = a                      --3> -0.65625

-- covariance matrix
tmp = _D:cov({X,Y})
ans = tmp[1][2]              --3> a

-- maximum element and index
_,ans = _D:max(X)           --> 4

-- median
ans = _D:median(X)          --> 3

-- table of frequencies
tmp = _D:freq(X)
ans = tmp[3]                  --> 3

-- central moment
ans = _D:moment(2,X)       --3> 2.234

-- summ of elements
ans = _D:sum(X)             --> 27

-- minimum value
ans = _D:min(X)             --> 1

-- geometrical mean
ans = _D:geomean(X)        --3> 2.995

-- harmonic mean
ans = _D:harmmean(X,W)     --3> 2.567

-- check if X[i] > 2
a = _D:is(X, _D:xGt(2))
ans = a[1]                    --> 1

-- get elements X[i] > 2
tmp = _D:filter(X, a)
ans = tmp[1]                  --> X[1]

-- filtration using explicit function
fn = function (x) return x > 2 end
tmp = _D:filter(X, fn)
ans = tmp[1]                  --> X[1]

-- generate new list
-- use 'lazy' function definition
tmp = _D:zip("{x1-x2,x1+x2}", X, Y)
ans = tmp[1][2]               --> X[1]+Y[1]

-- find histogram
a,b = _D:histcounts(X, 3)
ans = b[1]                    --> 2.25

-- define edges
a,b = _D:histcounts(X,{2,4,7})
ans = a[1]                    --> 1

-- table range reference
a = _D:ref(X, 3, 6)
ans = #a                      --> 4

ans = a[1]                    --> X[3]

-- Student cdf and pdf
ans = _D:tcdf(4, 2.5)      --3> 0.9805

ans = _D:tpdf(2, 3.3)      --3> 0.0672

-- dsv write
nm = os.tmpname()
-- separate elements with ';'
t = {{1,2,3},{4,5,6}}
_D:csvwrite(nm, t, ';')

-- dsv read
-- with separator ';'
tt = _D:csvread(nm, ';')
ans = tt[2][2]                --> 5

-- csv write by columns
_D:csvwrite(nm, t, ',', true)

-- csv read by columns
tt = _D:csvread(nm, ',', true)
ans = tt[1][3]                --> 3

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Geo"></a>
<h3># Geo (geodesy) #</h3>
<p class="descript">Преобразования координат и другие геодезические задачи.</p>
<p><b>A.blhInto[B]</b> - Возвращает функцию для преобразования геодезических координат из A в B с помощью метода Молоденского.<br>
<b>A.xyzInto[B]</b> - Возвращает функцию для преобразования геоцентрических координат из системы A в B.<br>
<b>Geo:deg2dms(d)</b> - Возвращает градусы, минуты и секунды для заданного угла в градусах.<br>
<b>Geo:dms2rad(d,[m=0,s=0])</b> - Преобразует градусы, минуты и секунды в радианы.<br>
<b>Geo:fromENU(tBLr,tXYZr,tTop)</b> - Преобразовать топоцентрические координаты точки в геоцентрические.<br>
<b>Geo:grav(dB)</b> - Международная формула гравитации, аргумент в радианах.<br>
<b>Geo:hashDecode(sHash)</b> - Определения положения зоны по геохэшу.<br>
<b>Geo:hashEncode(t[,N=6])</b> - Вычисления геохэша для точки.<br>
<b>Geo:toENU(tBLr,tXYZr,tCatr)</b> - Преобразовать геоцентрические координаты точки в топоцентрические.<br>
<b>projGK(tBL)</b> - Вовзращает северное и восточное положение точки в проекции Гаусса-Крюгера.<br>
<b>projM(tBL)</b> - Возвращает северное и восточное положение точки в проекции Меркатора.<br>
<b>solveDir(BLH,azimuth,dist)</b> - Решение прямой задачи геодезии, поиск положения и азимута второй точки при заданных начальной точке, направлении и расстоянии.<br>
<b>solveInv(BLH1,BLH2)</b> - Решение обратной задачи геодеции, поиск расстояния и азимутов для двух заданных точек.<br>
<b>toBLH(tXYZ)</b> - Приобразовать геоцентрические координаты в геодезические.<br>
<b>toXYZ(tBLH)</b> - Преобразует геодезические координаты в геоцентрические.<br></p>
<pre class="example">

-- use 'geodesy'
Geo = require 'lib.geodesy'

-- generate random from number -1 to 1
rnd = function () return 2*math.random()-1 end
-- random coordinates (degrees and meters)
t0 = {B=rnd()*90, L=rnd()*180, H=rnd()*1000}
-- latitude, longitude, height
print(t0.B, t0.L, t0.H)

--test in WGS84
wgs84 = Geo.WGS84
-- BLH to XYZ
t1 = wgs84:toXYZ(t0)
print(t1.X, t1.Y, t1.Z)

-- XYZ to BHL
t2 = wgs84:toBLH(t1)
print(t2.B, t2.L, t2.H)
ans = t2.B                 --3> t0.B

ans = t2.L                 --3> t0.L

ans = t2.H                 --3> t0.H

-- find topocentric coordinates
tg = {X=t1.X+10, Y=t1.Y+20, Z=t1.Z+30}
tc = Geo:toENU(t0, t1, tg)

-- back to cartesian
tg2 = Geo:fromENU(t0, t1, tc)
ans = tg2.X                --3> tg.X

-- transform XYZ from WGS84 to PZ90
pz90 = Geo.PZ90
-- get function
xyz_wgs84_pz90 = wgs84.xyzInto[pz90]
t3 = xyz_wgs84_pz90(t1)

-- backward transformation
xyz_pz90_wgs84 = pz90.xyzInto[wgs84]
t4 = xyz_pz90_wgs84(t3)
ans = t4.X                 --2> t1.X

-- datum transformation
blh_wgs84_pz90 = wgs84.blhInto[pz90]
t5 = blh_wgs84_pz90(t0)

-- Gauss-Kruger projection
sk = Geo.SK42
pt = {B=55.752, L=37.618}
t6 = sk:projGK(pt)
ans = t6.N                  --2> 6181924.245

ans = t6.E                  --2> 7413223.481

-- Merkator projection
t7 = wgs84:projM(pt)
print(t7.N, t7.E)

-- inverse problem
p1 = {B=rnd()*50, L=rnd()*50}
p2 = {B=rnd()*50, L=rnd()*50}
s, a1, a2 = wgs84:solveInv(p1,p2)
ans = (s >= 0)               --> true

-- direct problem
p3, a3 = wgs84:solveDir(p1,a1,s)
ans = a3                    --2> a2

ans = p3.B                  --2> p2.B

-- equator acceleration
ans = Geo:grav(0)           --1> 9.78

-- find geohash
h = Geo:hashEncode(p1, 7)
print(h)

-- position from geohash
p4, _ = Geo:hashDecode(h)
ans = p4.B                  --2> p1.B

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Gp"></a>
<h3># Gp (gnuplot) #</h3>
<p class="descript">Интерфейс для взаимодействия с Gnuplot.</p>
<p><b>Gp()</b> - Подготовка таблицы для Gnuplot.<br>
<b>Gp:plot(x1[,y1,nm,x2,..])</b> - 'x' - список чисел, 'y' - список или функция, 'nm' - имя кривой.<br>
<b>Gp:polarplot(x1,y1,[nm,x2,y2..])</b> - График в полярных координатах. 'x' - список чисел, 'y' - список либо функция, 'nm' - имя кривой.<br>
<b>Gp:surfplot(x1,y1,fn1,[nm,x2,y2..])</b> - Построение поверхности. 'x' и 'y' - списки чисел, 'fn' - функция двух агрументов, 'nm' - имя поверхности.<br>
<b>Gp:tplot(v[,x,y1,y2..])</b> - Построение графика на основе таблицы, матрицы или файла. Опциональные элементы определяют необходимые столбцы.<br>
<b>Gp:tpolar(v,[x,y1,y2..])</b> - График в полярных координатах для таблицы, матрицы или файла. Опциональные элементы определяют стоблцы.<br>
<b>Gp:tsurf(v,[x1,y1,z1,z2..])</b> - Построение графика поверхности на основе таблицы, матрицы или файла. Опциональные элементы определяют необходимые столбцы.<br>
<b>add(tCurve)</b> - Добавить функцию для построения.<br>
<b>copy()</b> - Возвращает копию параметров графика.<br>
<b>keys</b> -   Описание параметров:<br>
{math.sin, title='sin'}                      -- строит график для Lua функции, добавляет текст в легенду<br>
{'sin.dat', ln=1, lw=2}                      -- строит график для файла с учётом цвета и толщины маркеров<br>
{tbl, with='lines'}                          -- строит график для Lua таблицы с помощью линий<br>
title='Graph name'                           -- имя графика в целом<br>
xrange={0,10}                                -- диапазон x от 0 до 10<br>
yrange={-2,2}                                -- диапазон y<br>
zrange={0,5}                                 -- диапазон z<br>
trange={1,2}                                 -- изменение параметра в случае параметрической функции<br>
xtitle='A', ytitle='B'                       -- имена осей<br>
terminal='jpeg'                              -- сохранение результата в файл<br>
output='my_plot.jpg'                         -- имя файла для вывода результата<br>
parametric=true                              -- параметрическое представление функции<br>
size='square'                                -- установить квадратный размер изображения<br>
polar=true                                   -- график в полярных координатах<br>
grid='polar'                                 -- изменить тип сетки на полярный<br>
legend=false                                 -- отключить легенду<br>
surface=true                                 -- построение трёхмерного графика<br>
samples=200                                  -- задать число точек на графике<br>
raw='set pm3d'                               -- позволяет написать команды Gnuplot в явном виде<br>
<br>
<b>show()</b> - Строит график на основе параметров, представленных в виде таблицы Lua.<br></p>
<pre class="example">

-- use 'gnuplot'
Gp = require 'lib.gnuplot'
Gp.testmode = true -- just for testing

-- simple plot
t1 = {1,2,3,4,5}
t2 = {2,4,6,4,2}
-- in the dialog call "plot(t1,t2,'some curve')"
Gp:plot(t1,t2,'some curve')

-- simplified function plot
Gp:plot(t1, math.sin, 'sin')

-- name can be skipped
Gp:plot(t1, math.sin, t1, math.cos)

-- plot table (or matrix, or datafile)
arr = {}
for i = 1,50 do
  x = 0.1*i
  arr[i] = {x, math.sin(x), math.cos(x)}
end
-- all columns by default (for table and matrix)
Gp:tplot(arr)

-- the same, but with explicit column specification
Gp:tplot(arr,1,2,3)

-- in polar coordinate system
Gp:polarplot(t1,t2,'some curve')

-- from table
Gp:tpolar(arr,1,2)

-- plot surface
function fun(x,y) return x*x + y*y end
Gp:surfplot(t1,t2,fun,'some surf')

-- from table
arr2 = {}
for _,v1 in ipairs(t1) do
  for _,v2 in ipairs(t2) do
    arr2[#arr2+1] = {v1,v2,fun(v1,v2)}
  end
end
Gp:tsurf(arr2)

-- direct use Gp object
a = Gp()
a:add {math.sin, title='sin'}
a:add {math.cos, title='cos'}
a:show()

-- additional parameters
a.xrange = {0,10}   -- add rangle
-- save to file
a.terminal = 'png'
a.output = 'test.png'
a:show()

-- copy parameters to other object
b = a:copy()
print(b)

-- send 'raw' command to Gnuplot
c = Gp()
c.raw = 'plot x**2-2*x+1; set xlabel "X"; set ylabel "Y"'
c:show()

-- print Lua table
tmp = {
  {1,1},
  {2,2},
  {3,3},
  {4,4}
}
d = Gp()
d:add {tmp,with='lines'}
d:show()

-- define function
fn1 = function (x) return x^2-x end
f = Gp()
f:add {fn1,with='lines',title='x^2-x'}
f:show()

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Graph"></a>
<h3># Graph (graph) #</h3>
<p class="descript">Операции с графами.</p>
<p><b>Graph {v1,v2,..}</b> - Создает новый граф.<br>
<b>add(v)</b> - Добавляет узел (одиночное имя) или ребро. Ребро представлено списком, содержащим начало, конец и, при необходимости, вес (веса).<br>
<b>bfs(vStart,vGoal)</b> - Поиск в ширину. Возвращает флаг результата и найденный путь.<br>
<b>copy()</b> - Создаёт копию графа.<br>
<b>dfs(vStart,vGoal)</b> - Поиск в глубину. Возвращает флаг результата и найденный путь.<br>
<b>edges()</b> - Возвращает список рёбер.<br>
<b>isComplete()</b> - True если граф полный.<br>
<b>isDirected()</b> - True если граф направленный.<br>
<b>isNegative()</b> - True если граф содержит отрицательные веса.<br>
<b>isWeighted()</b> - True если граф взвешенный.<br>
<b>nodes()</b> - Возвращает список узвло графа.<br>
<b>pathBF(vStart,[vGoal])</b> - Поиск кратчайшего пути алгоритмом Беллмана-Форда. Возвращает таблицу расстояний и узлов. Если задана цель, возвращает путь и его длину.<br>
<b>pathD(vStart,[vGoal])</b> - Поиск кратчайшего пути алгоритмом Дейкстры. Возвращает таблицу расстояний и узлов. Если задана цель, возвращает путь и его длину.<br>
<b>remove(v)</b> - Удаляет узел или ребро. Узлы представляются именем, рёбра - двухэлементным списком.<br></p>
<pre class="example">

-- use 'graph'
Graph = require 'lib.graph'

-- build graph
-- single name - node, names in brackets - edges
-- letter w denotes weight of non directed edge
-- numbers are weights of directed edges
a = Graph {'a','b',
  {'a','c'},
  {'d','e',w=2},
  {'d','b',4,3}
}

-- list of nodes
nd = a:nodes()
ans = #nd                     --> 5

-- list of edges
-- if an edge has different weight for different sizes
-- it is represented twice
ed = a:edges()
ans = #ed                     --> 4

-- has directed edges
ans = a:isDirected()          --> true

-- add node
a:add('h')
-- add edge
a:add {'a','d'}
-- check size
-- (same as #a)
ans = a:size()                --> 6

-- remove edge
a:remove {'a','d'}
-- remove node
a:remove('a')
-- new edge number
ed = a:edges()
ans = #ed                     --> 3

-- directed edges
-- second way to define
-- from first to second node
a:add {'c','p',w12=2}
-- and vise versa
a:add {'c','q',w21=3}
ed = a:edges()
ans = #ed                     --> 5

-- make copy
b = a:copy()

-- completeness
ans = b:isComplete()          --> false

-- prepare graph
c = Graph {
  {'a','b'},
  {'a','c'},
  {'b','d'},
  {'b','e'},
  {'c','f'},
  {'f','g'},
  {'f','h'},
  {'e','g'}
}

-- is it weighted
ans = c:isWeighted()          --> false

-- breadth first search
_,path = c:bfs('e','h')
ans = path[3]                 --> 'f'

-- depth first search
found,path = c:dfs('d','c')
ans = found                   --> true

-- update weight (default is 1)
-- use 'add' method
c:add{'a','b',w=0.5}
c:add{'b','e',w=0.4}
c:add{'c','f',w=2}

-- Dijkstra path search
dist,prev = c:pathD('a')
ans = dist['g']               --> 1.9

-- Bellman-Ford path search
c:add{'f','h',w=-0.5}
dist,prev = c:pathBF('a')
ans = dist['h']

-- check negative edges
ans = c:isNegative()          --> true

-- show
print(b)

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Lens"></a>
<h3># Lens (lens) #</h3>
<p class="descript">Матричные методы в параксиальной оптике.</p>
<p><b>Lens {dA,dB,dC,dD}</b> - Новый объект с произвольными параметрами A, B, C, D.<br>
<b>Lens:afocal(dm)</b> - Возвращает матрицу для афокальной системы.<br>
<b>Lens:gausParam(dW0,dLam)</b> - Определение расходимости и размера ближней зоны пучка.<br>
<b>Lens:gaussSize(dW0,dLam,dist)</b> - Определение радиуса и кривизны гаусова пучка на заданном расстоянии.<br>
<b>Lens:mirror(dr,dn)</b> - Возвращает матрицу отражения на кривой поверхности с учётом показателя преломления.<br>
<b>Lens:ref(dr,dn1,dn2)</b> - Возвращает матрицу для преломления с учётом показателей преломления и радиуса кривизны поверхности.<br>
<b>Lens:solve(fn,ind,d0)</b> - Поиск условий, при которых компонент с заданным индексом равен 0. d0 - начальное предположение.<br>
<b>Lens:thin(df)</b> - Возвращает матрицу для тонкой линзы при заданном фокальном расстоянии.<br>
<b>Lens:trans(dt,dn)</b> - Возвращает матрицу перемещения с учётом показателя преломления.<br>
<b>beam(dW,dR,dLam)</b> - Определение радиуса и кривизны фронта гаусова пуска на выходе из системы.<br>
<b>cardinal([dn1=1,dn2=1])</b> - Поиск положения кардинальных точек системы относительно входных и выходных плоскостей, с учётом показателей преломления. Возвращает список расстояний.<br>
<b>copy()</b> - Возвращает копию объекта.<br>
<b>det()</b> - Возвращает определитель матрицы.<br>
<b>inv()</b> - Инвертированная матрица системы.<br>
<b>isUnit()</b> - Проверка, является ли матрица единичной.<br>
<b>operations</b> - L1 == L2, L1 .. L2<br>
<b>transform(dy,dV)</b> - Определяет положение луча 'dy' и оптический угол 'dV' (= v*n) на выходе оптической системы. Эквивалентно вызову L(dy,dV).<br></p>
<pre class="example">

-- use 'lens'
Lens = require 'lib.lens'
-- external dependencies, can be loaded implicitly
Num = require 'lib.numeric' -- for root searching

-- define a simple lense
n1 = 1      -- air
n2 = 1.56   -- glass
-- radius 200 mm, thickness 5 mm
lens1 = Lens:ref(200,n1,n2)..Lens:trans(5,n2)..Lens:ref(-200,n2,n1)
ans = lens1:isUnit()          --> true

-- get matrix element
ans = lens1.D                --2> 1

-- find cardinal points
pts = lens1:cardinal()
ans = pts.F1                 --2> -177.76

-- print points
print(pts)

-- object is located 250 mm to the left
-- from the lens, find position of
-- the image
d1 = 250
fn = function (d2)
  return Lens:trans(d1,n1)..lens1..Lens:trans(d2,n1)
end
-- solve for B = 0, initial guess dist = 100
d2 = Lens:solve(fn, Lens.key.B, 100)
ans = d2                     --2>  623.21

-- check solution
-- assume the lens it thin
f = -pts.F1
ans = 1/d1 + 1/d2            --2> 1/f

-- ray transformation
y1 = 10          -- mm, height
V1 = n1 * 0.05   -- optical angle
sys1 = fn(d2)
y2, V2 = sys1(y1,V1)
ans = y2                     --2> -24.83

-- from image to object
sys2 = sys1:inv()  -- transpose
ans, _ = sys2(y2, V2)        --3> y1

-- system matrix determinant
ans = lens1:det()            --3> 1

-- create thin lens
lens2 = Lens:thin(f)
_, V3 = lens1(y1,V1)
_, ans = lens2(y1,V1)        --2> V3

-- flat mirror
lens3 = Lens:mirror(math.huge, n1)
_, ans = lens3(y1,V1)        --2> V1

-- afocal system
m = 10
lens4 = Lens:afocal(m)
ans, _ = lens4(y1,V1)        --2> m*y1

-- arbitrary system matrix
lens5 = Lens {1, 0, -0.5, 1}
print(lens5)

-- make copy
ans = lens1:copy()            --> lens1

-- gaussian beam parameters
ans, _ = Lens:gaussParam(1E-3, 1.024E-6) --2> 3.26E-4

-- laser beam radius
ans, _ = Lens:gaussSize(1E-3, 1.024E-6, 100) --2> 0.033

-- laser beam transformation
ans, _ = lens1:beam(1E-3, 1E3, 1.024E-6)  --2> 1.44E-3

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Main"></a>
<h3># Main (main) #</h3>
<p class="descript">Программа для математических расчётов на Lua.</p>
<p><b>Map(fn,t)</b> - Вычисляет функцию для всех элементов списка (таблицы), возвращает новый список.<br>
<b>Print(...)</b> - Дополненная функция печати, показывает элементы таблицы, представляет числа в н "научно" виде.<br>
<b>Range(dBegin,dEnd,[dStep])</b> - Генерация диапазона чисел.<br>
<b>Round(f,[N=0])</b> - Округление числа до заданного количества десятичных знаков.<br>
<b>Run(sFile,[bInt=false])</b> - Выполнить lua- или note- файл. Установите флаг bInt для интерактивного выполнения.<br>
<b>Type(v)</b> - Печатает тип объекта, распознаёт типы, заданные в Sonata.<br>
<b>_ans</b> - Результат последней операции.<br>
<b>_e</b> - Число Эйлера.<br>
<b>_pi</b> - Число pi.<br>
<b>abs(d)</b> - Абсолютная величина.<br>
<b>acos(d)</b> - Арккосинус x.<br>
<b>acosh(x)</b> - Гиперболический арккосинус.<br>
<b>asin(d)</b> - Арксинус x.<br>
<b>asinh(x)</b> - Гиперболический арксинус.<br>
<b>atan2(dy,dx)</b> - Арктангенс dy/dx с учётом знака.<br>
<b>atanh(x)</b> - Гиперболический арктангенс.<br>
<b>cos(d)</b> - Косинус x.<br>
<b>cosh(d)</b> - Гиперболический косинус.<br>
<b>exp(d)</b> - Экспонента.<br>
<b>log(dPos)</b> - Натуральный логарифм.<br>
<b>rand()</b> - Случайное число от 0 до 1.<br>
<b>randi(N)</b> - Случайное целое число от 1 до N.<br>
<b>randn([dMean=0,dev=1])</b> - Нормально распределённая случайная величина с заданным средним значением и дисперсией.<br>
<b>sin(d)</b> - Синус x.<br>
<b>sinh(d)</b> - Гиперболический синус.<br>
<b>sqrt(dPos)</b> - Квадратный корень.<br>
<b>tan(d)</b> - Тангенс x.<br>
<b>tanh(d)</b> - Гиперболический тангенс.<br></p>
<pre class="example">

require 'lib.main'

-- constants starts from _
ans = _pi                     --> math.pi

-- standard functions
ans = exp(0)+sin(_pi/2)+cosh(0)  --1> 3.0

-- round number
ans = Round(0.9)              --> 1.0

-- save 2 digits
ans = Round(math.pi, 2)       --> 3.14

-- random between 0 and 1
p = rand()
ans = (p >= 0) and (p <= 1)   --> true

-- random integer (1 to 10)
p = randi(10)
ans = (p >= 1) and (p <= 10)  --> true

-- normal distributed random
print(randn())

-- get type
-- "knows" Sonata objects
ans = Type(25)                --> 'integer'

-- modified print function
a = {a=1,b=2, 3,4,5}
Print(a, 0.123)

-- generate 'sequence'
b = Range(1,3)
ans = b[3]                    --> 3

-- even numbers
b = Range(2,10,2)
ans = b[2]                    --> 4

-- linear transformations
-- with range Range objects
b2 = 2*b + 4
ans = b2[1]                   --> 8

-- calculate function values
c = Map(sin, b)
ans = c[1]                   --3> 0.909

-- use Lua functions if need
ans = math.floor(_pi)

ans = math.deg(_pi)

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Mat"></a>
<h3># Mat (matrix) #</h3>
<p class="descript">Операции с матрицами. На нулевые элементы память не расходуется. Индексация с единицы.</p>
<p><b>H()</b> - Сопряженная транспонированная матрица.<br>
<b>Mat {tRow1,tRow2,..}</b> - Создаёт матрицу на основе списка строк.<br>
<b>Mat:V({...})</b> - Преобразует список чисел в вектор.<br>
<b>Mat:eye(iRows,[iCols=iRows])</b> - Единичная матрица.<br>
<b>Mat:fill(iRows,iCols,[val=1])</b> - Создать матрицу, заполненную заданным числом.<br>
<b>Mat:zeros(rows,[cols=rows])</b> - Формирует матрицу нулей.<br>
<b>Mat:zip(fn,M1,M2,...)</b> - Поэлементно применяет функцию к матрицам для формирования новой матрицы.<br>
<b>T()</b> - Транспонирование матрицы. Эквивалентно T().<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, a^b, -a<br>
<b>chol()</b> - Преобразование Холески для положительно определённой симметричной матрицы.<br>
<b>cols()</b> - Число столбцов.<br>
<b>comparison</b> - a==b, a~=b<br>
<b>concat(M,sDir)</b> - Объединяет две матрица горизонтально (dir='h') или вертикально (dir='v').<br>
Горизонтальная конкатенация доступна в виде M1 .. M2, а вертикальная - M1 // M2.<br>
<b>copy()</b> - Возвращает копию матрицы.<br>
<b>cross(V)</b> - Векторное произведение 3-элементных векторов.<br>
<b>det()</b> - Определитель матрицы.<br>
<b>diag()</b> - Извлекает диагональные элементы либо формирует новую матрицу из вектора. n - индекс диагонали.<br>
<b>dot(V)</b> - Скалярное произведение векторов.<br>
<b>eig()</b> - Возвращает матрицы из собственных векторов и чисел.<br>
<b>insert(tR,tC,M)</b> - Вставляет матрицу в заданный диапазон строк и столбцов.<br>
<b>inv()</b> - Обратная матрица.<br>
<b>lu()</b> - LU преобразование матрицы. Возвращает L,U и P.<br>
<b>map(fn)</b> - Формирует новую матрицу путём применения указанной функции к исходной. Функция может зависеть как от элементов, f(x) так и от индексов f(x,row,col).<br>
<b>norm()</b> - Евклидова норма.<br>
<b>pinv()</b> - Вовзращает псевдо-обратную матрицу.<br>
<b>qr()</b> - QR разложение матрицы. Возвращает Q и R.<br>
<b>range(tR,tC)</b> - Возвращает подматрицу с заданным интервалом строк и столбцов.<br>
<b>rank()</b> - Возвращает ранг матрицы.<br>
<b>reshape([iRows=size,iCols=1])</b> - Изменить размер матрицы.<br>
<b>round([N=6])</b> - Округлить все элементы матрицы до заданного числа знаков.<br>
<b>rows()</b> - Число строк.<br>
<b>rref()</b> - Преобразование матрицы методом Гаусса.<br>
<b>table()</b> - Преобразует матрицу в обыкновенную Lua таблицу.<br>
<b>tr()</b> - След матрицы.<br></p>
<pre class="example">

-- use 'matrix'
Mat = require 'lib.matrix'

-- define matrix objects
a = Mat {{1,2},{3,4}}
b = Mat {{5,6},{7,8}}
-- call in typical way
ans = a[2][2]                 --> 4

b[1][1] = 5
-- transpose
c = a:T()
-- 'smart' getter
ans = c(1,-1)                 --> 3

-- matrix columns and rows
ans = a:cols()                --> 2

ans = a:rows()                --> 2

-- arithmetical operations
ans = a + b                   --> Mat {{6,8},{10,12}}

ans = b - a                   --> Mat {{4,4},{4,4}}

ans = a * b                   --> Mat {{19,22},{43,50}}

ans = a / b
-- determinant
ans = ans:det()              --2> 1

-- multiply to scalar
ans = 2 * a                   --> Mat {{2,4},{6,8}}

-- add scalar (to all elements)
ans = a - 1                   --> Mat {{0,1},{2,3}}

ans = a ^ 2                   --> Mat {{7,10},{15,22}}

-- determinant
ans = a:det()                 --> -2

-- inverse matrix
e = a:inv()
ans = e(2,1)                  --> 1.5

-- another call of inversion
e = a^-1
ans = e(2,1)                  --> 1.5

-- object copy
-- (it doesn't copy zeros)
f = a:copy()
ans = (f == a)                --> true

-- element-wise comparison
ans = (a == b)                --> false

-- identity matrix
ans = Mat:eye(2)              --> Mat {{1,0},
                                       {0,1}}

-- matrix argument
ans = Mat:eye(a)              --> Mat {{1,0},
                                       {0,1}}

-- matrix of zeros
ans = Mat:zeros(2,1)          --> Mat {{0},{0}}

-- matrix of constants = 4
ans = Mat:fill(2,3,4)         --> Mat {{4,4,4},
                                       {4,4,4}}

-- horizontal concatenation
ans = a .. b                  --> Mat {{1,2,5,6},
                                       {3,4,7,8}}

-- vertical concatenation
-- (a // b - for short)
ans = a:concat(b,'v')         --> Mat {{1,2},{3,4},{5,6},{7,8}}

-- apply function of 1 argument
ans = a:map(function (x) return x^2 end)       --> Mat {{1,4},{9,16}}

-- apply function which depends on index too
ans = a:map(function (x,r,c) return x-r-c end) --> Mat {{-1,-1},{-0,-0}}

-- apply function to matrices
-- element-wise
fn = function (x,y,z) return x*y+z end
aa = Mat:zip(fn, b,b,b)
ans = aa[1][1]                --> 30

-- use Gauss transform to solve equation
ans = (a .. Mat{{5},{11}}):rref()            --> Mat {{1,0,1},
                                                        {0,1,2}}

-- create vector
ans = Mat:V {1,2,3}           --> Mat {{1},{2},{3}}

-- get submatrix
g = Mat {
  {1,2,3},
  {4,5,6},
  {7,8,9}
}
-- same as g:range({2,-1},{2,3})
ans = g({2,-1},{2,3})         --> Mat {{5,6},
                                       {8,9}}

-- insert elements
gg = Mat:eye(3)
gg:insert({1,2},{1,2}, a)
ans = gg:range({1,2},{1,2})   --> a

-- euclidean norm
ans = Mat:V({1,2,3}):norm()  --3> math.sqrt(14)

-- random matrix
rnd = function () return math.random() end
h = Mat:zeros(2,3):map(rnd)
print(h)

-- round elements
noize = function (v) return v + math.random()*1E-8 end
hh = a:map(noize)
hh:round(3)
ans = hh                      --> a

-- pseudo inverse matrix
m = Mat {
  {1,2},
  {3,4},
  {5,6}
}
n = m:pinv()
ans = n(2,2)                 --3> 0.333

-- copy as Lua table
-- (without methametods)
k = Mat:eye(3)
k = k:table()
ans = k[2][1]                 --> 0

-- make diagonal matrix
ans = Mat:diag({1,2,3})       --> Mat {{1,0,0},
                                       {0,2,0},
                                       {0,0,3}}

-- get diagonal
ans = g:diag()               --> Mat {{1},{5},{9}}

-- cross-product of 2 vectors
x1 = Mat {{1,2,3}}
x2 = Mat {{4,5,6}}
ans = x1:cross(x2)            --> Mat {{-3},{6},{-3}}

-- dot product of 2 vectors
ans = x1:dot(x2)              --> 32

-- LU decomposition
l,u,p = b:lu()
ans = l[2][1]                --3> 0.714

-- QR decomposition
q,r = m:qr()
ans = (q*r)[2][2]            --3> m[2][2]

ans = q:det()                --3> 1.0

-- Cholesky decomposition
m = Mat {{3,1},{1,3}}
m = m:chol()
ans = m[2][2]                --3> 1.633

-- matrix trace
ans = a:tr()                  --> 5

-- extract first row
m = a({},1)
-- vector doesn't need in 2 indices
ans = m(1)                    --> 1

-- extract last column
-- index can be negative
m = a(-1,{})
ans = m(2)                    --> 4

-- get rank
ans = Mat:fill(2,3):rank()    --> 1

-- change size
tmp = Mat{
  {1,2},
  {3,4},
  {5,6}
}
ans = tmp:reshape(2,3)        --> Mat {{1,2,3},
                                       {4,5,6}}

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Num"></a>
<h3># Num (numeric) #</h3>
<p class="descript">Функции для численных расчётов. Все функции работают с точностью, определяемой параметром TOL.</p>
<p><b>Num:der(fn,x)</b> - Оценка производной функции в точке.<br>
<b>Num:newton(fn,d0)</b> - Find root of equation using Newton's rule with only one initial condition.<br>
<b>Num:ode45(fn,tDelta,y0,[param])</b> - Численное решение ОДУ.<br>
Первый параметр задаёт уравнение, второй - временной интервал, третий - начальное значение функции. Дополнительно можно определить такие параметры как шаг интегрирования и условие прерывания.<br>
Возвращает таблицу промежуточных точек и конечное значение yn.<br>
<b>Num:solve(fn,dA,dB)</b> - Поиск корня уравнения fn(x)=0 на интервале [a,b].<br>
<b>Num:trapez(fn,a,b)</b> - Интегрирование методом трапеций.<br>
<b>TOL[=0.001]</b> - Точность решения.<br></p>
<pre class="example">

-- use 'numeric'
Num = require 'lib.numeric'

-- define tolerance
Num.TOL = 1e-4
-- solve 'sin(x) = 0' for x in (pi/2...3*pi/2)
a = Num:solve(math.sin, math.pi*0.5, math.pi*1.5)
ans = a                      --3> math.pi

-- Newton method
-- only one initial value
d = Num:newton(math.sin, math.pi*0.7)
ans = d                      --3> math.pi

-- numeric derivative
b = Num:der(math.sin, 0)
ans = b                      --0> 1

-- numeric integral
c = Num:trapez(math.sin, 0, math.pi)
ans = c                      --0> 2

-- solve ODE x*y = x'
-- for x = 0..3, y(0) = 1
-- return table of solutions and y(3)
tbl, yn = Num:ode45(function (x,y) return x*y end,
                    {0,3}, 1)
ans = yn                     --2> 90.011

-- use matrices for high order equations
Mat = require 'lib.matrix'

-- y''-2*y'+2*y = 1
-- represent as: x1 = y, x2 = y'
-- so: x1' = x2, x2' = 1+2*x2-2*x1
myfun = function (t,x)
  return Mat:V {x(2), 1+2*x(2)-2*x(1)}
end
_, xn = Num:ode45(myfun, {0,2}, Mat:V{3,2}, {dt=0.2})
ans = xn(1)                  --2>  -10.54

-- define exit condition
-- from time, current and previous results
cond = function (time,current,previous)
  return current < 0.1
end
myfun = function (t,x) return -x end
y = Num:ode45(myfun, {0,1E2}, 1, {exit=cond})
ans = y[#y][1]               --2> 2.56

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Poly"></a>
<h3># Poly (polynomial) #</h3>
<p class="descript">Действия над полиномами.</p>
<p><b>Poly {..,v1,v0}</b> - Создаёт полином на основе списка коэффициентов.<br>
<b>Poly:build(root1,root2,...)</b> - Строит полином на основе списка корней.<br>
<b>Poly:char(M)</b> - Возвращает характеристический полином матрицы.<br>
<b>Poly:fit(tX,tY,N)</b> - Аппроксимация точек полиномом заданной степени.<br>
<b>Poly:lagrange(tX,tY)</b> - Интерполяция данных полиномом Лагранжа.<br>
<b>Poly:lin(tX,tY,[v0=0,vN=v0])</b> - Линейная интерполяция. Возвращает таблицу полиномов.<br>
<b>Poly:ppval(tP,d,[N]</b> - Вычисляет значение интерполяции из таблицы полиномов, можно использовать индекс полинома для ускорения расчёта.<br>
<b>Poly:spline(tX,tY)</b> - Интерполяция данных кубическими сплайнами. Возвращает таблицу полиномов.<br>
<b>Poly:taylor(v,vF,[vF',vF''..])</b> - Формирует полином Тейлора в окрестности заданной точки.<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, a^n, -a<br>
<b>comparison</b> - a==b, a~=b<br>
<b>copy()</b> - Возвращает копию полинома.<br>
<b>der()</b> - Первая производная полинома.<br>
<b>int([d0=0])</b> - Первообразная полинома, x0 - свободный коэффициент.<br>
<b>real()</b> - Возвращает список действительных корней полинома.<br>
<b>roots()</b> - Поиск действительных и комплексных корней полинома.<br>
<b>val(v)</b> - Вычисляет значение полинома в заданной точке. Эквивалентно вызаву P(x).<br></p>
<pre class="example">

-- use 'polynomial'
Poly = require 'lib.polynomial'
-- external dependencies, can be loaded implicitly
require 'lib.matrix'         -- in Poly.fit
Comp = require 'lib.complex' -- for complex roots

-- coefficients in ascendant order
a = Poly {1,2,4,3}
b = Poly {1,1}
-- polynomial value for x=0
ans = a:val(0)                --> 3

-- simplified call
ans = a(0)                    --> 3

-- coefficient for x^3
ans = a[3]                    --> 1

-- arithmetic
ans = a + b                   --> Poly {1,2,5,4}

ans = a - b                   --> Poly {1,2,3,2}

ans = b * b                   --> Poly {1,2,1}

ans = a / b                   --> Poly {1,1,3}

ans = a % b                   --> 0

ans = b ^ 3                   --> Poly {1,3,3,1}

-- integration
-- free coefficient is 0
ans = b:int()                 --> Poly {0.5,1,0}

-- derivative
ader = a:der()
-- and its value for x=1
ans = ader(1)                 --> 11

-- build polynomial using roots
ans = Poly:build(1,-1)        --> Poly {1,0,-1}

-- use complex roots
-- don't add conjugated toots
ans = Poly:build(1, Comp(2,3))  --> Poly {1, -5, 17, -13}

-- make copy and compare
c = a:copy()
ans = (a == c)                --> true

-- not equal
ans = (b == c)                --> false

-- find real roots
e = a:real()
ans = e[1]                   --1> -1.00

-- find all roots
g = Poly:build(2, Comp(3,4))
e = g:roots()
ans = e[2]:re()              --1> 3

-- fit curve with polynomial
-- of order 2
A={0,1,2,3}
B={-3,2,11,24}
p = Poly:fit(A,B,2)
ans = p(10)                  --0> 227.0

-- simple print
print(a)

-- human-friendly print
-- with variable 's' (default is 'x')
d = Poly {2,-2,1}
ans = d:str('s')              --> '2*s^2-2*s+1'

-- Lagrange polynomial
-- for tx(x)
X = {-1.5, -0.75, 0, 0.75, 1.5}
Y = {-14.101,-0.931596,0,0.931596,14.101}
p = Poly:lagrange(X,Y)
ans = p[3]                   --3> 4.83485

-- Taylor series
-- for exp(x) near 0
p = Poly:taylor(0, 1, 1, 1, 1)
ans = p(0.3)                 --2> math.exp(0.3)

-- linear interpolation
-- use constant values out the interval
p = Poly:lin(X,Y, Y[1], Y[#Y])
y1, n = Poly:ppval(p, 0.5)
ans = y1                     --2> 0.621

-- polynomial index
ans = n                       --> 4

-- simplify call when index is known
ans = Poly:ppval(p, 0.5, n)  --2> y1

-- cubic spline
p = Poly:spline(X, Y)
-- can be called without 'ppval'
ans = p(0.5)                 --2> -0.512

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Quat"></a>
<h3># Quat (quaternion) #</h3>
<p class="descript">Операции над кватернионами.</p>
<p><b>Quat {w,x,y,z}</b> - Новый кватернион.<br>
<b>Quat:fromAA(fAng,vAxe)</b> - Возвращает кватернион для заданного угла и оси вращения.<br>
<b>Quat:fromRot(M)</b> - Строит кватернион на основе угла поворота и оси вращения.<br>
<b>abs()</b> - Норма кватерниона.<br>
<b>arithmetic</b> - a + b, a - b, a * b, a ^ k, -a<br>
<b>comparison</b> - a == b, a ~= b<br>
<b>conj()</b> - Сопряжённый кватернион.<br>
<b>im()</b> - Возвращает таблицу мнимых элементов кватерниона.<br>
<b>inv()</b> - Возвращает крватернион, обратный к данному.<br>
<b>mat()</b> - Представление в виде эквивалентной матрицы.<br>
<b>normalize()</b> - Возвращает единичный кватернион.<br>
<b>re()</b> - Действительная часть (эквивалентно Q.w).<br>
<b>rotate(vec)</b> - Возвращает вектор, полученный при вращении с помощью заданного кватерниона.<br>
<b>slerp(Q,f)</b> - Сферическая линейная интерполяция двух кватернионов.<br>
<b>toAA()</b> - Возвращает угол поворота и ось вращения.<br>
<b>toRot()</b> - Возвращает эквивалентную матрицу вращения.<br>
<b>w()</b> - Действительная часть w.<br>
<b>x()</b> - Компонента x.<br>
<b>y()</b> - Компонента y.<br>
<b>z()</b> - Компонента z.<br></p>
<pre class="example">

-- use 'quaternion'
Quat = require 'lib.quaternion'
-- external dependencies, can be loaded implicitly
require 'lib.matrix'

-- quaternion
-- set {w,x,y,z}
a = Quat {1,2,3,4}
-- part of elements
b = Quat {w=3, x=4}
ans = b                       --> Quat{3,4,0,0}

-- conjugation
ans = a:conj()                --> Quat{1,-2,-3,-4}

-- real when imaginary are zeros
ans = a + a:conj()            --> 2

-- norm
ans = b:abs()                --1> 5.000

-- inversion
c = a*a:inv()
ans = c:w()                  --1> 1.000

-- arithmetic
ans = a+b                     --> Quat{4,6,3,4}

ans = a*b                     --> Quat{-5,10,25}

ans = 3*b                     --> Quat{9,12,0,0}

-- power
ans = b^3                     --> b * b * b

-- unit quaternion
a = a:normalize()
ans = a:abs()                --1> 1.000

-- unit power
aa = a^1.5
ans = aa:x()                 --3> 0.324

ans = aa:y()                 --3> 0.486

ans = aa:z()                 --3> 0.648

-- rotation matrix
m = a:toRot()
d = Quat:fromRot(m)
ans = (d-a):abs()            --1> 0.000

-- use angle
-- and axis
ang = 0.5
axis = {1,1,1}
f = Quat:fromAA(ang,axis)
ans,_ = f:toAA()             --3> ang

-- rotate vector
p = a:rotate({1,0,0})
ans = p[1]                   --3> -0.667

-- spherical interpolation
d = a:slerp(b,0.5)
ans = d:w()                  --3> 0.467

-- show
print(d)

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Rat"></a>
<h3># Rat (rational) #</h3>
<p class="descript">Операции с числами, представленными в виде дроби.</p>
<p><b>Rat(m,[n=1])</b> - Для создания рационального числа укажите числитель и (опционально) знаменатель.<br>
<b>Rat:from(f,[fErr=1E-3])</b> - Оценка дроби рациональным числом с заданной точностью.<br>
<b>Rat:fromCont(t)</b> - Преобразование цепной дроби в рациональное число.<br>
<b>Rat:gcd(va,vb)</b> - Наибольший общий делитель.<br>
<b>arithmetic</b> - R1+R2, R1-R2, R1*R2, R1/R2, -R, R1^R2<br>
<b>comparison</b> - R1<R2, R1<=R2, R1>R2, R1>=R2, R1==R2, R1~=R2<br>
<b>denom()</b> - Возвращает знаменатель.<br>
<b>eq(R)</b> - Проверка равенства двух чисел.<br>
<b>float()</b> - Представление рационального числа в десятичном виде.<br>
<b>num()</b> - Возвращает числитель.<br>
<b>toCont()</b> - Преобразование рационального числа в цепную дробь.<br></p>
<pre class="example">

-- use 'rational'
Rat = require 'lib.rational'

-- numerator, denominator
a = Rat(1,2)
-- only numerator
b = Rat(2)
ans = b                       --> Rat(2,1)

-- simplification
k = 234781
ans = Rat(2*k,3*k)            --> Rat(2,3)

-- arithmetic
ans = a + b                   --> Rat(5,2)

ans = 2 * a                   --> 1

ans = Rat(2,3)*Rat(3,2)       --> 1

ans = a / Rat(1,3)            --> Rat(3,2)

ans = a ^ 3                   --> Rat(1,8)

ans = 2 ^ a                  --3> 1.414

-- comparison
ans = (b == b)                --> true

ans = (a >= b)                --> false

-- greatest common division
ans = Rat:gcd(125,65)         --> 5

-- represent as decimal
ans = a:float()               --> 0.5

-- from decimal
ans = Rat:from(math.pi)       --> Rat(333, 106)

-- numerator
ans = b:num()                 --> 2

-- denominator
ans = b:denom()               --> 1

-- show
print(a)

-- result is rational
ans = a + 1                   --> Rat(3,2)

-- result is float
ans = a + 0.5                 --> 1

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Spec"></a>
<h3># Spec (special) #</h3>
<p class="descript">Специальные функции.</p>
<p><b>Spec:besseli(N,x)</b> - Модифицированная функция Бесселя In(x).<br>
<b>Spec:besselj(N,x)</b> - Функция Бесселя первого рода.<br>
<b>Spec:besselk(N,x)</b> - Модифицированная функция Бесселя Kn(x).<br>
<b>Spec:bessely(n,x)</b> - Функция Бесселя второго рода.<br>
<b>Spec:beta(z,w)</b> - Бета-функция.<br>
<b>Spec:betainc(x,a,b)</b> - Неполная бета-функция Ix(a,b).<br>
<b>Spec:betaln(z,w)</b> - Натуральный логарифм бета-функции.<br>
<b>Spec:dawson(x)</b> - Интеграл Доусона.<br>
<b>Spec:erf(x)</b> - Функция ошибки.<br>
<b>Spec:erfc(x)</b> - Дополнительная функция ошибки.<br>
<b>Spec:expint(n,x)</b> - Экспоненциальный интеграл En(x).<br>
<b>Spec:gamma(z)</b> - Гамма функция.<br>
<b>Spec:gammainc(x,N,[type='lower'])</b> - Неполная гамма-функция, P (lower - нижняя) или Q (upper - верхняя).<br>
<b>Spec:gammaln(z)</b> - Натуральный логарифм гамма-функции.<br>
<b>Spec:gammp(N,x)</b> - Неполная гамма-функция P(N,x).<br>
<b>Spec:gammq(N,x)</b> - Неполная гамма-функция Q(N,x) = 1-P(N,x).<br>
<b>Spec:legendre(n,x)</b> - Список коэффициентов полиномов Лежандра.<br></p>
<pre class="example">

-- use 'special'
Spec = require 'lib.special'

-- beta functions
ans = Spec:beta(3,4) * 1E2   --3> 1.667

ans = Spec:betaln(10,20)     --3> -19.115

ans = Spec:betainc(0.5, 2, 3.3)  --3> 0.7309

-- error functions
ans = Spec:erf(1)            --3> 0.8427

ans = Spec:erfc(0.5)         --3> 0.4795

-- Ei(x)
ans = Spec:expint(3.3) * 1E3     --3> 8.939

-- E3(x)
ans = Spec:expint(2, 5) * 1E4    --3> 9.965

-- gamma functions
ans = Spec:gamma(-1.5)       --3> 2.3633

ans = Spec:gammaln(100)      --3> 359.1342

ans = Spec:gammp(7.7, 2.3) * 1E3 --2> 3.85

ans = Spec:gammq(1.5, 4.8) * 1E2 --2> 2.23

-- another syntax
ans = Spec:gammainc(2.1, 0.3, 'upper') * 1E2 --3> 1.942

-- Bessel functions
ans = Spec:besselj(3, 1.5) * 1E2 --3> 6.096

ans = Spec:bessely(4, 0.8)   --3> -78.751

ans = Spec:besseli(2, -3.6)  --3> 4.254

ans = Spec:besselk(5, 5) * 1E2   --3> 3.2706

-- Legendre function
lst = Spec:legendre(3, 0.5)
ans = lst[1]                 --3> -0.4375

-- Dawson function
ans = Spec:dawson(3.3)       --3> 0.1598

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Sym"></a>
<h3># Sym (symbolic) #</h3>
<p class="descript">Symbolical calculations.</p>
<p><b>Sym(v)</b> - Create new symbolic variable.<br></p>
<pre class="example">

-- use 'symbolic'
Sym = require 'lib.symbolic'

-- create variables
x, y = Sym('x'), Sym('y')
ans = (x == y)            --> false

-- sum
ans = x + 2*y - x + y     --> 3*y

-- product
ans = x * y^2 / x * y     --> y^3

-- power
ans = x^y * x^(2*y)       --> x^(3*y)

-- evaluate
S = (x+y)*(x-y)
ans = S:eval{x=2, y=1}    --> Sym(3)

-- define function
foo = Sym:def('foo', {x, y}, x^y)
ans = foo(y, x)           --> y^x

-- numeric value
ans = foo(Sym(2), Sym(3)) --> Sym(8)


--</pre>
<a href="#Top">Top</a></div>
<div><a name="Unit"></a>
<h3># Unit (units) #</h3>
<p class="descript">Операции с единицами измерения.</p>
<p><b>Unit([v,]s)</b> - Создание числа с единицами измерения.<br>
<b>Unit:setRule(s,U)</b> - Добавление нового правила преобразования единиц измерения.<br>
<b>arithmetic</b> - U1+U2, U1-U2, U1*U2, U1/U2, U1^N<br>
<b>comparison</b> - U1==U2, U1~=U2, U1<U2, U1<=U2, U1>U2, U1>=U2<br>
<b>convert(s)</b> - Преобразование единиц измерения, возвращает новый объект или nil.<br>
<b>copy()</b> - Создание копии объекта с его единицами измерения.<br>
<b>key()</b> - Возвращает единицы измерения.<br>
<b>prefix</b> - Таблица дольных и кратных приставок.<br>
<b>value()</b> - Возвращает значение объекта. Эквивалентно #U.<br></p>
<pre class="example">

-- use 'units'
Unit = require 'lib.units'

-- add some rules
Unit:setRule('h', Unit(60,'min'))
Unit:setRule('min', Unit(60,'s'))

-- define variable
a = Unit(1,'m/s')
-- convert to km/h, get only value
ans = a['km/h']              --2> 3.6

-- get numerical value
-- (the save as #a)
ans = a:value()               --> 1

-- get units
ans = a:key()                 --> 'm/s'

-- make copy
cp = a:copy()
ans = cp                      --> Unit(1,'m/s')

-- get converted variable
b = a:convert('km/h')
ans = b                       --> Unit(3.6, 'km/h')

-- arithmetic
b = 3 * b
ans = a + b                   --> Unit(4, 'm/s')

ans = b - a                   --> Unit(2, 'm/s')

ans = a * b                   --> Unit(3, 'm^2/s^2')

ans = b / a                   --> Unit(3, '')

ans = (a < b)                 --> true

ans = b ^ 3                   --> Unit(27, 'm^3/s^3')

-- new rule
Unit:setRule('snake', Unit(48, 'parrot'))
-- define variable
c = Unit(2,'snake')
-- convert
ans = c['parrot']             --> 96

-- convert using prefix
ans = c['ksnake']            --3> 0.002

-- another definition syntax
ans = 2 * Unit('N')           --> Unit(2,'N')

-- show result
print(a)
--</pre>
<a href="#Top">Top</a></div>
<div><p align="center"><i>2017-2022, Stanislav Mikhel</i></p></div>
</body></html>