<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Sonata LC Help</title>
</head><body>
<style type="text/css">
H3 {text-align:center;}
P {line-height:1.3;}
UL {column-count: 4; border: 2px solid blue; border-radius: 5px; padding: 5px 5px 5px 30px;}
DIV {margin-left: 10px;}
.EXAMPLE {border: 2px solid blue; border-radius: 5px; background: lightgrey; padding: 15px; margin: 10px 0px; color:navy; }
.DESCRIPT {text-align:center; font-style:italic; }
</style>
<a name="Top"></a>
<div><h1 align="center">Sonata Lua Calculus</h1>
<ul>
<li><a href="#Arr">array</a></li>
<li><a href="#Big">bigint</a></li>
<li><a href="#Comp">complex</a></li>
<li><a href="#_C">const</a></li>
<li><a href="#File">files</a></li>
<li><a href="#Gnu">gnuplot</a></li>
<li><a href="#Graph">graph</a></li>
<li><a href="#Mat">matrix</a></li>
<li><a href="#Num">numeric</a></li>
<li><a href="#Poly">polynom</a></li>
<li><a href="#Quat">quaternion</a></li>
<li><a href="#Rat">rational</a></li>
<li><a href="#Spec">special</a></li>
<li><a href="#Stat">stat</a></li>
<li><a href="#Unit">units</a></li>
</ul></div>
<div><h3># About #</h3>
<p><br>
'Sonata LC' is a Lua based program for mathematical calculations.<br>
<br>
<b>USAGE</b>:<br>
	lua [-i] sonata.lua [flag] [arg1 arg2 ...]<br>
(option '-i' could be used for working in native Lua interpreter)<br>
<br>
<b>FLAGS</b>:<br>
	--help, -h - Get this help message.<br>
		(Development)<br>
	--test   - Apply unit tests to desired module, or all modules if the name is not defined.<br>
	  (e.g. --test array)<br>
	--lang   - Create/update file for localization.<br>
	  (e.g. --lang eo)<br>
	--new    - Generate template for a new module.<br>
	  (e.g. --new  signal  Sig  "Signal processing functions.")<br>
	--doc    - Create/update documentation file.<br>
	 No flag  - Evaluate file(s).<br>
<br>
<b>VERSION</b>: 0.9.19<br>
<br>
<b>MODULES</b>: special, files, graph, numeric, array, complex, quaternion, rational, gnuplot, const, stat, matrix, bigint, polynom, units.<br>
<br>
<b>BUGS</b>: mail to 'SonataLC@yandex.ru'<br>
</p>
<p><a href="https://github.com/mikhel1984/sonata/wiki">Project Wiki</a></p></div>
<div><a name="Main"></a>
<h3># Main (main) #</h3>
<p class="descript">Lua based mathematics.</p>
<p><b>_ans</b> - Result of the last operation.<br>
<b>_e</b> - Euler number.<br>
<b>_pi</b> - Number pi.<br>
<b>abs(x)</b> - Absolute value.<br>
<b>acos(x)</b> - Inverse cosine x.<br>
<b>acosh(x)</b> - Hyperbolic arc cosine.<br>
<b>asin(x)</b> - Inverse sine x.<br>
<b>asinh(x)</b> - Hyperbolic inverse sine.<br>
<b>atan2(y,x)</b> - Inverse tangent of y/x, use signs.<br>
<b>atanh(x)</b> - Hyperbolic inverse tangent.<br>
<b>cos(x)</b> - Cosine x.<br>
<b>cosh(x)</b> - Hyperbolic cosine.<br>
<b>exp(x)</b> - Exponent.<br>
<b>lc.map(fn,tbl)</b> - Evaluate function for each table element.<br>
<b>lc.range([from=1,]to[,step=1])</b> - Generate table with sequence of numbers.<br>
<b>lc.round(x[,n=0])</b> - Round value, define number of decimal digits.<br>
<b>lc.sci(x)</b> - 'Scientific' representation of the number.<br>
<b>lc.show(t[,N=10])</b> - Print Lua object. In case of table, ask about continuation after each N elements.<br>
<b>lc.type(t)</b> - Show type of the object.<br>
<b>log(x)</b> - Natural logarithm.<br>
<b>logging(flag)</b> - Save session into the log file. Use 'on'/true to start and 'off'/false to stop.<br>
<b>rand()</b> - Random number between 0 and 1.<br>
<b>randi(N)</b> - Random integer in range from 1 to N.<br>
<b>randn()</b> - Normal distributed random value with 0 mean and variance 1.<br>
<b>sin(x)</b> - Sinus x.<br>
<b>sinh(x)</b> - Hyperbolic sinus.<br>
<b>sqrt(a)</b> - Square root.<br>
<b>tan(x)</b> - Tangent x.<br>
<b>tanh(x)</b> - Hyperbolic tangent.<br></p>
<pre class="example">

lc = require 'sonatalib.main'

-- constants starts from _
ans = _pi                     --> math.pi

-- standard functions 
ans = exp(0)+sin(_pi/2)+cosh(0)  --1> 3.0

-- round number
ans = lc.round(0.9)           --> 1.0

-- save 2 digits
ans = lc.round(math.pi, 2)    --> 3.14

-- random between 0 and 1
p = rand()
ans = (p >= 0) and (p <= 1)   --> true

-- random integer (1 to 10)
p = randi(10)
ans = (p >= 1) and (p <= 10)  --> true

-- normal distributed random
print(randn())

-- get object type
-- "knows" types for Sonata objects
ans = lc.type(25)             --> 'integer'

-- show table components
a = {a=1,b=2;3,4,5}
lc.show(a)

-- show "scientific" view
lc.sci(1234.56789)

-- generate 'sequence'
b = lc.range(3)
ans = b[3]                    --> 3

-- even numbers
b = lc.range(2,10,2)
ans = b[2]                    --> 4

-- calculate function values
c = lc.map(sin, b)
ans = c[1]                   --3> 0.909

-- use Lua functions if need
ans = math.floor(_pi)

ans = math.deg(_pi)

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Arr"></a>
<h3># Arr (array) #</h3>
<p class="descript">Manipulations with arrays of elements. Indices have form of tables. Indexation from 1.</p>
<p><b>Arr(tSize)</b> - Create empty array with the given size.<br>
<b>apply(func, ...)</b> - Apply function of several arguments. Return new array.<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, -a, a^b<br>
<b>capacity(A)</b> - Maximal number of elements in the array. The same as #A.<br>
<b>comparison</b> - a == b, a ~= b<br>
<b>concat(A1,A2,nAxis)</b> - Array concatenation along the given axis.<br>
<b>copy(A)</b> - Get copy of the array.<br>
<b>dim(A)</b> - Return size of the array.<br>
<b>get(A,tInd)</b> - Get array element.<br>
<b>isEqual(A1,A2)</b> - Check size equality.<br>
<b>map(A,func)</b> - Apply function of 1 argument. Return new array.<br>
<b>next(A)</b> - Return iterator along all indexes.<br>
<b>rand(tSize)</b> - Return array with random numbers between 0 and 1.<br>
<b>set(A,tInd,val)</b> - Set value to the array.<br>
<b>sub(A,tInd1,tInd2)</b> - Return sub array restricted by 2 indexes.<br></p>
<pre class="example">

-- use 'array'
Arr = require 'sonatalib.array'

-- empty array
a = Arr {2,3,4}
ans = a:get{1,2,1}            --> nil

-- set values
a:set({1,2,1},4)
ans = a:get{1,2,1}            --> 4

-- random array
b = Arr.rand {5,2,1}
-- max number of elements
ans = #b                      --> 10

ans = b:copy()                --> b

-- compare sizes
ans = b:isEqual(Arr.rand{5,2,1})  --> true

-- arithmetical operations
c = b + b
ans = c:get{1,1,1}            --> 2*b:get{1,1,1}

-- get sub array
g = a:sub({1,1,1},{-1,-1,2})
ans = g:isEqual(Arr{2,3,2})   --> true

-- concatenate along the 3-rd axes
d = Arr.concat(b,b,3)
-- size for given dimension
ans = d:dim()[3]              --> 2

-- apply function of several arguments
a1 = Arr.rand{2,2}
a2 = Arr.rand{2,2}
a3 = Arr.rand{2,2}
fn = function (x,y,z) return x*y+z end
a4 = Arr.apply(fn, a1,a2,a3)
ans = a4:get{1,2}             --> a1:get{1,2}*a2:get{1,2}+a3:get{1,2}


-- apply function of 1 argument
-- to get new array
f = b:map(function (x) return 10*x end)
ans = f:get{1,1,1}            --> b:get{1,1,1}*10

-- simple print
print(a)

-- iterate over array 
-- prepare 
g = Arr {2,2}
g:set({1,1}, 1)
g:set({2,1}, 2)
g:set({1,2}, 3)
g:set({2,2}, 4)
-- show
for ind, val in g:next() do io.write('{',ind[1],',',ind[2],'}\t',val, '\n') end

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Big"></a>
<h3># Big (bigint) #</h3>
<p class="descript">Operations with arbitrary long integers.</p>
<p><b>Big(v)</b> - Create big number from integer or string.<br>
<b>abs(v)</b> - Return module of arbitrary long number.<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, a%b, a^b, -a, #a<br>
<b>comparison</b> - a<b, a<=b, a>b, a>=b, a==b, a~=b<br>
<b>copy(v)</b> - Return copy of given number.<br>
<b>eq(a,b)</b> - Check equality of two values.<br>
<b>fact(B)</b> - Return factorial of non-negative integer n.<br>
<b>size(B)</b> - Number of digits, the same as #B.<br>
<b>str(B[,n=3])</b> - More readable string representation of the number. Optional argument defines number of digits in a group.<br>
<b>val(N)</b> - Represent current big integer as number if it possible.<br></p>
<pre class="example">
-- use 'bigint'
Big = require 'sonatalib.bigint'

-- from integer
a = Big(123)
ans = a:val()                 --> 123

-- from string
b = Big('456')
ans = b:val()                 --> 456

-- arithmetical operations
ans = Big.val(a+b)            --> 579

ans = Big.val(a-b)            --> -333

ans = Big.val(a*Big(2))       --> 246

ans = Big.val(b/2)            --> 228

ans = Big.val(b%a)            --> 87

ans = Big.val(a^3)            --> 1860867

-- absolute value
ans = Big.abs('-25'):val()    --> 25

-- factorial
c = Big(10):fact()
ans = Big.val(c)              --> 3628800

-- make copy, comparison
d = a:copy()
ans = (a == d)                --> true

ans = (a > b)                 --> false

ans = (a == b)                --> false

-- compare with number
ans = a:eq(123)               --> true

-- number of digits
-- (the same as #a) 
ans = a:size()                --> 3

-- simple print
print(a)

-- more friendly representation
print(c:str())
-- set number of digits in group
print(c:str(6))

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Comp"></a>
<h3># Comp (complex) #</h3>
<p class="descript">Manipulations with complex numbers.</p>
<p><b>Comp([re=0],[im=0])</b> - Create new complex number.<br>
<b>_i</b> - Complex unit.<br>
<b>abs(Z)</b> - Return module of complex number.<br>
<b>acos(Z)</b> - Complex inverse cosine.<br>
<b>acosh(Z)</b> - Complex inverse hyperbolic cosine.<br>
<b>angle(Z)</b> - Return argument of complex number.<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, a^b, -a<br>
<b>asin(Z)</b> - Complex inverse sine.<br>
<b>asinh(Z)</b> - Complex inverse hyperbolic sine.<br>
<b>atan(Z)</b> - Complex inverse tangent.<br>
<b>atanh(Z)</b> - Complex inverse hyperbolic tangent.<br>
<b>comparison</b> - a==b, a~=b<br>
<b>conj(Z)</b> - Return the complex conjugate. Equal to ~Z.<br>
<b>copy(Z)</b> - Create copy of the complex number.<br>
<b>cos(Z)</b> - Return cosine of a complex number.<br>
<b>cosh(Z)</b> - Return hyperbolic cosine of a real or complex number.<br>
<b>exp(Z)</b> - Return exponent in for complex argument.<br>
<b>log(Z)</b> - Complex logarithm.<br>
<b>sin(Z)</b> - Return sinus of a complex number.<br>
<b>sinh(Z)</b> - Return hyperbolic sinus of a complex number.<br>
<b>sqrt(Z)</b> - Return square root. Result can be real of complex.<br>
<b>tan(Z)</b> - Return tangent of a complex number.<br>
<b>tanh(Z)</b> - Return hyperbolic tangent of a complex number.<br>
<b>trig(module,angle)</b> - Create complex number using module and angle.<br></p>
<pre class="example">

-- use 'complex'
Comp = require 'sonatalib.complex'

-- real and imaginary pars
a = Comp(1,2)
-- or just imaginary
b = Comp(0,3)

-- imaginary unit
j = Comp._i
ans = 3+4*j                   --> Comp(3,4)

-- use trigonometrical form
ans = Comp.trig(2,0)          --> Comp(2,0)

-- arithmetic
ans = a + b                   --> Comp(1,5)

ans = Comp(0,3) - b           --> Comp(0,0)

ans = a * b                   --> Comp(-6,3)

ans = a / Comp._i             --> Comp(2,-1)

-- power can be complex
c = Comp(1,1)^Comp(2,-2)

-- real part
ans = c.Re                   --3> 6.147

-- imaginary part
ans = c.Im                   --1> 7.4

-- comparison
ans = (a == b)                --> false

ans = (a ~= b)                --> true

-- absolute value
ans = a:abs()                --3> 2.236

-- argument (angle)
ans = a:angle()              --3> 1.107

-- conjugated number
ans = a:conj()                --> Comp(1,-2)

-- some functions after import 
-- become default, such as
d = Comp.sqrt(-2)
ans = d.Im                   --3> 1.414

-- exp
ans = Comp.exp(d).Re         --3> 0.156

-- log
ans = Comp.log(d).Re         --3> 0.3465

-- sin 
ans = Comp.sin(d).Im         --3> 1.935

-- cos 
ans = Comp.cos(d).Im         --1> 0

-- tan
ans = Comp.tan(d).Re         --1> 0

-- sinh
ans = Comp.sinh(d).Re        --1> 0

-- cosh
ans = Comp.cosh(d).Re        --3> 0.156

-- tanh
ans = Comp.tanh(d).Im        --3> 6.334

-- asin
z = Comp(2,3)
ans = z:asin().Im            --3> 1.983

-- acos 
ans = z:acos().Re            --2> 1.000

-- atan
ans = z:atan().Im            --3> 0.229

-- asinh
ans = z:asinh().Re           --3> 1.968

-- acosh
ans = z:acosh().Im           --1> 1.000

-- atanh
ans = z:atanh().Re           --3> 0.146

-- make copy
ans = a:copy()                --> a

-- show
print(a)

--</pre>
<a href="#Top">Top</a></div>
<div><a name="_C"></a>
<h3># _C (const) #</h3>
<p class="descript">Collection of constants.</p>
<p><b>add(name,value)</b> - Create new constant.<br>
<b>astro.ly</b> - One light year.<br>
<b>astro.pc</b> - One parsec.<br>
<b>math.e</b> - Base of the natural logarithm.<br>
<b>math.phi</b> - Golden ratio.<br>
<b>math.pi</b> - Ratio of a circle's circumference to its diameter.<br>
<b>phy.G</b> - Gravitational constant.<br>
<b>phy.NA</b> - Avogadro's number.<br>
<b>phy.R</b> - Universal gas constant.<br>
<b>phy.Rinf</b> - Rydberg constant.<br>
<b>phy.Vm</b> - Volume of one mole of ideal gas.<br>
<b>phy.c</b> - Speed of light.<br>
<b>phy.e</b> - Electron charge.<br>
<b>phy.eps0</b> - Permittivity of free space.<br>
<b>phy.g</b> - Acceleration of free fall.<br>
<b>phy.h</b> - Planck's constant.<br>
<b>phy.k</b> - Boltzmann's constant.<br>
<b>phy.mu0</b> - Permeability of free space.<br>
<b>phy.sigma</b> - Stefan-Boltzmann constant.<br>
<b>remove(name)</b> - Delete constant.<br></p>
<pre class="example">

-- use 'const'
_C = require 'sonatalib.const'

-- charge of electron
ans = _C.phy.e * 1E19        --3> 1.602

-- units have postfix _u
ans = _C.phy.e_u              --> 'C'

-- create "immutable" value
_C.add('myConst', 10)
ans = _C.myConst              --> 10

-- modification generate error
ans = pcall(function() _C.myConst = 0 end)  --> false

-- remove constant
_C.remove('myConst')
ans = _C.myConst              --> nil

--</pre>
<a href="#Top">Top</a></div>
<div><a name="File"></a>
<h3># File (files) #</h3>
<p class="descript">Routines for working with files and text.</p>
<p><b>dsvRead(fName[,delim=','])</b> - Read delimiter separated data as Lua table.<br>
<b>dsvWrite(fname,tbl[,delim=','])</b> - Save Lua table as delimiter separated data into file.<br>
<b>read(fName)</b> - Return file content as a text.<br>
<b>split(str,delim)</b> - Return iterator over substrings separated by the delimiter.<br>
<b>tblImport(fName)</b> - Import Lua table, written into file.<br></p>
<pre class="example">

-- use 'files'
File = require 'sonatalib.files'
-- prepare file name
nm = os.tmpname()

-- save table 
-- separate elements with ';'
t = {{1,2,3},{4,5,6}}
File.dsvWrite(nm, t, ';')

-- read table from file
-- with separator ';'
tt = File.dsvRead(nm, ';')
ans = tt[2][2]                --> 5

-- get file text as string
s = File.read(nm)
ans = string.sub(s,1,5)       --> '1;2;3'

-- read table from file
f = io.open(nm,'w')
f:write("{1,2.0,a='pqr',b={3,4,c='abc'}}")
f:close()
aa = File.tblImport(nm)
ans = aa.b.c                  --> 'abc'

-- string split
str = 'abc//defg//hijkl//mnop'
ans = 0
-- iterate over string parts
for s in File.split(str, '//') do ans = ans+1 end  --> 4

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Gnu"></a>
<h3># Gnu (gnuplot) #</h3>
<p class="descript">Interface for calling Gnuplot from Lua.</p>
<p><b>Gnu([G])</b> - Transform given table into gnuplot object.<br>
<b>N[=100]</b> - If no samples, divide interval into N points.<br>
<b>copy(G)</b> - Get copy of the plot options.<br>
<b>isAvailable(G)</b> - Check if all options in table are predefined in program.<br>
<b>keys</b> -   Options description:<br>
{'sin(x)'}                        -- print sinus using Gnuplot functions<br>
{math.sin, title='sinus'}         -- plot using function, define in Lua; add legend<br>
{file='sin.dat', ln=1, lw=2}      -- plot data from file, use given color and width<br>
{tbl, with='lines'}               -- plot data from Lua table, use lines<br>
title='Graph name'                -- set title<br>
xrange={0,10}                     -- range of x from 0 to 10<br>
yrange={-2,2}                     -- range of y<br>
zrange={0,5}                      -- range of z<br>
trange={1,2}                      -- range for parametric functions<br>
xtitle='A', ytitle='B'            -- axes names<br>
terminal='jpeg'                   -- save result as jpeg image<br>
output='my_plot.jpg'              -- file name<br>
parametric=true                   -- create parametric plot<br>
size='square'                     -- set square size<br>
polar=true                        -- use polar coordinate system<br>
grid='polar'                      -- polar grid<br>
legend=false                      -- don't use legend<br>
surface=true                      -- plot surface in 3D<br>
samples=200                       -- define number of points<br>
permanent=true                    -- create in independent window<br>
raw='set pm3d'                    -- set Gnuplot options manually<br>
<br>
<b>plot(G)</b> - Plot data, represented as Lua table.<br></p>
<pre class="example">

-- use 'gnuplot'
Gnu = require 'sonatalib.gnuplot'

a = {{'sin(x)',title='Sinus x'},permanent=false}
-- use 'permanent=true' instead or not define it at all
-- 'permanent=false' is just for testing
Gnu.plot(a)

-- save as object
-- to simplify modification
g = Gnu(a)
g.xrange = {-10,10}
g:plot()

-- copy parameters to other object
b = g:copy()
print(b)
-- check correctness of the table
ans = b:isAvailable()              --> true

-- print Lua table
tmp = {{1,1},{2,2},{3,3},{4,4}}
Gnu.plot {{tmp,with='lines'},permanent=false}

-- print Lua function
fn1 = function (x) return x^2-x end
Gnu.plot {{fn1,with='lines',title='x^2-x'},permanent=false}

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Graph"></a>
<h3># Graph (graph) #</h3>
<p class="descript">Operations with graphs.</p>
<p><b>Graph(t)</b> - Create new graph.<br>
<b>add(G,e)</b> - Add new node or edge to graph G. Node denoted as a single name, edge is a table of names (and weights if need).<br>
<b>bfs(G,start,goal)</b> - Breadth first search. Return result and found path.<br>
<b>copy(G)</b> - Get copy of the graph.<br>
<b>dfs(G,start,goal)</b> - Depth first search. Return result and found path.<br>
<b>edges(G)</b> - List of graph edges.<br>
<b>isComplete(G)</b> - Check completeness of the graph.<br>
<b>isDirected(G)</b> - Check if the graph has directed edges.<br>
<b>isNegative(G)</b> - Check if the graph has negative edges.<br>
<b>isWeighted(G)</b> - Check if any edge has weight different from 1.<br>
<b>nodes(G)</b> - List of graph nodes.<br>
<b>pathBF(G,start[,goal])</b> - Shortest path search using Bellman-Ford algorithm.<br>
<b>pathD(G,start[,goal])</b> - Find shortest path using Dijkstra's algorithm. Return table of distances and predecessors. If goal is defined, return path and its length.<br>
<b>remove(G,e)</b> - Remove node or edge from the graph G. Node is a single name, edge - table of names.<br></p>
<pre class="example">

-- use 'graph'
Graph = require 'sonatalib.graph'

-- build graph
-- single name - node, names in brackets - edges 
-- letter w denotes weight of non directed edge
-- numbers are weights of directed edges
a = Graph {'a','b',{'a','c'},{'d','e',w=2},{'d','b',4,3}}

-- list of nodes
nd = a:nodes()
ans = #nd                     --> 5

-- list of edges
-- if an edge has different weight for different sizes
-- it is represented twice
ed = a:edges()
ans = #ed                     --> 4

-- has directed edges
ans = a:isDirected()          --> true

-- add node
a:add('h') 
-- add edge
a:add {'a','d'}
-- check size
-- (same as #a)
ans = a:size()                --> 6

-- remove edge
a:remove {'a','d'}
-- remove node
a:remove('a')
-- new edge number
ed = a:edges()
ans = #ed                     --> 3

-- directed edges
-- second way to define
-- from first to second node
a:add {'c','p',w12=2} 
-- and vise versa
a:add {'c','q',w21=3}
ed = a:edges()
ans = #ed                     --> 5

-- make copy
b = a:copy()

-- completeness 
ans = b:isComplete()          --> false

-- prepare graph
c = Graph {{'a','b'},{'a','c'},{'b','d'},{'b','e'},{'c','f'},{'f','g'},{'f','h'},{'e','g'}}

-- is it weighted 
ans = c:isWeighted()          --> false

-- breadth first search
_,path = c:bfs('e','h')
ans = path[3]                 --> 'f'

-- depth first search
found,path = c:dfs('d','c')
ans = found                   --> true

-- update weight
-- (default is 1)
-- use 'add' for it
c:add{'a','b',w=0.5}
c:add{'b','e',w=0.4}
c:add{'c','f',w=2}

-- Dijkstra path search
dist,prev = c:pathD('a') 
ans = dist['g']               --> 1.9

-- Bellman-Ford path search
c:add{'f','h',w=-0.5}
dist,prev = c:pathBF('a')
ans = dist['h'] 

-- check negative edges
ans = c:isNegative()          --> true

-- show
print(b)

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Mat"></a>
<h3># Mat (matrix) #</h3>
<p class="descript">Matrix operations. The matrices are spares by default.</p>
<p><b>Mat(...)</b> - Create matrix from list of strings (tables).<br>
<b>apply(fn,M1,M2,...)</b> - Apply function to the given matrices element-wise.<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, a^b, -a<br>
<b>chol(M)</b> - Cholesky decomposition of positive definite symmetric matrix.<br>
<b>comparison</b> - a==b, a~=b<br>
<b>concat(M1,M2,dir)</b> - Concatenate two matrices, dir='h' - in horizontal direction, dir='v' - in vertical<br>
Use M1 .. M2 for horizontal concatenation and M1 // M2 for vertical.<br>
<b>copy(M)</b> - Return copy of matrix.<br>
<b>cross(V1,V2)</b> - Cross product or two 3-element vectors.<br>
<b>det(M)</b> - Calculate determinant.<br>
<b>diag(M[,n=0])</b> - Get diagonal of the matrix or create new matrix which diagonal elements are given. n is the diagonal index.<br>
<b>dot(V1,V2)</b> - Scalar product of two 3-element vectors.<br>
<b>eye(rows[,cols=rows,init=1])</b> - Create identity matrix. Diagonal value (init) can be defined.<br>
<b>fill(rows,cols,fn)</b> - Create matrix, using function fn(r,c).<br>
<b>inv(M)</b> - Return inverse matrix.<br>
<b>lu(M)</b> - LU decomposition for the matrix. Return L,U and P matrices.<br>
<b>map(M,fn)</b> - Apply the given function to all elements, return new matrix. Function can be in form f(x) or f(x,row,col).<br>
<b>norm(M)</b> - Euclidean norm.<br>
<b>ones(rows[,cols=rows,val=1])</b> - Create matrix of given numbers (default is 1).<br>
<b>pinv(M)</b> - Pseudo inverse matrix calculation.<br>
<b>rand(rows[,cols=rows])</b> - Create matrix with random numbers from 0 to 1.<br>
<b>randi([M],N,[rows],[cols=rows])</b> - Create matrix with random integer elements from 1 to N. Can be used as 'randi(M,N)' or 'randi(N,r,c)'.<br>
<b>randn(rows[,cols=rows])</b> - Create matrix with normally distributed values (0 mean and unit variance)<br>
<b>rank(M)</b> - Find rank of the matrix.<br>
<b>reshape(M,nRows[=size],nCols[=1])</b> - Change matrix size.<br>
<b>rref(M)</b> - Perform transformations using Gauss method.<br>
<b>size(M)</b> - Return number or rows and columns.<br>
<b>table(M)</b> - Convert to simple Lua table.<br>
<b>tr(M)</b> - Get trace of the matrix.<br>
<b>transpose(M)</b> - Return matrix transpose. Shorten form is T().<br>
<b>zeros(rows[,cols=rows])</b> - Create matrix from zeros.<br></p>
<pre class="example">

-- use 'matrix'
Mat = require 'sonatalib.matrix'

-- define matrix objects
a = Mat {{1,2},{3,4}}
b = Mat {{5,6},{7,8}}
-- call in typical way
ans = a[2][2]                 --> 4 

b[1][1] = 5
-- transpose
c = a:T()
-- use () as alias for get()
ans = c(1,-1)                 --> 3

-- matrix rows and columns
_, ans = a:size()             --> 2

-- arithmetical operations
ans = a + b                   --> Mat {{6,8},{10,12}}

ans = b - a                   --> Mat {{4,4},{4,4}}

ans = a * b                   --> Mat {{19,22},{43,50}}

ans = a / b 
-- determinant
ans = ans:det()              --2> 1

-- multiply to scalar
ans = 2 * a                   --> Mat {{2,4},{6,8}}

-- add scalar (to all elements)
ans = a - 1                   --> Mat {{0,1},{2,3}}

ans = a ^ 2                   --> Mat {{7,10},{15,22}} 

-- determinant
ans = a:det()                 --> -2

-- inverse matrix
e = a:inv()
ans = e(2,1)                  --> 1.5

-- another call of inversion
e = a^-1
ans = e(2,1)                  --> 1.5

-- object copy
-- (it doesn't copy zeros)
f = a:copy()
ans = (f == a)                --> true

-- element-wise comparison
ans = (a == b)                --> false

-- identity matrix
ans = Mat.eye(2)              --> Mat {{1,0},{0,1}}

-- matrix argument
ans = Mat.eye(a)              --> Mat {{1,0},{0,1}}

-- matrix of zeros
ans = Mat.zeros(2,1)          --> Mat {{0},{0}}

-- matrix of constants = 4
ans = Mat.ones(2,3,4)         --> Mat {{4,4,4},{4,4,4}}

-- matrix of constants = 1
ans = Mat.ones(a,3)           --> Mat {{3,3},{3,3}}

-- define rule to fill
-- result matrix is 'dense'
fn = function (i,j) return i == j and 1 or 0 end
ans = Mat.fill(2,3,fn)        --> Mat {{1,0,0},{0,1,0}}

-- horizontal concatenation
ans = a .. b                  --> Mat {{1,2,5,6},{3,4,7,8}}

-- vertical concatenation
-- (a // b - for short)
ans = a:concat(b,'v')         --> Mat {{1,2},{3,4},{5,6},{7,8}}

-- apply function of 1 argument
ans = a:map(function (x) return x^2 end)       --> Mat {{1,4},{9,16}}

-- apply function which depends on index too
ans = a:map(function (x,r,c) return x-r-c end) --> Mat {{-1,-1},{-0,-0}}

-- apply function to matrices
-- element-wise
fn = function (x,y,z) return x*y+z end
aa = Mat.apply(fn, b,b,b) 
ans = aa[1][1]                --> 30

-- use Gauss transform to solve equation
ans = Mat.rref(a .. Mat{{5},{11}})             --> Mat {{1,0,1},{0,1,2}}

-- create vector
ans = Mat.V {1,2,3}           --> Mat {{1},{2},{3}}

-- get submatrix
g = Mat {{1,2,3},{4,5,6},{7,8,9}}
ans = g({2,-1},{2,3})         --> Mat {{5,6},{8,9}}

-- euclidean norm
ans = Mat.V({1,2,3}):norm()  --3> math.sqrt(14)

-- random matrix
h = Mat.rand(3,2)
print(h)

-- random integer matrix
-- from 1 to 20
print(h:randi(20))

-- random matrix with 
-- normal distribution
print(Mat.randn(2,2))

-- pseudo inverse matrix
m = Mat {{1,2},{3,4},{5,6}}
n = m:pinv()
ans = n(2,2)                 --3> 0.333

-- copy as Lua table
-- (without methametods)
k = Mat.eye(3)
k = k:table()
ans = k[2][1]                 --> 0

-- make diagonal matrix
ans = Mat.diag({1,2,3})       --> Mat {{1,0,0},{0,2,0},{0,0,3}}

-- shifted diagonal
ans = g:diag(1)               --> Mat {{2},{6}}

-- cross-product of 2 vectors
x1 = Mat {{1,2,3}}
x2 = Mat {{4,5,6}}
ans = Mat.cross(x1,x2)        --> Mat {{-3},{6},{-3}}

-- dot product of 2 vectors
ans = Mat.dot(x1,x2)          --> 32

-- LU transform
l,u,p = b:lu()
ans = l[2][1]                --3> 0.714

-- Cholesky decomposition
m = Mat {{3,1},{1,3}}
m = m:chol()
ans = m[2][2]                --3> 1.633

-- matrix trace
ans = a:tr()                  --> 5

-- extract first row
m = a({},1)
-- vector doesn't need in 2 indices
ans = m(1)                    --> 1

-- extract last column
-- index can be negative 
m = a(-1,{})
ans = m:get(2)                --> 4

-- get rank
ans = Mat.ones(2,3):rank()    --> 1

-- change size
tmp = Mat{{1,2},{3,4},{5,6}} 
ans = tmp:reshape(2,3)        --> Mat {{1,2,3},{4,5,6}}

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Num"></a>
<h3># Num (numeric) #</h3>
<p class="descript">Group of functions for numerical calculations. Tolerance for all functions is defined with parameter TOL.</p>
<p><b>Newton(fn,x0)</b> - Find root of equation using Newton's rule with only one initial condition.<br>
<b>TOL[=0.001]</b> - The solution tolerance.<br>
<b>der(fn,x)</b> - Calculate the derivative value for given function.<br>
<b>ode45(fn,tDelta,y0[,param])</b> - Numerical approximation of the ODE solution.<br>
First parameter is differential equation, second - time interval, third - initial function value. List of parameters is optional and can includes time step or exit condition.<br>
Return table of intermediate points and result yn.<br>
<b>solve(fn,a,b)</b> - Find root of equation fn(x)=0 at interval [a,b].<br>
<b>trapez(fn,a,b)</b> - Get integral using trapezoidal rule.<br></p>
<pre class="example">

-- use 'numeric'
Num = require 'sonatalib.numeric'

-- define tolerance
Num.TOL = 1e-4
-- solve 'sin(x) = 0' for x in (pi/2...3*pi/2)
a = Num.solve(math.sin, math.pi*0.5, math.pi*1.5)
ans = a                      --3> math.pi

-- Newton method
-- only one initial value
d = Num.Newton(math.sin, math.pi*0.7)
ans = d                      --3> math.pi

-- numeric derivative
b = Num.der(math.sin, 0)
ans = b                      --0> 1

-- numeric integral
c = Num.trapez(math.sin, 0, math.pi)
ans = c                      --0> 2

-- solve ODE x*y = x'
-- for x = 0..3, y(0) = 1
-- return table of solutions and y(3)
tbl, yn = Num.ode45(function (x,y) return x*y end, {0,3}, 1)
ans = yn                     --2> 90.011

-- use matrices for high order equations
Mat = require 'sonatalib.matrix'

-- y''-2*y'+2*y = 1
-- represent as: x1 = y, x2 = y'
-- so: x1' = x2, x2' = 1+2*x2-2*x1
myfun = function (t,x) return Mat.V {x(2), 1+2*x(2)-2*x(1)} end
_, xn = Num.ode45(myfun, {0,2}, Mat.V{3,2}, {dt=0.2}) 
ans = xn(1)                  --2>  -10.54

-- define exit condition
-- from time, current and previous results
cond = function (time,current,previous) return current < 0.1 end
myfun = function (t,x) return -x end
y = Num.ode45(myfun, {0,1E2}, 1, {exit=cond})
ans = y[#y][1]               --2> 2.56

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Poly"></a>
<h3># Poly (polynom) #</h3>
<p class="descript">Operations with polynomials.</p>
<p><b>Poly(...)</b> - Create a polynomial.<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, a^n, -a<br>
<b>build(root1,root2,...)</b> - Return polynomial with given roots.<br>
<b>comparison</b> - a==b, a~=b<br>
<b>copy(P)</b> - Get copy of the polynomial.<br>
<b>der(P)</b> - Calculate derivative of polynomial.<br>
<b>fit(X,Y,ord)</b> - Find polynomial approximation for the line.<br>
<b>int(P[,x0=0])</b> - Calculate integral, x0 - free coefficient.<br>
<b>real(p)</b> - Find real roots of the polynomial.<br>
<b>val(P,x)</b> - Get value of polynomial P in point x.<br></p>
<pre class="example">

-- use 'polynom'
Poly = require 'sonatalib.polynom'

-- coefficients in ascendant order
a = Poly {1,2,4,3}
b = Poly {1,1}  
-- polynomial value for x=0
ans = a:val(0)                --> 3

-- simplified call
ans = a(0)                    --> 3

-- arithmetic
ans = a + b                   --> Poly {1,2,5,4}

ans = a - b                   --> Poly {1,2,3,2}

ans = b * b                   --> Poly {1,2,1}

ans = a / b                   --> Poly {1,1,3}

ans = a % b                   --> Poly {0}

ans = b ^ 3                   --> Poly {1,3,3,1}

-- integration
-- free coefficient is 0
ans = b:int()                 --> Poly {0.5,1,0}

-- derivative
ader = a:der()
-- and its value for x=1
ans = ader(1)                 --> 11

-- build polynomial using roots
ans = Poly.build(1,-1)        --> Poly {1,0,-1}

-- make copy and compare
c = a:copy()
ans = (a == c)                --> true

-- not equal
ans = (b == c)                --> false

-- find real roots
e = a:real()
ans = e[1]                   --1> -1.00

-- fit curve with polynomial
-- of order 2
A={0,1,2,3}
B={-3,2,11,24}
p = Poly.fit(A,B,2)
ans = p(10)                  --0> 227.0

-- simple print
print(a)

-- human-friendly print
-- with variable 's' (default is 'x')
d = Poly {2,-2,1}
ans = d:str('s')              --> '2*s^2 -2*s +1'

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Quat"></a>
<h3># Quat (quaternion) #</h3>
<p class="descript">Operations with quaternions.</p>
<p><b>Quat(t={0,0,0,0})</b> - Create new quaternion.<br>
<b>abs(Q)</b> - Value of the norm.<br>
<b>arithmetic</b> - a + b, a - b, a * b, a ^ k, -a<br>
<b>comparison</b> - a == b, a ~= b<br>
<b>conj(Q)</b> - Get conjugation.<br>
<b>copy(t)</b> - Create a copy of the quaternion.<br>
<b>fromAA(fAng,vAxe)</b> - Create quaternion using angle and axis.<br>
<b>fromRot(M)</b> - Convert rotation matrix to quaternion.<br>
<b>imag(Q)</b> - Get table of the imaginary part.<br>
<b>inv(Q)</b> - Find inverted quaternion.<br>
<b>mat(Q)</b> - Equivalent matrix representation.<br>
<b>normalize(Q)</b> - Make unit quaternion.<br>
<b>real(Q)</b> - Real part (same as Q.w).<br>
<b>rotate(Q,vec)</b> - Apply quaternion to rotate the vector.<br>
<b>slerp(Q1,Q2,t)</b> - Spherical linear interpolation for part t.<br>
<b>toAA(Q)</b> - Get angle and axis of rotation.<br>
<b>toRot(Q)</b> - Get equal rotation matrix.<br></p>
<pre class="example">

-- use 'quaternion'
Quat = require 'sonatalib.quaternion'

-- new quaternion
-- set {w,i,j,k}
a = Quat {1,2,3,4}
-- part of elements
b = Quat {w=3, i=4}
ans = b                       --> Quat{3,4,0,0}

-- conjugation
ans = a:conj()                --> Quat{1,-2,-3,-4}

-- norm
ans = b:abs()                --1> 5.000

-- inversion
c = a*a:inv()
ans = c.w                    --1> 1.000

-- arithmetic
ans = a+b                     --> Quat{4,6,3,4}

ans = a*b                     --> Quat{-5,10,25}

ans = 3*b                     --> Quat{9,12,0,0}

-- power
ans = b^3                     --> b * b * b

-- unit quaternion
a:normalize()
ans = a:abs()                --1> 1.000

-- unit power
aa = a^1.5
ans = aa.i                   --3> 0.324

ans = aa.j                   --3> 0.486

ans = aa.k                   --3> 0.648

-- rotation matrix
m = a:toRot()
d = Quat.fromRot(m)
ans = Quat.abs(d-a)          --1> 0.000

-- use angle 
-- and axis
ang = 0.5
axis = {1,1,1}
f = Quat.fromAA(ang,axis)
ans,_ = f:toAA()             --3> ang

-- rotate vector
p = a:rotate({1,0,0})
ans = p[1]                   --3> -0.667

-- spherical interpolation
d = Quat.slerp(a,b,0.5)
ans = d.w                    --3> 0.467

-- make copy
ans = d:copy()                --> d

-- show 
print(d)

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Rat"></a>
<h3># Rat (rational) #</h3>
<p class="descript">Computations with rational numbers.</p>
<p><b>De(R)</b> - Return the denominator of the rational number.<br>
<b>Nu(R)</b> - Return the numerator of rational number.<br>
<b>Rat(m[,n=1])</b> - Create rational number using num (and denom).<br>
<b>arithmetic</b> - R1+R2, R1-R2, R1*R2, R1/R2, -R, R1^R2} <br>
<b>comparison</b> - R1<R2, R1<=R2, R1>R2, R1>=R2, R1==R2, R1~=R2<br>
<b>copy(R)</b> - Get copy of the rational number.<br>
<b>gcd(a,b)</b> - Calculate the greatest common divisor for two integers.<br>
<b>val(R)</b> - Return rational number as decimal.<br></p>
<pre class="example">

-- use 'rational'
Rat = require 'sonatalib.rational'

-- numerator, denominator
a = Rat(1,2)
-- only numerator
b = Rat(2)
ans = b                       --> Rat(2,1)

-- simplification
k = 234781
ans = Rat(2*k,3*k)            --> Rat(2,3)

-- arithmetic
ans = a + b                   --> Rat(5,2)

ans = 2 * a                   --> Rat(1)

ans = Rat(2,3)*Rat(3,2)       --> Rat(1)

ans = a / Rat(1,3)            --> Rat(3,2)

ans = a ^ 3                   --> Rat(1,8)

ans = 2 ^ a                  --3> 1.414

-- comparison
ans = (b == b)                --> true

ans = (a >= b)                --> false

-- greatest common division
ans = Rat.gcd(125,65)         --> 5

-- represent as decimal
ans = a:val()                 --> 0.5

-- numerator
ans = b:Nu()                  --> 2

-- denominator
ans = b:De()                  --> 1

-- make copy
ans = a:copy()                --> a

-- show
print(a)

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Spec"></a>
<h3># Spec (special) #</h3>
<p class="descript">Special mathematical functions.</p>
<p><b>besseli(n,x)</b> - Modified Bessel function In(x).<br>
<b>besselj(n,x)</b> - Bessel function of the first kind.<br>
<b>besselk(n,x)</b> - Modified Bessel function Kn(x).<br>
<b>bessely(n,x)</b> - Bessel function of the second kind.<br>
<b>beta(z,w)</b> - Beta function.<br>
<b>betainc(x,a,b)</b> - Incomplete beta function Ix(a,b).<br>
<b>betaln(z,w)</b> - Natural logarithm of beta function.<br>
<b>dawson(x)</b> - Dawson integral.<br>
<b>erf(x)</b> - Error function.<br>
<b>erfc(x)</b> - Complementary error function.<br>
<b>expint(n,x)</b> - Exponential integral En(x).<br>
<b>gamma(z)</b> - Gamma function.<br>
<b>gammainc(x,a[,type='lower')</b> - Incomplete gamma function, P (type='lower') or Q (type='upper').<br>
<b>gammaln(z)</b> - Natural logarithm of gamma function.<br>
<b>gammp(a,x)</b> - Incomplete gamma function P(a,x).<br>
<b>gammq(a,x)</b> - Incomplete gamma function Q(a,x) = 1-P(a,x).<br>
<b>legendre(n,x)</b> - Return list of Legendre polynomial coefficients.<br></p>
<pre class="example">

-- use 'special'
Spec = require 'sonatalib.special'

-- beta functions
ans = Spec.beta(3,4) * 1E2   --3> 1.667

ans = Spec.betaln(10,20)     --3> -19.115

ans = Spec.betainc(0.5, 2, 3.3)  --3> 0.7309

-- error functions
ans = Spec.erf(1)            --3> 0.8427

ans = Spec.erfc(0.5)         --3> 0.4795

-- Ei(x)
ans = Spec.expint(3.3) * 1E3     --3> 8.939

-- E3(x)
ans = Spec.expint(2, 5) * 1E4    --3> 9.965

-- gamma functions
ans = Spec.gamma(-1.5)       --3> 2.3633

ans = Spec.gammaln(100)      --3> 359.1342

ans = Spec.gammp(7.7, 2.3) * 1E3 --2> 3.85

ans = Spec.gammq(1.5, 4.8) * 1E2 --2> 2.23

-- another syntax
ans = Spec.gammainc(2.1, 0.3, 'upper') * 1E2 --3> 1.942

-- Bessel functions
ans = Spec.besselj(3, 1.5) * 1E2 --3> 6.096

ans = Spec.bessely(4, 0.8)   --3> -78.751

ans = Spec.besseli(2, -3.6)  --3> 4.254

ans = Spec.besselk(5, 5) * 1E2   --3> 3.2706

-- Legendre function
lst = Spec.legendre(3, 0.5)
ans = lst[1]                 --3> -0.4375

-- Dawson function
ans = Spec.dawson(3.3)       --3> 0.1598

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Stat"></a>
<h3># Stat (stat) #</h3>
<p class="descript">Statistical calculations. Data set must be a Lua table.</p>
<p><b>freq(t)</b> - Return table with frequencies of elements.<br>
<b>geomean(t[,w])</b> - Geometrical mean.<br>
<b>harmmean(t[,w])</b> - Harmonic mean.<br>
<b>histcounts(X[,rng=10])</b> - Calculate amount of bins. Edges can be either number or table.<br>
<b>max(t)</b> - Maximal element and its index.<br>
<b>mean(t[,w])</b> - Calculate average value. Weights can be used.<br>
<b>median(t)</b> - Median of the list.<br>
<b>min(t)</b> - Minimal element and its index.<br>
<b>moment(n,x[,p])</b> - Central moment of x order n, p is a list of weights.<br>
<b>std(t[,w])</b> - Standard deviation and variance. Weights can be used.<br>
<b>sum(t)</b> - Get sum of all elements.<br>
<b>tcdf(x,nu)</b> - Student's cumulative distribution.<br>
<b>tpdf(x,nu)</b> - Student's distribution density.<br></p>
<pre class="example">

-- use 'stat'
Stat = require 'sonatalib.stat'

-- initial data (tables)
X = {3,2,5,6,3,4,3,1}
w = {1,1,0,1,2,2,1,1}
-- average
ans = Stat.mean(X)           --3> 3.375

-- standard deviation
ans, tmp = Stat.std(X,W)     --3> 1.495

-- variance
ans = tmp                    --3> 2.234

-- maximum element and index
_,ans = Stat.max(X)           --> 4 

-- median
ans = Stat.median(X)          --> 3

-- table of frequencies
tmp = Stat.freq(X)
ans = tmp[3]                  --> 3

-- central moment
ans = Stat.moment(2,X)       --3> 2.234

-- summ of elements
ans = Stat.sum(X)             --> 27

-- minimum value
ans = Stat.min(X)             --> 1

-- geometrical mean
ans = Stat.geomean(X)        --3> 2.995

-- harmonic mean
ans = Stat.harmmean(X,W)     --3> 2.567

-- find histogram
a,b = Stat.histcounts(X, 3)
ans = b[1]                    --> 1

-- define edges 
a,b = Stat.histcounts(X,{0,4,7})  
ans = a[1]                    --> 5 

-- Student cdf and pdf
ans = Stat.tcdf(4, 2.5)      --3> 0.9805

ans = Stat.tpdf(2, 3.3)      --3> 0.0672

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Unit"></a>
<h3># Unit (units) #</h3>
<p class="descript">Operations and conversations according the units.</p>
<p><b>Unit(v[,u])</b> - Create new elements with units.<br>
<b>add(U,rule)</b> - Add new rule for conversation.<br>
<b>arithmetic</b> - U1+U2, U1-U2, U1*u2, U1/U2, U1^n<br>
<b>comparison</b> - U1==U2, U1~=U2, U1<U2, U1<=U2, U1>U2, U1>=U2<br>
<b>convert(v, units)</b> - Convert one units to another, return new object or nil.<br>
<b>copy(U)</b> - Create copy of the element.<br>
<b>prefix</b> - Table of possible prefixes for units.<br></p>
<pre class="example">

-- use 'units'
Unit = require 'sonatalib.units'

-- add some rules
Unit.add('h', Unit(60,'min'))
Unit.add('min', Unit(60,'s'))

-- define variable
a = Unit(1,'m/s')
-- convert to km/h, get only value
ans = a['km/h']               --> 3.6

-- get numerical value
-- (the save as #a)
ans = a:val()                 --> 1

-- make copy
cp = a:copy() 
ans = cp                      --> Unit(1,'m/s')

-- get converted variable
b = a:convert('km/h')
ans = b                       --> Unit(3.6, 'km/h')

-- arithmetic
b = 3 * b
ans = a + b                   --> Unit(4, 'm/s')

ans = b - a                   --> Unit(2, 'm/s')

ans = a * b                   --> Unit(3, 'm^2/s^2')

ans = b / a                   --> Unit(3)

ans = (a < b)                 --> true

ans = b ^ 3                   --> Unit(27, 'm^3/s^3')

-- new rule
Unit.add('snake', Unit(48, 'parrot'))
-- define variable
c = Unit(2,'snake')
-- convert
ans = c['parrot']             --> 96

-- convert using prefix
ans = c['ksnake']             --> 0.002

-- complex rule
d = Unit(1,'W')
-- define function for conversation, apply it
lg = function (x) return math.log(x)/math.log(10) end
e = d:convert(function (x) return Unit( 10*lg((x/Unit('mW')):simp()), 'dBm') end)
ans = #e                     --0> 30

-- another definition syntax
ans = 2 * Unit('N')           --> Unit(2,'N')

-- show result
print(a)
--</pre>
<a href="#Top">Top</a></div>
<div><p align="center"><i>2021, Stanislav Mikhel</i></p></div>
</body></html>