<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Sonata Help</title>
</head><body>
<style type="text/css">
H3 {text-align:center;}
P {line-height:1.3;}
UL {column-count: 4; border: 2px solid blue; border-radius: 5px; padding: 5px 5px 5px 30px;}
DIV {margin-left: 10px;}
.EXAMPLE {border: 2px solid blue; border-radius: 5px; background: lightgrey; padding: 15px; margin: 10px 0px; color:navy; }
.DESCRIPT {text-align:center; font-style:italic; }
</style>
<a name="Top"></a>
<div><h1 align="center">Sonata Lua Calculus</h1>
<ul>
<li><a href="#Arr">array</a></li>
<li><a href="#Ap">asciiplot</a></li>
<li><a href="#Int">bigint</a></li>
<li><a href="#Comp">complex</a></li>
<li><a href="#_C">const</a></li>
<li><a href="#Geo">geodesy</a></li>
<li><a href="#Gp">gnuplot</a></li>
<li><a href="#Graph">graph</a></li>
<li><a href="#Lens">lens</a></li>
<li><a href="#Mat">matrix</a></li>
<li><a href="#Num">numeric</a></li>
<li><a href="#Poly">polynomial</a></li>
<li><a href="#Quat">quaternion</a></li>
<li><a href="#Rat">rational</a></li>
<li><a href="#Spec">special</a></li>
<li><a href="#Stat">stat</a></li>
<li><a href="#Unit">units</a></li>
</ul></div>
<div><h3># About #</h3>
<p><br>
'Sonata' is a Lua based program for mathematical calculations.<br>
<br>
<b>USAGE</b>:<br>
	lua [-i] sonata.lua [flag] [arg1 arg2 ...]<br>
(option '-i' can be used for working in native Lua interpreter)<br>
<br>
<b>FLAGS</b>:<br>
	-h - Get this help message.<br>
	-e - Evaluate command line expression.<br>
	  (e.g. -e "2+2")<br>
		{Development}<br>
	--new    - Create a template for a new module.<br>
	  (e.g. --new  signal  Sig  "Signal processing functions.")<br>
	--lang   - Creating/updating a file for localization.<br>
	  (e.g. --lang eo)<br>
	--test   - Apply the unit tests to the desired module. Call all modules if the name is not defined.<br>
	  (e.g. --test array)<br>
	--doc    - Creating/updating a documentation file.<br>
	  (e.g. --doc ru)<br>
	 No flag  - Evaluate file(s).<br>
<br>
<b>VERSION</b>: 0.9.27<br>
<br>
<b>MODULES</b>: const, lens, array, gnuplot, stat, bigint, complex, graph, asciiplot, polynomial, numeric, special, geodesy, quaternion, rational, units, matrix.<br>
<br>
<b>BUGS</b>: mail to 'sonatalc@yandex.ru'<br>
</p>
<p><a href="https://github.com/mikhel1984/sonata/wiki">Project Wiki</a></p></div>
<div><a name="Main"></a>
<h3># Main (main) #</h3>
<p class="descript">Lua based mathematics.</p>
<p><b>DsvRead(sFile[,delim=',',bCol=false])</b> - Read delimiter separated data as Lua table.<br>
<b>DsvWrite(sFile,t[,char=',',bCol=false])</b> - Save Lua table as delimiter separated data into file.<br>
<b>Logging(flag)</b> - Save session into the log file. Use 'on'/true to start and 'off'/false to stop.<br>
<b>Map(fn,t)</b> - Evaluate function for each table element.<br>
<b>Print(...)</b> - Extenden print function, it shows elements of tables and scientific form of numbers.<br>
<b>Range(dBegin,dEnd[,dStep])</b> - Generate table with sequence of numbers.<br>
<b>Round(f[,N=0])</b> - Round value, define number of decimal digits.<br>
<b>Run(sFile)</b> - Execute lua- or note-file.<br>
<b>TblImport(sFile)</b> - Import Lua table, saved into file.<br>
<b>Type(v)</b> - Show type of the object.<br>
<b>_ans</b> - Result of the last operation.<br>
<b>_e</b> - Euler number.<br>
<b>_pi</b> - Number pi.<br>
<b>abs(x)</b> - Absolute value.<br>
<b>acos(x)</b> - Inverse cosine x.<br>
<b>acosh(x)</b> - Hyperbolic arc cosine.<br>
<b>asin(x)</b> - Inverse sine x.<br>
<b>asinh(x)</b> - Hyperbolic inverse sine.<br>
<b>atan2(y,x)</b> - Inverse tangent of y/x, use signs.<br>
<b>atanh(x)</b> - Hyperbolic inverse tangent.<br>
<b>cos(x)</b> - Cosine x.<br>
<b>cosh(x)</b> - Hyperbolic cosine.<br>
<b>exp(x)</b> - Exponent.<br>
<b>log(x)</b> - Natural logarithm.<br>
<b>rand()</b> - Random number between 0 and 1.<br>
<b>randi(N)</b> - Random integer in range from 1 to N.<br>
<b>randn([dMean=0,dev=1])</b> - Normal distributed random value with the given mean and deviation.<br>
<b>sin(x)</b> - Sinus x.<br>
<b>sinh(x)</b> - Hyperbolic sinus.<br>
<b>sqrt(a)</b> - Square root.<br>
<b>tan(x)</b> - Tangent x.<br>
<b>tanh(x)</b> - Hyperbolic tangent.<br></p>
<pre class="example">

require 'lib.main'

-- constants starts from _
ans = _pi                     --> math.pi

-- standard functions 
ans = exp(0)+sin(_pi/2)+cosh(0)  --1> 3.0

-- round number
ans = Round(0.9)              --> 1.0

-- save 2 digits
ans = Round(math.pi, 2)       --> 3.14

-- random between 0 and 1
p = rand()
ans = (p >= 0) and (p <= 1)   --> true

-- random integer (1 to 10)
p = randi(10)
ans = (p >= 1) and (p <= 10)  --> true

-- normal distributed random
print(randn())

-- get object type
-- "knows" types for Sonata objects
ans = Type(25)                --> 'integer'

-- modified print function 
a = {a=1,b=2, 3,4,5}
Print(a, 0.123)

-- generate 'sequence'
b = Range(1,3)
ans = b[3]                    --> 3

-- even numbers
b = Range(2,10,2)
ans = b[2]                    --> 4

-- linear transformations
-- with range Range objects
b2 = 2*b + 4
ans = b2[1]                   --> 8

-- calculate function values
c = Map(sin, b)
ans = c[1]                   --3> 0.909

-- use Lua functions if need
ans = math.floor(_pi)

ans = math.deg(_pi)

-- prepare file name
nm = os.tmpname()

-- dsv write 
-- separate elements with ';'
t = {{1,2,3},{4,5,6}}
DsvWrite(nm, t, ';')

-- dsv read
-- with separator ';'
tt = DsvRead(nm, ';')
ans = tt[2][2]                --> 5

-- csv write by columns
DsvWrite(nm, t, ',', true)

-- csv read by columns
tt = DsvRead(nm, ',', true)
ans = tt[1][3]                --> 3

-- read table from file
f = io.open(nm,'w')
f:write("{1,2.0,a='pqr',b={3,4,c='abc'}}")
f:close()
aa = TblImport(nm)
ans = aa.b.c                  --> 'abc'

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Arr"></a>
<h3># Arr (array) #</h3>
<p class="descript">Manipulations with arrays of elements. Indices have form of tables. Indexation from 1.</p>
<p><b>Arr {n1,n2,..}</b> - Create empty array with the given size.<br>
<b>apply(fn, ...)</b> - Apply function of several arguments. Return new array.<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, -a, a^b<br>
<b>capacity(A)</b> - Maximal number of elements in the array. The same as #A.<br>
<b>comparison</b> - a == b, a ~= b<br>
<b>concat(A1,A2,iAxis)</b> - Array concatenation along the given axis.<br>
<b>copy(A)</b> - Get copy of the array.<br>
<b>dim(A)</b> - Return size of the array.<br>
<b>get(A,tInd)</b> - Get array element.<br>
<b>isEqual(A1,A2)</b> - Check size equality.<br>
<b>map(A,fn)</b> - Apply function of 1 argument. Return new array.<br>
<b>next(A)</b> - Return iterator along all indexes.<br>
<b>rand(tSize)</b> - Return array with random numbers between 0 and 1.<br>
<b>set(A,tInd,v)</b> - Set value to the array.<br>
<b>sub(A,tInd1,tInd2)</b> - Return sub array restricted by 2 indexes.<br></p>
<pre class="example">

-- use 'array'
Arr = require 'lib.array'

-- empty array
a = Arr {2,3,4}
ans = a:get{1,2,1}            --> nil

-- set values
a:set({1,2,1},4)
ans = a:get{1,2,1}            --> 4

-- random array
b = Arr.rand {5,2,1}
-- max number of elements
ans = #b                      --> 10

ans = b:copy()                --> b

-- compare sizes
ans = b:isEqual(Arr.rand{5,2,1})  --> true

-- arithmetical operations
c = b + b
ans = c:get{1,1,1}            --> 2*b:get{1,1,1}

-- get sub array
g = a:sub({1,1,1},{-1,-1,2})
ans = g:isEqual(Arr{2,3,2})   --> true

-- concatenate along the 3-rd axes
d = Arr.concat(b,b,3)
-- size for given dimension
ans = d:dim()[3]              --> 2

-- apply function of several arguments
a1 = Arr.rand{2,2}
a2 = Arr.rand{2,2}
a3 = Arr.rand{2,2}
fn = function (x,y,z) return x*y+z end
a4 = Arr.apply(fn, a1,a2,a3)
ans = a4:get{1,2}             --> a1:get{1,2}*a2:get{1,2}+a3:get{1,2}


-- apply function of 1 argument
-- to get new array
f = b:map(function (x) return 10*x end)
ans = f:get{1,1,1}            --> b:get{1,1,1}*10

-- simple print
print(a)

-- iterate over array 
-- prepare 
g = Arr {2,2}
g:set({1,1}, 1)
g:set({2,1}, 2)
g:set({1,2}, 3)
g:set({2,2}, 4)
-- show
for ind, val in g:next() do io.write('{',ind[1],',',ind[2],'}\t',val, '\n') end

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Ap"></a>
<h3># Ap (asciiplot) #</h3>
<p class="descript">Use pseudography for data visualization.</p>
<p><b>Ap([iWidth=75,iHeight=23])</b> - Create new asciiplot.<br>
<b>addPoint(F,dx,dy,s)</b> - Add point (dx,dy) using char 's'.<br>
<b>addPose(F,ir,ic,s)</b> - Add character s to the given position.<br>
<b>addString(F,ir,ic,s)</b> - Set string from the given position.<br>
<b>concat(...)</b> - Horizontal concatenation of figures with the same height. For two object operator '..' can be used.<br>
<b>copy(F)</b> - Create a copy of the object.<br>
<b>plot(F,...)</b> - Plot arguments in form 't', 't1,t1', 'fn,nm', 'fn1,fn2' etc.<br>
<b>reset(F)</b> - Prepare a clear canvas.<br>
<b>scale(F,factor)</b> - Change figure size w.r.t. default values.<br>
<b>tplot(F,t[,tOpt={}])</b> - Plot the table data, choose columns if need.<br></p>
<pre class="example">

-- use 'asciiplot'
Ap = require 'lib.asciiplot'

-- figure with default size
fig1 = Ap()
print(fig1.width, fig1.height)

-- print functions 
fig1.xrange = {-3.14, 3.14}   -- default is (-1,1)
fig1:plot(math.sin, 'sin', math.cos, 'cos')
fig1.title = 'Trigonometry'
print(fig1) 

-- print data 
x = {1,2,3,4,5}
y = {1,3,5,7,9}
print(fig1:plot(x,y)) 

-- combine different sources 
fig1.yaxis = 'L'  -- left axis
fig1:plot(x,'single',x,y,'pair',math.log, 'function')
print(fig1) 

-- define arbitrary figure size
-- odd is preferable 
fig2 = Ap(21,11)    -- width=21, height = 11
print(fig2:plot(function (x) return 2*x end)) 

-- show table 
tbl = {}
for x = 0, 3, 0.1 do
  --             x      y1          y2
  tbl[#tbl+1] = {x, math.sin(x), math.cos(x)}
end
fig2.xaxis = 'D'  -- down
print(fig2:tplot(tbl))

-- plot only y2, don't rescale
fig2.xrange = {-1, 4}
fig2.yrange = {0, 1}
print(fig2:tplot(tbl, {2, resize=false}))

-- scale figure 
fig1:scale(0.5)
ans = fig1.width             --> 37

-- horizontal concatenation 
-- first
fig1.xrange = {0, 1.57}
fig1.yaxis = 'C'; fig1.xaxis = 'D'
fig1:plot(sin, 'sin')
fig1.title = 'First'
-- second
fig2:scale(0.5)
fig2.xrange = {0, 1.57}
fig2:plot(cos, 'cos')
fig2.title = 'Second'
print(Ap.concat(fig1, fig2))   -- similar to fig1..fig2 for 2 objects

-- 'manual' createion 
fig3 = Ap() 
fig3:scale(0.5)
fig3.xrange = {-2,2} 
fig3.yrange = {-1,4}
-- no axes and limits
fig3.xaxis = nil; fig3.yaxis = nil
fig3:reset()
-- add line
for x = -1.2, 1.2, 0.1 do
  fig3:addPoint(x, x*x-0.5, Ap.char[1])
end
-- add char by index
fig3:addPose(3, 13, '#')
fig3:addPose(3, 24, '#')
-- add text 
fig3:addString(2,3,'Hi!')
print(fig3)

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Int"></a>
<h3># Int (bigint) #</h3>
<p class="descript">Operations with arbitrary long integers.</p>
<p><b>Int(v)</b> - Create number from integer, string or table.<br>
<b>abs(B)</b> - Return module of arbitrary long number.<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, a%b, a^b, -a, #a<br>
<b>base(B)</b> - Current numeric base.<br>
<b>comparison</b> - a<b, a<=b, a>b, a>=b, a==b, a~=b<br>
<b>copy(B)</b> - Return copy of given number.<br>
<b>eq(B1,B2)</b> - Check equality of two values.<br>
<b>fact(B)</b> - Return factorial of non-negative integer B.<br>
<b>factorize(B)</b> - Find the list of multipliers.<br>
<b>float(B)</b> - Represent current big integer as number if it possible.<br>
<b>gcd(B1,B2)</b> - Find the greatest common divisor for two integers.<br>
<b>isPrime(B[,sMethod])</b> - Check if the number is prime. Set 'Fermat' method to use the small Fermat theorem.<br>
<b>random(B)</b> - Generate pseudo-random value from 0 to B.<br>
<b>rebase(B,N)</b> - Convert number to the new numeric base.<br></p>
<pre class="example">
-- use 'bigint'
Int = require 'lib.bigint'

-- from integer
a = Int(123)
ans = a:float()               --> 123

-- from string
b = Int('456')
ans = b:float()               --> 456

-- from table 
-- 'sign' and 'base' can be skipped
g = Int {1,2,3,sign=-1,base=10}
ans = g:float()               --> -123

-- check equality
ans = (a == -g)               --> true

-- arithmetical operations
ans = Int.float(a+b)          --> 579

ans = Int.float(a-b)          --> -333

ans = Int.float(a*Int(2))     --> 246

ans = Int.float(b/2)          --> 228

ans = Int.float(b%a)          --> 87

ans = Int.float(a^3)          --> 1860867

-- absolute value
ans = Int.abs('-25'):float()  --> 25

-- factorial
c = Int(10):fact()
ans = Int.float(c)            --> 3628800

-- make copy, comparison
d = a:copy()
ans = (a == d)                --> true

ans = (a > b)                 --> false

ans = (a == b)                --> false

-- compare with number
ans = a:eq(123)               --> true

-- number of digits
ans = #a                      --> 3

-- 2nd digit (from the lowest)
ans = a[2]                    --> 2

-- get numeric base 
ans = g:base()                --> 10

-- change numeric base
v = g:rebase(60)
ans = tostring(v)             --> '-2|3'

-- still the same value
ans = (v == g)                --> true

-- operations with different bases
-- transform to the biggest common base
w = v + b
ans = tostring(w)             --> '5|33'

-- simple print
print(a)

-- check if it prime
-- iterate though multipliers 
ans = Int.isPrime(1229)       --> true

-- Fermat theorem 
ans = Int.isPrime(1229,'Fermat') --> true

-- factorize 
t = b:factorize()
ans = #t                      --> 5

-- check factorization
ans = 1
for i = 1,#t do
  ans = ans * (t[i]:float())
end                           --> 456

-- pseudo-random number
-- from 0 to b
print(b:random())

-- greatest common divisor
ans = a:gcd(b):float()        --> 3

-- result is bigint
ans = a + 1.0                 --> Int(124) 

-- result is float
ans = a - 0.5                 --> 122.5

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Comp"></a>
<h3># Comp (complex) #</h3>
<p class="descript">Manipulations with complex numbers.</p>
<p><b>Comp([vRe=0,vIm=0])</b> - Create new complex number.<br>
<b>_i</b> - Complex unit.<br>
<b>abs(C)</b> - Return module of complex number.<br>
<b>acos(C)</b> - Complex inverse cosine.<br>
<b>acosh(C)</b> - Complex inverse hyperbolic cosine.<br>
<b>angle(C)</b> - Return argument of complex number.<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, a^b, -a<br>
<b>asin(C)</b> - Complex inverse sine.<br>
<b>asinh(C)</b> - Complex inverse hyperbolic sine.<br>
<b>atan(C)</b> - Complex inverse tangent.<br>
<b>atanh(C)</b> - Complex inverse hyperbolic tangent.<br>
<b>comparison</b> - a==b, a~=b<br>
<b>conj(C)</b> - Return the complex conjugate. Equal to ~C.<br>
<b>copy(C)</b> - Create copy of the complex number.<br>
<b>cos(C)</b> - Return cosine of a complex number.<br>
<b>cosh(C)</b> - Return hyperbolic cosine of a real or complex number.<br>
<b>exp(C)</b> - Return exponent in for complex argument.<br>
<b>log(C)</b> - Complex logarithm.<br>
<b>sin(C)</b> - Return sinus of a complex number.<br>
<b>sinh(C)</b> - Return hyperbolic sinus of a complex number.<br>
<b>sqrt(C)</b> - Return square root. Result can be real of complex.<br>
<b>tan(C)</b> - Return tangent of a complex number.<br>
<b>tanh(C)</b> - Return hyperbolic tangent of a complex number.<br>
<b>trig(vModule,vAngle)</b> - Create complex number using module and angle.<br></p>
<pre class="example">

-- use 'complex'
Comp = require 'lib.complex'

-- real and imaginary pars
a = Comp(1,2)
-- or just imaginary
b = Comp(0,3)

-- imaginary unit
j = Comp._i
ans = 3+4*j                   --> Comp(3,4)

-- use trigonometrical form
ans = Comp.trig(2,0)          --> Comp(2,0)

-- arithmetic
ans = a + b                   --> Comp(1,5)

ans = Comp(0,3) - b           --> 0

ans = a * b                   --> Comp(-6,3)

ans = a / Comp._i             --> Comp(2,-1)

-- power can be complex
c = Comp(1,1)^Comp(2,-2)

-- real part
ans = c.Re                   --3> 6.147

-- imaginary part
ans = c.Im                   --1> 7.4

-- comparison
ans = (a == b)                --> false

ans = (a ~= b)                --> true

-- absolute value
ans = a:abs()                --3> 2.236

-- argument (angle)
ans = a:angle()              --3> 1.107

-- conjugated number
ans = a:conj()                --> Comp(1,-2)

-- some functions after import 
-- become default, such as
d = Comp.sqrt(-2)
ans = d.Im                   --3> 1.414

-- exp
ans = Comp.exp(d).Re         --3> 0.156

-- log
ans = Comp.log(d).Re         --3> 0.3465

-- sin 
ans = Comp.sin(d).Im         --3> 1.935

-- cos 
ans = Comp.cos(d)            --3> 2.178

-- tan
ans = Comp.tan(d).Re         --1> 0

-- sinh
ans = Comp.sinh(d).Re        --1> 0

-- cosh
ans = Comp.cosh(d)           --3> 0.156

-- tanh
ans = Comp.tanh(d).Im        --3> 6.334

-- asin
z = Comp(2,3)
ans = z:asin().Im            --3> 1.983

-- acos 
ans = z:acos().Re            --2> 1.000

-- atan
ans = z:atan().Im            --3> 0.229

-- asinh
ans = z:asinh().Re           --3> 1.968

-- acosh
ans = z:acosh().Im           --1> 1.000

-- atanh
ans = z:atanh().Re           --3> 0.146

-- make copy
ans = a:copy()                --> a

-- show
print(a)

--</pre>
<a href="#Top">Top</a></div>
<div><a name="_C"></a>
<h3># _C (const) #</h3>
<p class="descript">Collection of constants.</p>
<p><b>add(sName,value[,sUnits])</b> - Create new constant.<br>
<b>astro.ly</b> - One light year.<br>
<b>astro.pc</b> - One parsec.<br>
<b>math.e</b> - Base of the natural logarithm.<br>
<b>math.phi</b> - Golden ratio.<br>
<b>math.pi</b> - Ratio of a circle's circumference to its diameter.<br>
<b>phy.G</b> - Gravitational constant.<br>
<b>phy.NA</b> - Avogadro's number.<br>
<b>phy.R</b> - Universal gas constant.<br>
<b>phy.Rinf</b> - Rydberg constant.<br>
<b>phy.Vm</b> - Volume of one mole of ideal gas.<br>
<b>phy.c</b> - Speed of light.<br>
<b>phy.e</b> - Electron charge.<br>
<b>phy.eps0</b> - Permittivity of free space.<br>
<b>phy.g</b> - Acceleration of free fall.<br>
<b>phy.h</b> - Planck's constant.<br>
<b>phy.k</b> - Boltzmann's constant.<br>
<b>phy.mu0</b> - Permeability of free space.<br>
<b>phy.sigma</b> - Stefan-Boltzmann constant.<br>
<b>remove(sName)</b> - Delete user-defined constant.<br></p>
<pre class="example">

-- use 'const'
_C = require 'lib.const'

-- charge of electron
ans = _C.phy.e * 1E19        --3> 1.602

-- units have postfix _u
ans = _C.phy.e_u              --> 'C'

-- create "immutable" value
_C.add('myConst', 10)
ans = _C.myConst              --> 10

-- modification generate error
ans = pcall(function() _C.myConst = 0 end)  --> false

-- remove constant
_C.remove('myConst')
ans = _C.myConst              --> nil

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Geo"></a>
<h3># Geo (geodesy) #</h3>
<p class="descript">Coordinate transformations and other geodetic tasks.</p>
<p><b>A.blhInto[B]</b> - Get function to transform geodetic coordinates from A to B system using the Molodensky method.<br>
<b>A.xyzInto[B]</b> - Get function to transform coordinates from A to B system.<br>
<b>deg2dms(d)</b> - Return degrees, minutes and seconds for the given angle value.<br>
<b>dms2rad(d[,m[,s]])</b> - Convert degrees, minutes and seconds to radians.<br>
<b>fromENU(tBLr,tXYZr,tTop)</b> - Get cartesian coordinates of a local point in reference frame.<br>
<b>grav(dB)</b> - International gravity formula, angle in degrees.<br>
<b>projGK(E,tBL)</b> - Return north and east positions of the point after Gauss-Kruger projection.<br>
<b>projM(E,tBL)</b> - Return north and east positions of the point after Mercator projectoin.<br>
<b>solveDir(E,BLH,azimuth,dist)</b> - Solve direct geodetic problem, find second point position and its orientation if the first point, azimuth and distance are given.<br>
<b>solveInv(E,BLH1,BLH2)</b> - Solve inverse geodetic problem, find distance and azimuths for two points.<br>
<b>toBLH(E,tXYZ)</b> - Transform Cartesian coordinates to Geodetic.<br>
<b>toENU(tBLr,tXYZr,tCatr)</b> - Get topocentric coordinates of a point in reference frame.<br>
<b>toXYZ(E,tBLH)</b> - Transform Geodetic coordinates to Cartesian.<br></p>
<pre class="example">

-- use 'geodesy'
Geo = require 'lib.geodesy'

-- generate random from number -1 to 1
rnd = function () return 2*math.random()-1 end
-- random coordinates (degrees and meters)
t0 = {B=rnd()*90, L=rnd()*180, H=rnd()*1000}
print(t0.B, t0.L, t0.H)

--test in WGS84
wgs84 = Geo.WGS84
-- BLH to XYZ
t1 = wgs84:toXYZ(t0)
print(t1.X, t1.Y, t1.Z)

-- XYZ to BHL
t2 = wgs84:toBLH(t1)
print(t2.B, t2.L, t2.H)
ans = t2.B                 --3> t0.B

ans = t2.L                 --3> t0.L

ans = t2.H                 --3> t0.H

-- find topocentric coordinates
tg = {X=t1.X+10, Y=t1.Y+20, Z=t1.Z+30}
tc = Geo.toENU(t0, t1, tg)

-- back to cartesian
tg2 = Geo.fromENU(t0, t1, tc)
ans = tg2.X                --3> tg.X

-- transform XYZ from WGS84 to PZ90
pz90 = Geo.PZ90
-- get function
xyz_wgs84_pz90 = wgs84.xyzInto[pz90]
t3 = xyz_wgs84_pz90(t1) 

-- backward transformation
xyz_pz90_wgs84 = pz90.xyzInto[wgs84]
t4 = xyz_pz90_wgs84(t3)
ans = t4.X                 --2> t1.X

-- datum transformation
blh_wgs84_pz90 = wgs84.blhInto[pz90]
t5 = blh_wgs84_pz90(t0)

-- Gauss-Kruger projection
sk = Geo.SK42
pt = {B=55.752, L=37.618}
t6 = sk:projGK(pt)
ans = t6.N                  --2> 6181924.245

ans = t6.E                  --2> 7413223.481

-- Merkator projection
-- methods can be called directly from Geo
t7 = Geo.projM(wgs84, pt)
print(t7.N, t7.E)

-- inverse problem
p1 = {B=rnd()*50, L=rnd()*50}
p2 = {B=rnd()*50, L=rnd()*50}
s, a1, a2 = wgs84:solveInv(p1,p2)
ans = (s >= 0)               --> true

-- direct problem 
p3, a3 = wgs84:solveDir(p1,a1,s)
ans = a3                    --2> a2

ans = p3.B                  --2> p2.B

-- equator acceleration 
ans = Geo.grav(0)           --1> 9.78

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Gp"></a>
<h3># Gp (gnuplot) #</h3>
<p class="descript">Interface for calling Gnuplot from Sonata.</p>
<p><b>Gp()</b> - Prepare Gnuplot object.<br>
<b>add(tCurve)</b> - Add new curve to figure.<br>
<b>copy(G)</b> - Get copy of the plot options.<br>
<b>keys</b> -   Options / examples:<br>
{math.sin, title='sin'}           -- plot using function, define in Lua; add legend<br>
{'sin.dat', ln=1, lw=2}           -- plot data from file, use given color and width<br>
{tbl, with='lines'}               -- plot data from Lua table, use lines<br>
title='Graph name'                -- set title<br>
xrange={0,10}                     -- range of x from 0 to 10<br>
yrange={-2,2}                     -- range of y<br>
zrange={0,5}                      -- range of z<br>
trange={1,2}                      -- range for parametric functions<br>
xtitle='A', ytitle='B'            -- axes names<br>
terminal='jpeg'                   -- save result as jpeg image<br>
output='my_plot.jpg'              -- file name<br>
parametric=true                   -- create parametric plot<br>
size='square'                     -- set square size<br>
polar=true                        -- use polar coordinate system<br>
grid='polar'                      -- polar grid<br>
legend=false                      -- don't use legend<br>
surface=true                      -- plot surface in 3D<br>
samples=200                       -- define number of points<br>
raw='set pm3d'                    -- set Gnuplot options manually<br>
<br>
<b>plot(x1,[y1,[nm,[x2,..]]])</b> - 'x' is list of numbers, 'y' is either list or functin, 'nm' - curve name.<br>
<b>polarplot(x1,y1,[nm,[x2,y2..]])</b> - Make polar plot. 'x' is list of numbers, 'y' is either list or functin, 'nm' - curve name.<br>
<b>show(G)</b> - Plot data, represented as Lua table.<br>
<b>surfplot(x1,y1,fn1,[nm,[x2,y2..]])</b> - Make surfac–µ plot. 'x' and 'y' are lists of numbers, 'fn' is functin, 'nm' - surface name.<br>
<b>tplot(v,[x,y1,y2..])</b> - Plot table, matrix or data file. Optional elements define columns.<br>
<b>tpolar(v,[x,y1,y2..])</b> - Polar plot for table, matrix or data file. Optional elements define columns.<br>
<b>tsurf(v,[x1,y1,z1,z2..])</b> - Surface plot for table, matrix or data file. Optional elements define columns.<br></p>
<pre class="example">

-- use 'gnuplot'
Gp = require 'lib.gnuplot'
Gp.testmode = true -- just for testing

-- simple plot 
t1 = {1,2,3,4,5}
t2 = {2,4,6,4,2}
-- in the dialog call "plot(t1,t2,'some curve')"
Gp.plot(t1,t2,'some curve')

-- simplified function plot
Gp.plot(t1, math.sin, 'sin')

-- name can be skipped 
Gp.plot(t1, math.sin, t1, math.cos)

-- plot table (or matrix, or datafile)
arr = {}
for i = 1,50 do 
  x = 0.1*i 
  arr[i] = {x, math.sin(x), math.cos(x)}
end
-- all columns by default (for table and matrix)
Gp.tplot(arr)

-- the same, but with explicit column specification
Gp.tplot(arr,1,2,3)

-- in polar coordinate system
Gp.polarplot(t1,t2,'some curve')

-- from table
Gp.tpolar(arr,1,2) 

-- plot surface
function fun(x,y) return x*x + y*y end
Gp.surfplot(t1,t2,fun,'some surf')

-- from table 
arr2 = {}
for _,v1 in ipairs(t1) do
  for _,v2 in ipairs(t2) do
    arr2[#arr2+1] = {v1,v2,fun(v1,v2)}
  end
end
Gp.tsurf(arr2)

-- direct use Gp object
a = Gp()
a:add {math.sin, title='sin'}
a:add {math.cos, title='cos'}
a:show()

-- additional parameters
a.xrange = {0,10}   -- add rangle
-- save to file 
a.terminal = 'png'
a.output = 'test.png'
a:show()

-- copy parameters to other object
b = a:copy()
print(b)

-- send 'raw' command to Gnuplot
c = Gp()
c.raw = 'plot x**2-2*x+1; set xlabel "X"; set ylabel "Y"'
c:show()

-- print Lua table
tmp = {
  {1,1},
  {2,2},
  {3,3},
  {4,4}
}
d = Gp()
d:add {tmp,with='lines'}
d:show()

-- define function
fn1 = function (x) return x^2-x end
f = Gp()
f:add {fn1,with='lines',title='x^2-x'}
f:show()

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Graph"></a>
<h3># Graph (graph) #</h3>
<p class="descript">Operations with graphs.</p>
<p><b>Graph {v1,v2,..}</b> - Create new graph.<br>
<b>add(G,v)</b> - Add new node or edge to graph G. Node denoted as a single name, edge is a table of names (and weights if need).<br>
<b>bfs(G,vStart,vGoal)</b> - Breadth first search. Return result and found path.<br>
<b>copy(G)</b> - Get copy of the graph.<br>
<b>dfs(G,vStart,vGoal)</b> - Depth first search. Return result and found path.<br>
<b>edges(G)</b> - List of graph edges.<br>
<b>isComplete(G)</b> - Check completeness of the graph.<br>
<b>isDirected(G)</b> - Check if the graph has directed edges.<br>
<b>isNegative(G)</b> - Check if the graph has negative edges.<br>
<b>isWeighted(G)</b> - Check if any edge has weight different from 1.<br>
<b>nodes(G)</b> - List of graph nodes.<br>
<b>pathBF(G,vStart[,vGoal])</b> - Shortest path search using Bellman-Ford algorithm.<br>
<b>pathD(G,vStart[,vGoal])</b> - Find shortest path using Dijkstra's algorithm. Return table of distances and predecessors. If goal is defined, return path and its length.<br>
<b>remove(G,v)</b> - Remove node or edge from the graph G. Node is a single name, edge - table of names.<br></p>
<pre class="example">

-- use 'graph'
Graph = require 'lib.graph'

-- build graph
-- single name - node, names in brackets - edges 
-- letter w denotes weight of non directed edge
-- numbers are weights of directed edges
a = Graph {'a','b',
  {'a','c'},
  {'d','e',w=2},
  {'d','b',4,3}
}

-- list of nodes
nd = a:nodes()
ans = #nd                     --> 5

-- list of edges
-- if an edge has different weight for different sizes
-- it is represented twice
ed = a:edges()
ans = #ed                     --> 4

-- has directed edges
ans = a:isDirected()          --> true

-- add node
a:add('h') 
-- add edge
a:add {'a','d'}
-- check size
-- (same as #a)
ans = a:size()                --> 6

-- remove edge
a:remove {'a','d'}
-- remove node
a:remove('a')
-- new edge number
ed = a:edges()
ans = #ed                     --> 3

-- directed edges
-- second way to define
-- from first to second node
a:add {'c','p',w12=2} 
-- and vise versa
a:add {'c','q',w21=3}
ed = a:edges()
ans = #ed                     --> 5

-- make copy
b = a:copy()

-- completeness 
ans = b:isComplete()          --> false

-- prepare graph
c = Graph {
  {'a','b'},
  {'a','c'},
  {'b','d'},
  {'b','e'},
  {'c','f'},
  {'f','g'},
  {'f','h'},
  {'e','g'}
}

-- is it weighted 
ans = c:isWeighted()          --> false

-- breadth first search
_,path = c:bfs('e','h')
ans = path[3]                 --> 'f'

-- depth first search
found,path = c:dfs('d','c')
ans = found                   --> true

-- update weight
-- (default is 1)
-- use 'add' for it
c:add{'a','b',w=0.5}
c:add{'b','e',w=0.4}
c:add{'c','f',w=2}

-- Dijkstra path search
dist,prev = c:pathD('a') 
ans = dist['g']               --> 1.9

-- Bellman-Ford path search
c:add{'f','h',w=-0.5}
dist,prev = c:pathBF('a')
ans = dist['h'] 

-- check negative edges
ans = c:isNegative()          --> true

-- show
print(b)

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Lens"></a>
<h3># Lens (lens) #</h3>
<p class="descript">Matrix methods in paraxial optics</p>
<p><b>Lens {dA,dB,dC,dD}</b> - Make new lens component.<br>
<b>afocal(dm)</b> - Find matrix for the afocal system.<br>
<b>cardinal(L[,dn1=1,dn2=1])</b> - Find location of the cardinal points of the given system w.r.t input and output planes, use refractive indeces if need. Return list of distances.<br>
<b>copy(L)</b> - Create a copy of the object.<br>
<b>det(L)</b> - Find determinant of the system matrix.<br>
<b>inv(L)</b> - Get the inverted system matrix.<br>
<b>isUnit(L)</b> - Check if the system matrix is unit.<br>
<b>mirror(dr,dn)</b> - Find reflection matrix for the given radius and refractive index.<br>
<b>operations</b> - L1 == L2, L1 .. L2<br>
<b>ref(dr,dn1,dn2)</b> - Find refraction matrix for the given radius of surface and input and output refractive indeces.<br>
<b>solve(fn,ind,d0)</b> - Find condition when component with the given index is equal to 0, d0 is the initial assumption.<br>
<b>thin(df)</b> - Find the thin lens system matrix for the given focal distance.<br>
<b>trans(dt,dn)</b> - Find translation matrix for the given distance and refractive index.<br>
<b>transform(L,dy,dV)</b> - Find the output ray position 'dy' and optical angle 'dV' (= v*n). Equal to call L(dy,dV).<br></p>
<pre class="example">

-- use 'lens'
Lens = require 'lib.lens'
-- external dependencies, can be loaded implicitly 
Num = require 'lib.numeric' -- for root searching

-- define a simple lense 
n1 = 1      -- air 
n2 = 1.56   -- glass 
-- radius 200 mm, thickness 5 mm
lens1 = Lens.ref(200,n1,n2)..Lens.trans(5,n2)..Lens.ref(-200,n2,n1) 
ans = lens1:isUnit()          --> true

-- get matrix element
ans = lens1.D                --2> 1

-- find cardinal points 
pts = lens1:cardinal() 
ans = pts[1]                 --2> -177.76

-- print points
print(pts)

-- object is located 250 mm to the left 
-- from the lens, find position of 
-- the image 
d1 = 250
fn = function (d2)
  return Lens.trans(d1,n1)..lens1..Lens.trans(d2,n1) 
end
-- solve for B = 0, initial guess dist = 100
d2 = Lens.solve(fn, Lens.key.B, 100)  
ans = d2                     --2>  623.21

-- check solution 
-- assume the lens it thin 
f = -pts[1]
ans = 1/d1 + 1/d2            --2> 1/f

-- ray transformation 
y1 = 10          -- mm, height   
V1 = n1 * 0.05   -- optical angle
sys1 = fn(d2) 
y2, V2 = sys1(y1,V1)
ans = y2                     --2> -24.83

-- from image to object 
sys2 = sys1:inv()  -- transpose
ans, _ = sys2(y2, V2)        --3> y1

-- system matrix determinant
ans = lens1:det()            --3> 1

-- create thin lens
lens2 = Lens.thin(f)
_, V3 = lens1(y1,V1)
_, ans = lens2(y1,V1)        --2> V3

-- flat mirror 
lens3 = Lens.mirror(math.huge, n1)
_, ans = lens3(y1,V1)        --2> V1

-- afocal system 
m = 10
lens4 = Lens.afocal(m) 
ans, _ = lens4(y1,V1)        --2> m*y1

-- arbitrary system matrix 
lens5 = Lens {1, 0, -0.5, 1} 
print(lens5)

-- make copy 
ans = lens1:copy()            --> lens1

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Mat"></a>
<h3># Mat (matrix) #</h3>
<p class="descript">Matrix operations. The matrices are spares by default.</p>
<p><b>Mat {tRow1,tRow2,..}</b> - Create matrix from list of strings (tables).<br>
<b>apply(fn,M1,M2,...)</b> - Apply function to the given matrices element-wise.<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, a^b, -a<br>
<b>chol(M)</b> - Cholesky decomposition of positive definite symmetric matrix.<br>
<b>comparison</b> - a==b, a~=b<br>
<b>concat(M1,M2,sDir)</b> - Concatenate two matrices, dir='h' - in horizontal direction, dir='v' - in vertical<br>
Use M1 .. M2 for horizontal concatenation and M1 // M2 for vertical.<br>
<b>copy(M)</b> - Return copy of matrix.<br>
<b>cross(V1,V2)</b> - Cross product or two 3-element vectors.<br>
<b>det(M)</b> - Calculate determinant.<br>
<b>diag(M[,n=0])</b> - Get diagonal of the matrix or create new matrix which diagonal elements are given. n is the diagonal index.<br>
<b>dot(V1,V2)</b> - Scalar product of two 3-element vectors.<br>
<b>eye(iRows[,iCols=iRows,val=1])</b> - Create identity matrix. Diagonal value (init) can be defined.<br>
<b>fill(iRows,iCols,fn)</b> - Create matrix, using function fn(r,c).<br>
<b>inv(M)</b> - Return inverse matrix.<br>
<b>lu(M)</b> - LU decomposition for the matrix. Return L,U and P matrices.<br>
<b>map(M,fn)</b> - Apply the given function to all elements, return new matrix. Function can be in form f(x) or f(x,row,col).<br>
<b>norm(M)</b> - Euclidean norm.<br>
<b>ones(iRows[,iCols=iRows,val=1])</b> - Create matrix of given numbers (default is 1).<br>
<b>pinv(M)</b> - Pseudo inverse matrix calculation.<br>
<b>rand(iRows[,iCols=iRows])</b> - Create matrix with random numbers from 0 to 1.<br>
<b>randi([M],N,[rows],[cols=rows])</b> - Create matrix with random integer elements from 1 to N. Can be used as 'randi(M,N)' or 'randi(N,r,c)'.<br>
<b>randn(iRows[,iCols=iRows])</b> - Create matrix with normally distributed values (0 mean and unit variance)<br>
<b>rank(M)</b> - Find rank of the matrix.<br>
<b>reshape(M,iRows[=size],iCols[=1])</b> - Change matrix size.<br>
<b>rref(M)</b> - Perform transformations using Gauss method.<br>
<b>size(M)</b> - Return number or rows and columns.<br>
<b>table(M)</b> - Convert to simple Lua table.<br>
<b>tr(M)</b> - Get trace of the matrix.<br>
<b>transpose(M)</b> - Return matrix transpose. Shorten form is T().<br>
<b>zeros(rows[,cols=rows])</b> - Create matrix from zeros.<br></p>
<pre class="example">

-- use 'matrix'
Mat = require 'lib.matrix'

-- define matrix objects
a = Mat {{1,2},{3,4}}
b = Mat {{5,6},{7,8}}
-- call in typical way
ans = a[2][2]                 --> 4 

b[1][1] = 5
-- transpose
c = a:T()
-- use () as alias for get()
ans = c(1,-1)                 --> 3

-- matrix rows and columns
_, ans = a:size()             --> 2

-- arithmetical operations
ans = a + b                   --> Mat {{6,8},{10,12}}

ans = b - a                   --> Mat {{4,4},{4,4}}

ans = a * b                   --> Mat {{19,22},{43,50}}

ans = a / b 
-- determinant
ans = ans:det()              --2> 1

-- multiply to scalar
ans = 2 * a                   --> Mat {{2,4},{6,8}}

-- add scalar (to all elements)
ans = a - 1                   --> Mat {{0,1},{2,3}}

ans = a ^ 2                   --> Mat {{7,10},{15,22}} 

-- determinant
ans = a:det()                 --> -2

-- inverse matrix
e = a:inv()
ans = e(2,1)                  --> 1.5

-- another call of inversion
e = a^-1
ans = e(2,1)                  --> 1.5

-- object copy
-- (it doesn't copy zeros)
f = a:copy()
ans = (f == a)                --> true

-- element-wise comparison
ans = (a == b)                --> false

-- identity matrix
ans = Mat.eye(2)              --> Mat {{1,0},
                                       {0,1}}

-- matrix argument
ans = Mat.eye(a)              --> Mat {{1,0},
                                       {0,1}}

-- matrix of zeros
ans = Mat.zeros(2,1)          --> Mat {{0},{0}}

-- matrix of constants = 4
ans = Mat.ones(2,3,4)         --> Mat {{4,4,4},
                                       {4,4,4}}

-- matrix of constants = 1
ans = Mat.ones(a,3)           --> Mat {{3,3},{3,3}}

-- define rule to fill
-- result matrix is 'dense'
fn = function (i,j) 
  return i == j and 1 or 0 
end
ans = Mat.fill(2,3,fn)        --> Mat {{1,0,0},
                                       {0,1,0}}

-- horizontal concatenation
ans = a .. b                  --> Mat {{1,2,5,6},
                                       {3,4,7,8}}

-- vertical concatenation
-- (a // b - for short)
ans = a:concat(b,'v')         --> Mat {{1,2},{3,4},{5,6},{7,8}}

-- apply function of 1 argument
ans = a:map(function (x) return x^2 end)       --> Mat {{1,4},{9,16}}

-- apply function which depends on index too
ans = a:map(function (x,r,c) return x-r-c end) --> Mat {{-1,-1},{-0,-0}}

-- apply function to matrices
-- element-wise
fn = function (x,y,z) return x*y+z end
aa = Mat.apply(fn, b,b,b) 
ans = aa[1][1]                --> 30

-- use Gauss transform to solve equation
ans = Mat.rref(a .. Mat{{5},{11}})             --> Mat {{1,0,1},
                                                        {0,1,2}}

-- create vector
ans = Mat.V {1,2,3}           --> Mat {{1},{2},{3}}

-- get submatrix
g = Mat {
  {1,2,3},
  {4,5,6},
  {7,8,9}
}
ans = g({2,-1},{2,3})         --> Mat {{5,6},
                                       {8,9}}

-- euclidean norm
ans = Mat.V({1,2,3}):norm()  --3> math.sqrt(14)

-- random matrix
h = Mat.rand(3,2)
print(h)

-- random integer matrix
-- from 1 to 20
print(h:randi(20))

-- random matrix with 
-- normal distribution
print(Mat.randn(2,2))

-- pseudo inverse matrix
m = Mat {
  {1,2},
  {3,4},
  {5,6}
}
n = m:pinv()
ans = n(2,2)                 --3> 0.333

-- copy as Lua table
-- (without methametods)
k = Mat.eye(3)
k = k:table()
ans = k[2][1]                 --> 0

-- make diagonal matrix
ans = Mat.diag({1,2,3})       --> Mat {{1,0,0},
                                       {0,2,0},
                                       {0,0,3}}

-- shifted diagonal
ans = g:diag(1)               --> Mat {{2},{6}}

-- cross-product of 2 vectors
x1 = Mat {{1,2,3}}
x2 = Mat {{4,5,6}}
ans = Mat.cross(x1,x2)        --> Mat {{-3},{6},{-3}}

-- dot product of 2 vectors
ans = Mat.dot(x1,x2)          --> 32

-- LU transform
l,u,p = b:lu()
ans = l[2][1]                --3> 0.714

-- Cholesky decomposition
m = Mat {{3,1},{1,3}}
m = m:chol()
ans = m[2][2]                --3> 1.633

-- matrix trace
ans = a:tr()                  --> 5

-- extract first row
m = a({},1)
-- vector doesn't need in 2 indices
ans = m(1)                    --> 1

-- extract last column
-- index can be negative 
m = a(-1,{})
ans = m:get(2)                --> 4

-- get rank
ans = Mat.ones(2,3):rank()    --> 1

-- change size
tmp = Mat{
  {1,2},
  {3,4},
  {5,6}
} 
ans = tmp:reshape(2,3)        --> Mat {{1,2,3},
                                       {4,5,6}}

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Num"></a>
<h3># Num (numeric) #</h3>
<p class="descript">Group of functions for numerical calculations. Tolerance for all functions is defined with parameter TOL.</p>
<p><b>Newton(fn,d0)</b> - Find root of equation using Newton's rule with only one initial condition.<br>
<b>TOL[=0.001]</b> - The solution tolerance.<br>
<b>der(fn,x)</b> - Calculate the derivative value for given function.<br>
<b>ode45(fn,tDelta,y0[,param])</b> - Numerical approximation of the ODE solution.<br>
First parameter is differential equation, second - time interval, third - initial function value. List of parameters is optional and can includes time step or exit condition.<br>
Return table of intermediate points and result yn.<br>
<b>solve(fn,dA,dB)</b> - Find root of equation fn(x)=0 at interval [a,b].<br>
<b>trapez(fn,a,b)</b> - Get integral using trapezoidal rule.<br></p>
<pre class="example">

-- use 'numeric'
Num = require 'lib.numeric'

-- define tolerance
Num.TOL = 1e-4
-- solve 'sin(x) = 0' for x in (pi/2...3*pi/2)
a = Num.solve(math.sin, math.pi*0.5, math.pi*1.5)
ans = a                      --3> math.pi

-- Newton method
-- only one initial value
d = Num.Newton(math.sin, math.pi*0.7)
ans = d                      --3> math.pi

-- numeric derivative
b = Num.der(math.sin, 0)
ans = b                      --0> 1

-- numeric integral
c = Num.trapez(math.sin, 0, math.pi)
ans = c                      --0> 2

-- solve ODE x*y = x'
-- for x = 0..3, y(0) = 1
-- return table of solutions and y(3)
tbl, yn = Num.ode45(function (x,y) return x*y end, 
                    {0,3}, 1)
ans = yn                     --2> 90.011

-- use matrices for high order equations
Mat = require 'lib.matrix'

-- y''-2*y'+2*y = 1
-- represent as: x1 = y, x2 = y'
-- so: x1' = x2, x2' = 1+2*x2-2*x1
myfun = function (t,x) 
  return Mat.V {x(2), 1+2*x(2)-2*x(1)}
end
_, xn = Num.ode45(myfun, {0,2}, Mat.V{3,2}, {dt=0.2}) 
ans = xn(1)                  --2>  -10.54

-- define exit condition
-- from time, current and previous results
cond = function (time,current,previous) 
  return current < 0.1 
end
myfun = function (t,x) return -x end
y = Num.ode45(myfun, {0,1E2}, 1, {exit=cond})
ans = y[#y][1]               --2> 2.56

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Poly"></a>
<h3># Poly (polynomial) #</h3>
<p class="descript">Operations with polynomials.</p>
<p><b>Poly {..,v1,v0}</b> - Create a polynomial.<br>
<b>arithmetic</b> - a+b, a-b, a*b, a/b, a^n, -a<br>
<b>build(root1,root2,...)</b> - Return polynomial with given roots.<br>
<b>comparison</b> - a==b, a~=b<br>
<b>copy(P)</b> - Get copy of the polynomial.<br>
<b>der(P)</b> - Calculate derivative of polynomial.<br>
<b>fit(tX,tY,N)</b> - Find polynomial approximation for the line.<br>
<b>int(P[,d0=0])</b> - Calculate integral, d0 - free coefficient.<br>
<b>lagrange(tX,tY)</b> - Find interpolation polynomial in the Lagrange form.<br>
<b>lin(tX,tY[,v0=0,vN=v0])</b> - Linear data interpolation. Return table with polynomials.<br>
<b>ppval(tP,d[,N]</b> - Return value of a piecewise polynomial in the point and the polynomial index.<br>
<b>real(P)</b> - Find real roots of the polynomial.<br>
<b>roots(P)</b> - Find all the polynomial roots.<br>
<b>spline(tX,tY)</b> - Cubic spline data interpolation. Return table with polynomials.<br>
<b>taylor(v,vF[,vF',vF''..])</b> - Get Taylor series.<br>
<b>val(P,v)</b> - Get value of polynomial P in point x.<br></p>
<pre class="example">

-- use 'polynomial'
Poly = require 'lib.polynomial'
-- external dependencies, can be loaded implicitly
require 'lib.matrix'         -- in Poly.fit
Comp = require 'lib.complex' -- for complex roots

-- coefficients in ascendant order
a = Poly {1,2,4,3}
b = Poly {1,1}  
-- polynomial value for x=0
ans = Poly.val(a,0)           --> 3

-- simplified call
ans = a(0)                    --> 3

-- coefficient for x^3
ans = a[3]                    --> 1

-- arithmetic
ans = a + b                   --> Poly {1,2,5,4}

ans = a - b                   --> Poly {1,2,3,2}

ans = b * b                   --> Poly {1,2,1}

ans = a / b                   --> Poly {1,1,3}

ans = a % b                   --> 0

ans = b ^ 3                   --> Poly {1,3,3,1}

-- integration
-- free coefficient is 0
ans = b:int()                 --> Poly {0.5,1,0}

-- derivative
ader = a:der()
-- and its value for x=1
ans = ader(1)                 --> 11

-- build polynomial using roots
ans = Poly.build(1,-1)        --> Poly {1,0,-1}

-- use complex roots
-- don't add conjugated toots
ans = Poly.build(1, Comp(2,3))  --> Poly {1, -5, 17, -13}

-- make copy and compare
c = a:copy()
ans = (a == c)                --> true

-- not equal
ans = (b == c)                --> false

-- find real roots
e = a:real()
ans = e[1]                   --1> -1.00

-- find all roots
g = Poly.build(2, Comp(3,4))
e = g:roots()
ans = e[2].Re                --1> 3

-- fit curve with polynomial
-- of order 2
A={0,1,2,3}
B={-3,2,11,24}
p = Poly.fit(A,B,2)
ans = p(10)                  --0> 227.0

-- simple print
print(a)

-- human-friendly print
-- with variable 's' (default is 'x')
d = Poly {2,-2,1}
ans = d:str('s')              --> '2*s^2-2*s+1'

-- Lagrange polynomial 
-- for tx(x)
X = {-1.5, -0.75, 0, 0.75, 1.5}
Y = {-14.101,-0.931596,0,0.931596,14.101}
p = Poly.lagrange(X,Y)
ans = p[3]                   --3> 4.83485

-- Taylor series
-- for exp(x) near 0
p = Poly.taylor(0, 1, 1, 1, 1)
ans = p(0.3)                 --2> math.exp(0.3)

-- linear interpolation
-- use constant values out the interval
p = Poly.lin(X,Y, Y[1], Y[#Y]) 
y1, n = Poly.ppval(p, 0.5)
ans = y1                     --2> 0.621

-- polynomial index
ans = n                       --> 4

-- simplify call when index is known
ans = Poly.ppval(p, 0.5, n)  --2> y1

-- cubic spline 
p = Poly.spline(X, Y)
-- can be called without 'ppval'
ans = p(0.5)                 --2> -0.512

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Quat"></a>
<h3># Quat (quaternion) #</h3>
<p class="descript">Operations with quaternions.</p>
<p><b>Quat {w,i,j,k}</b> - Create new quaternion.<br>
<b>abs(Q)</b> - Value of the norm.<br>
<b>arithmetic</b> - a + b, a - b, a * b, a ^ k, -a<br>
<b>comparison</b> - a == b, a ~= b<br>
<b>conj(Q)</b> - Get conjugation.<br>
<b>copy(t)</b> - Create a copy of the quaternion.<br>
<b>fromAA(fAng,vAxe)</b> - Create quaternion using angle and axis.<br>
<b>fromRot(M)</b> - Convert rotation matrix to quaternion.<br>
<b>imag(Q)</b> - Get table of the imaginary part.<br>
<b>inv(Q)</b> - Find inverted quaternion.<br>
<b>mat(Q)</b> - Equivalent matrix representation.<br>
<b>normalize(Q)</b> - Make unit quaternion.<br>
<b>real(Q)</b> - Real part (same as Q.w).<br>
<b>rotate(Q,vec)</b> - Apply quaternion to rotate the vector.<br>
<b>slerp(Q1,Q2,f)</b> - Spherical linear interpolation for part t.<br>
<b>toAA(Q)</b> - Get angle and axis of rotation.<br>
<b>toRot(Q)</b> - Get equal rotation matrix.<br></p>
<pre class="example">

-- use 'quaternion'
Quat = require 'lib.quaternion'
-- external dependencies, can be loaded implicitly
require 'lib.matrix'

-- quaternion
-- set {w,i,j,k}
a = Quat {1,2,3,4}
-- part of elements
b = Quat {w=3, i=4}
ans = b                       --> Quat{3,4,0,0}

-- conjugation
ans = a:conj()                --> Quat{1,-2,-3,-4}

-- real when imaginary are zeros
ans = a + a:conj()            --> 2

-- norm
ans = b:abs()                --1> 5.000

-- inversion
c = a*a:inv()
ans = c.w                    --1> 1.000

-- arithmetic
ans = a+b                     --> Quat{4,6,3,4}

ans = a*b                     --> Quat{-5,10,25}

ans = 3*b                     --> Quat{9,12,0,0}

-- power
ans = b^3                     --> b * b * b

-- unit quaternion
a:normalize()
ans = a:abs()                --1> 1.000

-- unit power
aa = a^1.5
ans = aa.i                   --3> 0.324

ans = aa.j                   --3> 0.486

ans = aa.k                   --3> 0.648

-- rotation matrix
m = a:toRot()
d = Quat.fromRot(m)
ans = Quat.abs(d-a)          --1> 0.000

-- use angle 
-- and axis
ang = 0.5
axis = {1,1,1}
f = Quat.fromAA(ang,axis)
ans,_ = f:toAA()             --3> ang

-- rotate vector
p = a:rotate({1,0,0})
ans = p[1]                   --3> -0.667

-- spherical interpolation
d = Quat.slerp(a,b,0.5)
ans = d.w                    --3> 0.467

-- make copy
ans = d:copy()                --> d

-- show 
print(d)

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Rat"></a>
<h3># Rat (rational) #</h3>
<p class="descript">Computations with rational numbers.</p>
<p><b>De(R)</b> - Return the denominator of the rational number.<br>
<b>Nu(R)</b> - Return the numerator of rational number.<br>
<b>Rat(m[,n=1])</b> - Create rational number using num (and denom).<br>
<b>arithmetic</b> - R1+R2, R1-R2, R1*R2, R1/R2, -R, R1^R2} <br>
<b>comparison</b> - R1<R2, R1<=R2, R1>R2, R1>=R2, R1==R2, R1~=R2<br>
<b>copy(R)</b> - Get copy of the rational number.<br>
<b>eq(R1,R2)</b> - Compare two objects.<br>
<b>float(R)</b> - Return rational number as decimal.<br>
<b>gcd(va,vb)</b> - Calculate the greatest common divisor for two integers.<br></p>
<pre class="example">

-- use 'rational'
Rat = require 'lib.rational'

-- numerator, denominator
a = Rat(1,2)
-- only numerator
b = Rat(2)
ans = b                       --> Rat(2,1)

-- simplification
k = 234781
ans = Rat(2*k,3*k)            --> Rat(2,3)

-- arithmetic
ans = a + b                   --> Rat(5,2)

ans = 2 * a                   --> 1

ans = Rat(2,3)*Rat(3,2)       --> 1

ans = a / Rat(1,3)            --> Rat(3,2)

ans = a ^ 3                   --> Rat(1,8)

ans = 2 ^ a                  --3> 1.414

-- comparison
ans = (b == b)                --> true

ans = (a >= b)                --> false

-- greatest common division
ans = Rat.gcd(125,65)         --> 5

-- represent as decimal
ans = a:float()               --> 0.5

-- numerator
ans = b:Nu()                  --> 2

-- denominator
ans = b:De()                  --> 1

-- make copy
ans = a:copy()                --> a

-- show
print(a)

-- result is rational 
ans = a + 1                   --> Rat(3,2)

-- result is float
ans = a + 0.5                 --> 1

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Spec"></a>
<h3># Spec (special) #</h3>
<p class="descript">Special mathematical functions.</p>
<p><b>besseli(N,x)</b> - Modified Bessel function In(x).<br>
<b>besselj(N,x)</b> - Bessel function of the first kind.<br>
<b>besselk(N,x)</b> - Modified Bessel function Kn(x).<br>
<b>bessely(n,x)</b> - Bessel function of the second kind.<br>
<b>beta(z,w)</b> - Beta function.<br>
<b>betainc(x,a,b)</b> - Incomplete beta function Ix(a,b).<br>
<b>betaln(z,w)</b> - Natural logarithm of beta function.<br>
<b>dawson(x)</b> - Dawson integral.<br>
<b>erf(x)</b> - Error function.<br>
<b>erfc(x)</b> - Complementary error function.<br>
<b>expint(n,x)</b> - Exponential integral En(x).<br>
<b>gamma(z)</b> - Gamma function.<br>
<b>gammainc(x,N[,type='lower'])</b> - Incomplete gamma function, P (type='lower') or Q (type='upper').<br>
<b>gammaln(z)</b> - Natural logarithm of gamma function.<br>
<b>gammp(N,x)</b> - Incomplete gamma function P(N,x).<br>
<b>gammq(N,x)</b> - Incomplete gamma function Q(N,x) = 1-P(N,x).<br>
<b>legendre(n,x)</b> - Return list of Legendre polynomial coefficients.<br></p>
<pre class="example">

-- use 'special'
Spec = require 'lib.special'

-- beta functions
ans = Spec.beta(3,4) * 1E2   --3> 1.667

ans = Spec.betaln(10,20)     --3> -19.115

ans = Spec.betainc(0.5, 2, 3.3)  --3> 0.7309

-- error functions
ans = Spec.erf(1)            --3> 0.8427

ans = Spec.erfc(0.5)         --3> 0.4795

-- Ei(x)
ans = Spec.expint(3.3) * 1E3     --3> 8.939

-- E3(x)
ans = Spec.expint(2, 5) * 1E4    --3> 9.965

-- gamma functions
ans = Spec.gamma(-1.5)       --3> 2.3633

ans = Spec.gammaln(100)      --3> 359.1342

ans = Spec.gammp(7.7, 2.3) * 1E3 --2> 3.85

ans = Spec.gammq(1.5, 4.8) * 1E2 --2> 2.23

-- another syntax
ans = Spec.gammainc(2.1, 0.3, 'upper') * 1E2 --3> 1.942

-- Bessel functions
ans = Spec.besselj(3, 1.5) * 1E2 --3> 6.096

ans = Spec.bessely(4, 0.8)   --3> -78.751

ans = Spec.besseli(2, -3.6)  --3> 4.254

ans = Spec.besselk(5, 5) * 1E2   --3> 3.2706

-- Legendre function
lst = Spec.legendre(3, 0.5)
ans = lst[1]                 --3> -0.4375

-- Dawson function
ans = Spec.dawson(3.3)       --3> 0.1598

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Stat"></a>
<h3># Stat (stat) #</h3>
<p class="descript">Statistical calculations. Data set must be a Lua table.</p>
<p><b>freq(t)</b> - Return table with frequencies of elements.<br>
<b>geomean(t[,tw])</b> - Geometrical mean.<br>
<b>harmmean(t[,tw])</b> - Harmonic mean.<br>
<b>histcounts(X[,rng=10])</b> - Calculate amount of bins. Edges can be either number or table.<br>
<b>max(t)</b> - Maximal element and its index.<br>
<b>mean(t[,tw])</b> - Calculate average value. Weights can be used.<br>
<b>median(t)</b> - Median of the list.<br>
<b>min(t)</b> - Minimal element and its index.<br>
<b>moment(N,t[,tw])</b> - Central moment of t order N, tw is a list of weights.<br>
<b>std(t[,tw])</b> - Standard deviation and variance. Weights can be used.<br>
<b>sum(t)</b> - Get sum of all elements.<br>
<b>tcdf(d,N)</b> - Student's cumulative distribution.<br>
<b>tpdf(d,N)</b> - Student's distribution density.<br></p>
<pre class="example">

-- use 'stat'
Stat = require 'lib.stat'
-- external dependencies, can be loaded implicitly
require 'lib.special'

-- initial data (tables)
X = {3,2,5,6,3,4,3,1}
w = {1,1,0,1,2,2,1,1}
-- average
ans = Stat.mean(X)           --3> 3.375

-- standard deviation
ans, tmp = Stat.std(X,W)     --3> 1.495

-- variance
ans = tmp                    --3> 2.234

-- maximum element and index
_,ans = Stat.max(X)           --> 4 

-- median
ans = Stat.median(X)          --> 3

-- table of frequencies
tmp = Stat.freq(X)
ans = tmp[3]                  --> 3

-- central moment
ans = Stat.moment(2,X)       --3> 2.234

-- summ of elements
ans = Stat.sum(X)             --> 27

-- minimum value
ans = Stat.min(X)             --> 1

-- geometrical mean
ans = Stat.geomean(X)        --3> 2.995

-- harmonic mean
ans = Stat.harmmean(X,W)     --3> 2.567

-- find histogram
a,b = Stat.histcounts(X, 3)
ans = b[1]                    --> 1

-- define edges 
a,b = Stat.histcounts(X,{0,4,7})  
ans = a[1]                    --> 5 

-- Student cdf and pdf
ans = Stat.tcdf(4, 2.5)      --3> 0.9805

ans = Stat.tpdf(2, 3.3)      --3> 0.0672

--</pre>
<a href="#Top">Top</a></div>
<div><a name="Unit"></a>
<h3># Unit (units) #</h3>
<p class="descript">Operations and conversations according the units.</p>
<p><b>Unit(v[,u])</b> - Create new elements with units.<br>
<b>add(U,rule)</b> - Add new rule for conversation.<br>
<b>arithmetic</b> - U1+U2, U1-U2, U1*u2, U1/U2, U1^n<br>
<b>comparison</b> - U1==U2, U1~=U2, U1<U2, U1<=U2, U1>U2, U1>=U2<br>
<b>convert(v, fn)</b> - Convert one units to another, return new object or nil.<br>
<b>copy(U)</b> - Create copy of the element.<br>
<b>prefix</b> - Table of possible prefixes for units.<br></p>
<pre class="example">

-- use 'units'
Unit = require 'lib.units'

-- add some rules
Unit.add('h', Unit(60,'min'))
Unit.add('min', Unit(60,'s'))

-- define variable
a = Unit(1,'m/s')
-- convert to km/h, get only value
ans = a['km/h']               --> 3.6

-- get numerical value
-- (the save as #a)
ans = a:val()                 --> 1

-- make copy
cp = a:copy() 
ans = cp                      --> Unit(1,'m/s')

-- get converted variable
b = a:convert('km/h')
ans = b                       --> Unit(3.6, 'km/h')

-- arithmetic
b = 3 * b
ans = a + b                   --> Unit(4, 'm/s')

ans = b - a                   --> Unit(2, 'm/s')

ans = a * b                   --> Unit(3, 'm^2/s^2')

ans = b / a                   --> Unit(3)

ans = (a < b)                 --> true

ans = b ^ 3                   --> Unit(27, 'm^3/s^3')

-- new rule
Unit.add('snake', Unit(48, 'parrot'))
-- define variable
c = Unit(2,'snake')
-- convert
ans = c['parrot']             --> 96

-- convert using prefix
ans = c['ksnake']             --> 0.002

-- complex rule
d = Unit(1,'W')
-- define function for conversation, apply it
lg = function (x) 
  return math.log(x)/math.log(10) 
end
e = d:convert(function (x) 
  return Unit( 10*lg((x/Unit('mW')):simp()), 'dBm') 
end)
ans = #e                     --0> 30

-- another definition syntax
ans = 2 * Unit('N')           --> Unit(2,'N')

-- show result
print(a)
--</pre>
<a href="#Top">Top</a></div>
<div><p align="center"><i>2017-2022, Stanislav Mikhel</i></p></div>
</body></html>